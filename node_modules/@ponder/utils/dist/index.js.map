{"version":3,"sources":["../src/getLogsRetryHelper.ts","../src/mergeAbis.ts","../src/loadBalance.ts","../../common/src/promiseWithResolvers.ts","../../common/src/queue.ts","../src/rateLimit.ts","../src/replaceBigInts.ts"],"sourcesContent":["import {\n  type Address,\n  type Hex,\n  type LogTopic,\n  type RpcError,\n  hexToBigInt,\n  numberToHex,\n} from \"viem\";\n\nexport type GetLogsRetryHelperParameters = {\n  error: RpcError;\n  params: [\n    {\n      address?: Address | Address[];\n      topics?: LogTopic[];\n      fromBlock: Hex;\n      toBlock: Hex;\n    },\n  ];\n};\n\nexport type GetLogsRetryHelperReturnType =\n  | {\n      shouldRetry: true;\n      /** Suggested values to use for (fromBlock, toBlock) in follow-up eth_getLogs requests. */\n      ranges: { fromBlock: Hex; toBlock: Hex }[];\n    }\n  | {\n      shouldRetry: false;\n      /** Suggested values to use for (fromBlock, toBlock) in follow-up eth_getLogs requests. */\n      ranges?: never;\n    };\n\nexport const getLogsRetryHelper = ({\n  params,\n  error,\n}: GetLogsRetryHelperParameters): GetLogsRetryHelperReturnType => {\n  const sError = JSON.stringify(error);\n  let match: RegExpMatchArray | null;\n\n  // Cloudflare\n  match = sError.match(/Max range: (\\d+)/);\n  if (match !== null) {\n    const ranges = chunk({ params, range: BigInt(match[1]!) - 1n });\n\n    if (isRangeUnchanged(params, ranges)) {\n      return { shouldRetry: false } as const;\n    }\n\n    return {\n      shouldRetry: true,\n      ranges,\n    } as const;\n  }\n\n  // infura, thirdweb, zksync\n  match = sError.match(\n    /Try with this block range \\[0x([0-9a-fA-F]+),\\s*0x([0-9a-fA-F]+)\\]/,\n  )!;\n  if (match !== null) {\n    const start = hexToBigInt(`0x${match[1]}`);\n    const end = hexToBigInt(`0x${match[2]}`);\n    const range = end - start;\n\n    const ranges = chunk({ params, range });\n\n    if (isRangeUnchanged(params, ranges)) {\n      return { shouldRetry: false } as const;\n    }\n\n    return {\n      shouldRetry: true,\n      ranges,\n    } as const;\n  }\n\n  // ankr\n  match = sError.match(\"block range is too wide\");\n  if (match !== null && error.code === -32600) {\n    const ranges = chunk({ params, range: 3000n });\n\n    if (isRangeUnchanged(params, ranges)) {\n      return { shouldRetry: false } as const;\n    }\n\n    return {\n      shouldRetry: true,\n      ranges,\n    } as const;\n  }\n\n  // alchemy\n  match = sError.match(\n    /this block range should work: \\[0x([0-9a-fA-F]+),\\s*0x([0-9a-fA-F]+)\\]/,\n  );\n  if (match !== null) {\n    const start = hexToBigInt(`0x${match[1]}`);\n    const end = hexToBigInt(`0x${match[2]}`);\n    const range = end - start;\n\n    const ranges = chunk({ params, range });\n\n    if (isRangeUnchanged(params, ranges)) {\n      return { shouldRetry: false } as const;\n    }\n\n    return {\n      shouldRetry: true,\n      ranges,\n    } as const;\n  }\n\n  // quicknode, 1rpc, blast\n  match = sError.match(/limited to a ([\\d,.]+)/);\n  if (match !== null) {\n    const ranges = chunk({\n      params,\n      range: BigInt(match[1]!.replace(/[,.]/g, \"\")),\n    });\n\n    if (isRangeUnchanged(params, ranges)) {\n      return { shouldRetry: false } as const;\n    }\n\n    return {\n      shouldRetry: true,\n      ranges,\n    } as const;\n  }\n\n  // blockpi\n  match = sError.match(/limited to ([\\d,.]+) block/);\n  if (match !== null) {\n    const ranges = chunk({\n      params,\n      range: BigInt(match[1]!.replace(/[,.]/g, \"\")),\n    });\n\n    if (isRangeUnchanged(params, ranges)) {\n      return { shouldRetry: false } as const;\n    }\n\n    return {\n      shouldRetry: true,\n      ranges,\n    } as const;\n  }\n\n  // 1rpc\n  match = sError.match(/response size should not greater than \\d+ bytes/);\n  if (match !== null) {\n    const ranges = chunk({\n      params,\n      range:\n        (hexToBigInt(params[0].toBlock) - hexToBigInt(params[0].fromBlock)) /\n        2n,\n    });\n\n    if (isRangeUnchanged(params, ranges)) {\n      return { shouldRetry: false } as const;\n    }\n\n    return {\n      shouldRetry: true,\n      ranges,\n    } as const;\n  }\n\n  // zkevm\n  match = sError.match(/query returned more than \\d+ results/);\n  if (match !== null) {\n    const ranges = chunk({\n      params,\n      range:\n        (hexToBigInt(params[0].toBlock) - hexToBigInt(params[0].fromBlock)) /\n        2n,\n    });\n\n    if (isRangeUnchanged(params, ranges)) {\n      return { shouldRetry: false } as const;\n    }\n\n    return {\n      shouldRetry: true,\n      ranges,\n    } as const;\n  }\n\n  // llamarpc\n  match = sError.match(/query exceeds max results/);\n  if (match !== null) {\n    const ranges = chunk({\n      params,\n      range:\n        (hexToBigInt(params[0].toBlock) - hexToBigInt(params[0].fromBlock)) /\n        2n,\n    });\n\n    if (isRangeUnchanged(params, ranges)) {\n      return { shouldRetry: false } as const;\n    }\n\n    return {\n      shouldRetry: true,\n      ranges,\n    } as const;\n  }\n\n  // optimism\n  match = sError.match(/backend response too large/);\n  if (match !== null) {\n    const ranges = chunk({\n      params,\n      range:\n        (hexToBigInt(params[0].toBlock) - hexToBigInt(params[0].fromBlock)) /\n        2n,\n    });\n\n    if (isRangeUnchanged(params, ranges)) {\n      return { shouldRetry: false } as const;\n    }\n\n    return {\n      shouldRetry: true,\n      ranges,\n    } as const;\n  }\n\n  // base\n  match = sError.match(/block range too large/);\n  if (match !== null) {\n    const ranges = chunk({\n      params,\n      range: 2_000n,\n    });\n\n    if (isRangeUnchanged(params, ranges)) {\n      return { shouldRetry: false } as const;\n    }\n\n    return {\n      shouldRetry: true,\n      ranges,\n    } as const;\n  }\n\n  // arbitrum\n  match = sError.match(/logs matched by query exceeds limit of 10000/);\n  if (match !== null) {\n    const ranges = chunk({\n      params,\n      range:\n        (hexToBigInt(params[0].toBlock) - hexToBigInt(params[0].fromBlock)) /\n        2n,\n    });\n\n    if (isRangeUnchanged(params, ranges)) {\n      return { shouldRetry: false } as const;\n    }\n\n    return {\n      shouldRetry: true,\n      ranges,\n    } as const;\n  }\n\n  // blast (paid)\n  match = sError.match(\n    /exceeds the range allowed for your plan \\(\\d+ > (\\d+)\\)/,\n  );\n  if (match !== null) {\n    const ranges = chunk({ params, range: BigInt(match[1]!) });\n\n    if (isRangeUnchanged(params, ranges)) {\n      return { shouldRetry: false } as const;\n    }\n\n    return {\n      shouldRetry: true,\n      ranges,\n    } as const;\n  }\n\n  // chainstack\n  match = sError.match(/Block range limit exceeded./);\n  if (match !== null) {\n    const prevRange =\n      hexToBigInt(params[0].toBlock) - hexToBigInt(params[0].fromBlock);\n\n    // chainstack has different limits for free and paid plans.\n    const ranges =\n      prevRange < 10_000n\n        ? chunk({ params, range: 100n })\n        : chunk({ params, range: 10_000n });\n\n    if (isRangeUnchanged(params, ranges)) {\n      return { shouldRetry: false } as const;\n    }\n\n    return {\n      shouldRetry: true,\n      ranges,\n    } as const;\n  }\n\n  // No match found\n  return {\n    shouldRetry: false,\n  } as const;\n};\n\nconst isRangeUnchanged = (\n  params: GetLogsRetryHelperParameters[\"params\"],\n  ranges: Extract<\n    GetLogsRetryHelperReturnType,\n    { shouldRetry: true }\n  >[\"ranges\"],\n) => {\n  return (\n    ranges.length === 0 ||\n    (ranges.length === 1 &&\n      ranges[0]!.fromBlock === params[0].fromBlock &&\n      ranges[0]!.toBlock === params[0].toBlock)\n  );\n};\n\nconst chunk = ({\n  params,\n  range,\n}: { params: GetLogsRetryHelperParameters[\"params\"]; range: bigint }) => {\n  const ranges: { fromBlock: Hex; toBlock: Hex }[] = [];\n\n  const fromBlock = hexToBigInt(params[0].fromBlock);\n  const toBlock = hexToBigInt(params[0].toBlock);\n\n  for (let start = fromBlock; start <= toBlock; start += range + 1n) {\n    const end = start + range > toBlock ? toBlock : start + range;\n\n    ranges.push({\n      fromBlock: numberToHex(start),\n      toBlock: numberToHex(end),\n    });\n  }\n\n  return ranges;\n};\n","import type { Abi, AbiItem } from \"viem\";\nimport { formatAbiItem } from \"viem/utils\";\n\ntype MergeAbi<\n  TBase extends Abi,\n  TInsert extends Abi,\n> = TInsert extends readonly [\n  infer First extends AbiItem,\n  ...infer Rest extends Abi,\n]\n  ? Extract<TBase[number], First> extends never\n    ? First[\"type\"] extends \"constructor\" | \"receive\" | \"fallback\"\n      ? MergeAbi<TBase, Rest>\n      : MergeAbi<readonly [...TBase, First], Rest>\n    : MergeAbi<TBase, Rest>\n  : TBase;\n\nexport type MergeAbis<\n  TAbis extends readonly Abi[],\n  TMerged extends Abi = [],\n> = TAbis extends readonly [\n  infer First extends Abi,\n  ...infer Rest extends readonly Abi[],\n]\n  ? MergeAbis<Rest, MergeAbi<TMerged, First>>\n  : TMerged;\n\nconst isAbiItemEqual = (a: AbiItem, b: AbiItem): boolean =>\n  formatAbiItem(a) === formatAbiItem(b);\n\n/**\n * Combine multiple ABIs into one, removing duplicates if necessary.\n */\nexport const mergeAbis = <const TAbis extends readonly Abi[]>(abis: TAbis) => {\n  let merged: Abi = [];\n\n  for (const abi of abis) {\n    for (const item of abi) {\n      // Don't add a duplicate items\n      // if item is constructor, receive, fallback, or already in merged, don't add it\n      if (\n        item.type !== \"constructor\" &&\n        item.type !== \"receive\" &&\n        item.type !== \"fallback\" &&\n        !merged.some((m) => isAbiItemEqual(m, item))\n      ) {\n        merged = [...merged, item];\n      }\n    }\n  }\n\n  return merged as MergeAbis<TAbis>;\n};\n","import { type Transport, type TransportConfig, createTransport } from \"viem\";\n\n/**\n * @description Creates a load balanced transport that spreads requests between child transports using a round robin algorithm.\n */\nexport const loadBalance = (_transports: Transport[]): Transport => {\n  return ({ chain, retryCount, timeout }) => {\n    const transports = _transports.map((t) =>\n      chain === undefined\n        ? t({ retryCount: 0, timeout })\n        : t({ chain, retryCount: 0, timeout }),\n    );\n\n    let index = 0;\n\n    return createTransport({\n      key: \"loadBalance\",\n      name: \"Load Balance\",\n      request: (body) => {\n        const response = transports[index++]!.request(body);\n        if (index === transports.length) index = 0;\n\n        return response;\n      },\n      retryCount,\n      timeout,\n      type: \"loadBalance\",\n    } as TransportConfig);\n  };\n};\n","export type PromiseWithResolvers<TPromise> = {\n  resolve: (arg: TPromise) => void;\n  reject: (error: Error) => void;\n  promise: Promise<TPromise>;\n};\n\n/**\n * @description Application level polyfill.\n */\nexport const promiseWithResolvers = <\n  TPromise,\n>(): PromiseWithResolvers<TPromise> => {\n  let resolve: (arg: TPromise) => void;\n  let reject: (error: Error) => void;\n  const promise = new Promise<TPromise>((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  return { resolve: resolve!, reject: reject!, promise };\n};\n","import {\n  type PromiseWithResolvers,\n  promiseWithResolvers,\n} from \"./promiseWithResolvers.js\";\n\nexport type InnerQueue<returnType, taskType> = {\n  task: taskType;\n  resolve: (arg: returnType) => void;\n  reject: (error: Error) => void;\n}[];\n\nexport type Queue<returnType, taskType> = {\n  size: () => number;\n  pending: () => Promise<number>;\n  add: (task: taskType) => Promise<returnType>;\n  clear: () => void;\n  isStarted: () => boolean;\n  start: () => Promise<void>;\n  pause: () => void;\n  onIdle: () => Promise<void>;\n  onEmpty: () => Promise<void>;\n  setParameters: (\n    parameters: Pick<\n      CreateQueueParameters<unknown, unknown>,\n      \"frequency\" | \"concurrency\"\n    >,\n  ) => void;\n};\n\nexport type CreateQueueParameters<returnType, taskType> = {\n  worker: (task: taskType) => Promise<returnType>;\n  initialStart?: boolean;\n  browser?: boolean;\n} & (\n  | {\n      concurrency: number;\n      frequency: number;\n    }\n  | { concurrency: number; frequency?: undefined }\n  | { concurrency?: undefined; frequency: number }\n);\n\nconst validateParameters = ({\n  concurrency,\n  frequency,\n}: Pick<\n  CreateQueueParameters<unknown, unknown>,\n  \"frequency\" | \"concurrency\"\n>) => {\n  if (concurrency === undefined && frequency === undefined) {\n    throw new Error(\n      \"Invalid queue configuration, must specify either 'concurrency' or 'frequency'.\",\n    );\n  }\n\n  if (concurrency !== undefined && concurrency <= 0) {\n    throw new Error(\n      `Invalid value for queue 'concurrency' option. Got ${concurrency}, expected a number greater than zero.`,\n    );\n  }\n\n  if (frequency !== undefined && frequency <= 0) {\n    throw new Error(\n      `Invalid value for queue 'frequency' option. Got ${frequency}, expected a number greater than zero.`,\n    );\n  }\n};\n\nexport const createQueue = <returnType, taskType = void>({\n  worker,\n  initialStart = false,\n  browser = true,\n  ..._parameters\n}: CreateQueueParameters<returnType, taskType>): Queue<\n  returnType,\n  taskType\n> => {\n  validateParameters(_parameters);\n\n  const parameters: Pick<\n    CreateQueueParameters<unknown, unknown>,\n    \"frequency\" | \"concurrency\"\n  > = _parameters;\n  let queue = new Array<InnerQueue<returnType, taskType>[number]>();\n  let pending = 0;\n  let timestamp = 0;\n  let requests = 0;\n  let isStarted = initialStart;\n\n  let timer: NodeJS.Timeout | undefined;\n\n  let emptyPromiseWithResolvers:\n    | (PromiseWithResolvers<void> & { completed: boolean })\n    | undefined = undefined;\n  let idlePromiseWithResolvers:\n    | (PromiseWithResolvers<void> & { completed: boolean })\n    | undefined = undefined;\n\n  const next = () => {\n    if (!isStarted) return;\n\n    const _timestamp = Date.now();\n\n    if (Math.floor(_timestamp / 1_000) !== timestamp) {\n      requests = 0;\n      timestamp = Math.floor(_timestamp / 1_000);\n    }\n\n    if (timer) return;\n\n    while (\n      (parameters.frequency !== undefined\n        ? requests < parameters.frequency\n        : true) &&\n      (parameters.concurrency !== undefined\n        ? pending < parameters.concurrency\n        : true) &&\n      queue.length > 0\n    ) {\n      const { task, resolve, reject } = queue.shift()!;\n\n      requests++;\n      pending++;\n\n      worker(task)\n        .then(resolve)\n        .catch(reject)\n        .finally(() => {\n          pending--;\n\n          if (\n            idlePromiseWithResolvers !== undefined &&\n            queue.length === 0 &&\n            pending === 0\n          ) {\n            idlePromiseWithResolvers.resolve();\n            idlePromiseWithResolvers.completed = true;\n          }\n\n          browser ? next() : process.nextTick(next);\n        });\n\n      if (emptyPromiseWithResolvers !== undefined && queue.length === 0) {\n        emptyPromiseWithResolvers.resolve();\n        emptyPromiseWithResolvers.completed = true;\n      }\n    }\n\n    if (\n      parameters.frequency !== undefined &&\n      requests >= parameters.frequency\n    ) {\n      timer = setTimeout(\n        () => {\n          timer = undefined;\n          next();\n        },\n        1_000 - (_timestamp % 1_000),\n      );\n      return;\n    }\n  };\n\n  return {\n    size: () => queue.length,\n    pending: () => {\n      if (browser) {\n        return new Promise<number>((resolve) =>\n          setTimeout(() => resolve(pending)),\n        );\n      } else {\n        return new Promise<number>((resolve) =>\n          setImmediate(() => resolve(pending)),\n        );\n      }\n    },\n    add: (task: taskType) => {\n      const { promise, resolve, reject } = promiseWithResolvers<returnType>();\n      queue.push({ task, resolve, reject });\n\n      next();\n\n      return promise;\n    },\n    clear: () => {\n      queue = new Array<InnerQueue<returnType, taskType>[number]>();\n      clearTimeout(timer);\n      timer = undefined;\n    },\n    isStarted: () => isStarted,\n    start: () => {\n      if (browser) {\n        return new Promise<number>((resolve) =>\n          setTimeout(() => resolve(pending)),\n        ).then(() => {\n          isStarted = true;\n          next();\n        });\n      } else {\n        return new Promise<number>((resolve) =>\n          process.nextTick(() => resolve(pending)),\n        ).then(() => {\n          isStarted = true;\n          next();\n        });\n      }\n    },\n    pause: () => {\n      isStarted = false;\n    },\n    onIdle: () => {\n      if (\n        idlePromiseWithResolvers === undefined ||\n        idlePromiseWithResolvers.completed\n      ) {\n        if (queue.length === 0 && pending === 0) return Promise.resolve();\n\n        idlePromiseWithResolvers = {\n          ...promiseWithResolvers<void>(),\n          completed: false,\n        };\n      }\n      return idlePromiseWithResolvers.promise;\n    },\n    onEmpty: () => {\n      if (\n        emptyPromiseWithResolvers === undefined ||\n        emptyPromiseWithResolvers.completed\n      ) {\n        if (queue.length === 0) return Promise.resolve();\n\n        emptyPromiseWithResolvers = {\n          ...promiseWithResolvers<void>(),\n          completed: false,\n        };\n      }\n      return emptyPromiseWithResolvers.promise;\n    },\n    setParameters: (_parameters) => {\n      validateParameters(_parameters);\n\n      if (\"frequency\" in _parameters) {\n        parameters.frequency = _parameters.frequency;\n      }\n      if (\"concurrency\" in _parameters) {\n        parameters.concurrency = _parameters.concurrency;\n      }\n    },\n  } as Queue<returnType, taskType>;\n};\n","import { createQueue } from \"@ponder/common\";\nimport { type Transport, type TransportConfig, createTransport } from \"viem\";\n\n/**\n * @description Creates a rate limited transport that throttles request throughput.\n */\nexport const rateLimit = (\n  _transport: Transport,\n  {\n    requestsPerSecond,\n    browser = true,\n  }: { requestsPerSecond: number; browser?: boolean },\n): Transport => {\n  return ({ chain, retryCount, timeout }) => {\n    const transport =\n      chain === undefined\n        ? _transport({ retryCount: 0, timeout })\n        : _transport({ chain, retryCount: 0, timeout });\n\n    const queue = createQueue({\n      frequency: requestsPerSecond,\n      concurrency: Math.ceil(requestsPerSecond / 4),\n      initialStart: true,\n      browser,\n      worker: (body: {\n        method: string;\n        params?: unknown;\n      }) => {\n        return transport.request(body);\n      },\n    });\n\n    return createTransport({\n      key: \"rateLimit\",\n      name: \"Rate Limit\",\n      request: (body) => {\n        return queue.add(body);\n      },\n      retryCount,\n      type: \"rateLimit\",\n    } as TransportConfig);\n  };\n};\n","type _ReplaceBigInts<\n  arr extends readonly unknown[],\n  type,\n  result extends readonly unknown[] = [],\n> = arr extends [infer first, ...infer rest]\n  ? _ReplaceBigInts<\n      rest,\n      type,\n      readonly [...result, first extends bigint ? type : first]\n    >\n  : result;\n\nexport type ReplaceBigInts<obj, type> = obj extends bigint\n  ? type\n  : obj extends unknown[]\n    ? _ReplaceBigInts<Readonly<obj>, type>\n    : obj extends readonly []\n      ? _ReplaceBigInts<obj, type>\n      : obj extends object\n        ? { [key in keyof obj]: ReplaceBigInts<obj[key], type> }\n        : obj;\n\nexport const replaceBigInts = <const T, const type>(\n  obj: T,\n  replacer: (x: bigint) => type,\n): ReplaceBigInts<T, type> => {\n  if (typeof obj === \"bigint\") return replacer(obj) as ReplaceBigInts<T, type>;\n  if (Array.isArray(obj))\n    return obj.map((x) => replaceBigInts(x, replacer)) as ReplaceBigInts<\n      T,\n      type\n    >;\n  if (obj && typeof obj === \"object\")\n    return Object.fromEntries(\n      Object.entries(obj).map(([k, v]) => [k, replaceBigInts(v, replacer)]),\n    ) as ReplaceBigInts<T, type>;\n  return obj as ReplaceBigInts<T, type>;\n};\n"],"mappings":"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","names":["_parameters","createTransport"]}
{"version":3,"sources":["../../src/bin/ponder.ts","../../src/utils/extend.ts","../../src/build/service.ts","../../src/build/configAndIndexingFunctions.ts","../../src/utils/duplicates.ts","../../src/config/abi.ts","../../src/utils/lowercase.ts","../../src/utils/offset.ts","../../src/config/factories.ts","../../src/utils/chains.ts","../../src/config/networks.ts","../../src/config/sources.ts","../../../common/src/promiseWithResolvers.ts","../../../common/src/debounce.ts","../../../common/src/dedupe.ts","../../../common/src/queue.ts","../../src/build/plugin.ts","../../src/build/schema.ts","../../src/build/stacktrace.ts","../../src/build/index.ts","../../src/common/codegen.ts","../../src/common/logger.ts","../../src/common/metrics.ts","../../src/common/options.ts","../../src/common/telemetry.ts","../../src/utils/timer.ts","../../src/utils/wait.ts","../../src/bin/utils/shutdown.ts","../../src/bin/commands/codegen.ts","../../src/bin/commands/dev.ts","../../src/utils/format.ts","../../src/ui/app.tsx","../../src/ui/ProgressBar.tsx","../../src/ui/Table.tsx","../../src/ui/service.ts","../../src/sync-store/postgres/migrations.ts","../../src/utils/checkpoint.ts","../../src/utils/hash.ts","../../src/utils/pg.ts","../../src/utils/print.ts","../../src/database/postgres/service.ts","../../src/database/kysely.ts","../../src/database/revert.ts","../../src/database/postgres/migrations.ts","../../src/database/sqlite/service.ts","../../src/sync-store/sqlite/migrations.ts","../../src/utils/sqlite.ts","../../src/utils/exists.ts","../../src/database/sqlite/migrations.ts","../../src/indexing-store/historical.ts","../../src/utils/encoding.ts","../../src/utils/never.ts","../../src/indexing-store/utils/encoding.ts","../../src/indexing-store/utils/errors.ts","../../src/indexing-store/utils/filter.ts","../../src/indexing-store/metadata.ts","../../src/indexing-store/readonly.ts","../../src/utils/serialize.ts","../../src/indexing-store/utils/cursor.ts","../../src/indexing-store/utils/sort.ts","../../src/indexing-store/realtime.ts","../../src/indexing/service.ts","../../src/indexing/addStackTrace.ts","../../src/indexing/ponderActions.ts","../../src/indexing/index.ts","../../src/utils/fragments.ts","../../src/utils/interval.ts","../../src/utils/range.ts","../../src/sync-store/postgres/store.ts","../../src/sync-store/postgres/encoding.ts","../../src/sync-store/sqlite/store.ts","../../src/sync-store/sqlite/encoding.ts","../../src/sync/events.ts","../../src/sync/index.ts","../../src/utils/queue.ts","../../src/sync-historical/service.ts","../../src/sync-realtime/service.ts","../../src/sync-realtime/bloom.ts","../../src/sync-realtime/filter.ts","../../src/sync-realtime/format.ts","../../src/sync-realtime/index.ts","../../src/utils/requestQueue.ts","../../src/sync/service.ts","../../src/sync/transport.ts","../../src/bin/utils/run.ts","../../src/server/service.ts","../../src/drizzle/runtime.ts","../../src/drizzle/bigint.ts","../../src/drizzle/hex.ts","../../src/drizzle/json.ts","../../src/drizzle/list.ts","../../src/hono/index.ts","../../src/server/error.ts","../../src/bin/utils/runServer.ts","../../src/bin/commands/serve.ts","../../src/bin/commands/start.ts"],"sourcesContent":["#!/usr/bin/env node\nimport { readFileSync } from \"node:fs\";\nimport { dirname, resolve } from \"node:path\";\nimport { fileURLToPath } from \"node:url\";\nimport type { Prettify } from \"@/types/utils.js\";\nimport { Command } from \"@commander-js/extra-typings\";\nimport dotenv from \"dotenv\";\nimport { codegen } from \"./commands/codegen.js\";\nimport { dev } from \"./commands/dev.js\";\nimport { serve } from \"./commands/serve.js\";\nimport { start } from \"./commands/start.js\";\n\ndotenv.config({ path: \".env.local\" });\n\nconst __dirname = dirname(fileURLToPath(import.meta.url));\nconst packageJsonPath = resolve(__dirname, \"../../package.json\");\nconst packageJson = JSON.parse(\n  readFileSync(packageJsonPath, { encoding: \"utf8\" }),\n);\n\nconst ponder = new Command(\"ponder\")\n  .usage(\"<command> [OPTIONS]\")\n  .helpOption(\"-h, --help\", \"Show this help message\")\n  .helpCommand(false)\n  .option(\n    \"--root <PATH>\",\n    \"Path to the project root directory (default: working directory)\",\n  )\n  .option(\n    \"--config <PATH>\",\n    \"Path to the project config file\",\n    \"ponder.config.ts\",\n  )\n  .option(\n    \"-v, --debug\",\n    \"Enable debug logs, e.g. realtime blocks, internal events\",\n  )\n  .option(\n    \"-vv, --trace\",\n    \"Enable trace logs, e.g. db queries, indexing checkpoints\",\n  )\n  .option(\n    \"--log-level <LEVEL>\",\n    'Minimum log level (\"error\", \"warn\", \"info\", \"debug\", or \"trace\")',\n    \"info\",\n  )\n  .option(\n    \"--log-format <FORMAT>\",\n    'The log format (\"pretty\" or \"json\")',\n    \"pretty\",\n  )\n  .version(packageJson.version, \"-V, --version\", \"Show the version number\")\n  .configureHelp({ showGlobalOptions: true })\n  .allowExcessArguments(false)\n  .showHelpAfterError()\n  .enablePositionalOptions(false);\n\ntype GlobalOptions = {\n  command: \"dev\" | \"start\" | \"serve\" | \"codegen\";\n} & ReturnType<typeof ponder.opts>;\n\nconst devCommand = new Command(\"dev\")\n  .description(\"Start the development server with hot reloading\")\n  .option(\"-p, --port <PORT>\", \"Port for the web server\", Number, 42069)\n  .option(\"-H, --hostname <HOSTNAME>\", \"Hostname for the web server\", \"0.0.0.0\")\n  .showHelpAfterError()\n  .action(async (_, command) => {\n    const cliOptions = {\n      ...command.optsWithGlobals(),\n      command: command.name(),\n    } as GlobalOptions & ReturnType<typeof command.opts>;\n    await dev({ cliOptions });\n  });\n\nconst startCommand = new Command(\"start\")\n  .description(\"Start the production server\")\n  .option(\"-p, --port <PORT>\", \"Port for the web server\", Number, 42069)\n  .option(\"-H, --hostname <HOSTNAME>\", \"Hostname for the web server\", \"0.0.0.0\")\n  .showHelpAfterError()\n  .action(async (_, command) => {\n    const cliOptions = {\n      ...command.optsWithGlobals(),\n      command: command.name(),\n    } as GlobalOptions & ReturnType<typeof command.opts>;\n    await start({ cliOptions });\n  });\n\nconst serveCommand = new Command(\"serve\")\n  .description(\"Start the production HTTP server without the indexer\")\n  .option(\"-p, --port <PORT>\", \"Port for the web server\", Number, 42069)\n  .option(\"-H, --hostname <HOSTNAME>\", \"Hostname for the web server\", \"0.0.0.0\")\n  .showHelpAfterError()\n  .action(async (_, command) => {\n    const cliOptions = {\n      ...command.optsWithGlobals(),\n      command: command.name(),\n    } as GlobalOptions & ReturnType<typeof command.opts>;\n    await serve({ cliOptions });\n  });\n\nconst codegenCommand = new Command(\"codegen\")\n  .description(\"Generate the schema.graphql file, then exit\")\n  .showHelpAfterError()\n  .action(async (_, command) => {\n    const cliOptions = {\n      ...command.optsWithGlobals(),\n      command: command.name(),\n    } as GlobalOptions & ReturnType<typeof command.opts>;\n    await codegen({ cliOptions });\n  });\n\n// const cache = new Command(\"cache\");\n\n// cache\n//   .command(\"drop\")\n//   .description(\"Dangerously drop all cached RPC data\")\n//   .action(async (_, command) => {\n//     const cliOptions = command.optsWithGlobals() as GlobalOptions &\n//       ReturnType<typeof command.opts>;\n//     console.log(\"ponder db drop\");\n//   });\n\n// ponder.addCommand(cache);\n\n// cli\n//   .command(\"cache prune\", \"Drop stale indexed data tables\")\n//   .action(async (cliOptions: DbOptions) => {\n//     // if (cliOptions.help) process.exit(0);\n//     console.log(\"ponder cache prune\");\n//   });\n\nponder.addCommand(devCommand);\nponder.addCommand(startCommand);\nponder.addCommand(serveCommand);\nponder.addCommand(codegenCommand);\n\nexport type CliOptions = Prettify<\n  GlobalOptions &\n    Partial<\n      ReturnType<typeof devCommand.opts> &\n        ReturnType<typeof startCommand.opts> &\n        ReturnType<typeof serveCommand.opts> &\n        ReturnType<typeof codegenCommand.opts>\n    >\n>;\n\nawait ponder.parseAsync();\n","import type { Prettify } from \"@/types/utils.js\";\n\nexport const extend = <\n  TCreate extends (...params: any[]) => any,\n  TMethods extends { [methodName: string]: (...params: any[]) => unknown },\n>(\n  create: TCreate,\n  _methods: TMethods,\n): ((\n  ...params: Parameters<TCreate>\n) => ReturnType<TCreate> extends Promise<any>\n  ? Promise<Extend<Awaited<ReturnType<TCreate>>, TMethods>>\n  : Extend<ReturnType<TCreate>, TMethods>) => {\n  return (...params: Parameters<TCreate>) => {\n    const service = create(...params);\n\n    if (service instanceof Promise) {\n      return service.then((s) => {\n        const methods: any = {};\n        for (const [methodName, method] of Object.entries(_methods)) {\n          methods[methodName] = (...params: any) => method(s, ...params);\n        }\n\n        return {\n          ...s,\n          ...methods,\n        };\n      });\n    } else {\n      const methods: any = {};\n      for (const [methodName, method] of Object.entries(_methods)) {\n        methods[methodName] = (...params: any) => method(service, ...params);\n      }\n\n      return {\n        ...service,\n        ...methods,\n      };\n    }\n  };\n};\n\nexport type Extend<\n  service,\n  methods extends { [methodName: string]: (...params: any[]) => unknown },\n> = Prettify<\n  service & {\n    [methodName in keyof methods]: Parameters<methods[methodName]> extends [\n      any,\n      ...infer parameters,\n    ]\n      ? (...params: parameters) => ReturnType<methods[methodName]>\n      : never;\n  }\n>;\n","import { createHash } from \"node:crypto\";\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport type { Common } from \"@/common/common.js\";\nimport { BuildError } from \"@/common/errors.js\";\nimport type { Config, OptionsConfig } from \"@/config/config.js\";\nimport type { DatabaseConfig } from \"@/config/database.js\";\nimport type { Network } from \"@/config/networks.js\";\nimport type { EventSource } from \"@/config/sources.js\";\nimport { buildGraphQLSchema } from \"@/graphql/buildGraphqlSchema.js\";\nimport type { PonderRoutes } from \"@/hono/index.js\";\nimport type { Schema } from \"@/schema/common.js\";\nimport { glob } from \"glob\";\nimport type { GraphQLSchema } from \"graphql\";\nimport type { Hono } from \"hono\";\nimport { type ViteDevServer, createServer } from \"vite\";\nimport { ViteNodeRunner } from \"vite-node/client\";\nimport { ViteNodeServer } from \"vite-node/server\";\nimport { installSourcemapsSupport } from \"vite-node/source-map\";\nimport { normalizeModuleId, toFilePath } from \"vite-node/utils\";\nimport viteTsconfigPathsPlugin from \"vite-tsconfig-paths\";\nimport {\n  type IndexingFunctions,\n  type RawIndexingFunctions,\n  safeBuildConfigAndIndexingFunctions,\n} from \"./configAndIndexingFunctions.js\";\nimport { vitePluginPonder } from \"./plugin.js\";\nimport { safeBuildSchema } from \"./schema.js\";\nimport { parseViteNodeError } from \"./stacktrace.js\";\n\nconst BUILD_ID_VERSION = \"1\";\n\nexport type Service = {\n  // static\n  common: Common;\n  indexingRegex: RegExp;\n  apiRegex: RegExp;\n  indexingPattern: string;\n  apiPattern: string;\n\n  // vite\n  viteDevServer: ViteDevServer;\n  viteNodeServer: ViteNodeServer;\n  viteNodeRunner: ViteNodeRunner;\n};\n\ntype BaseBuild = {\n  // Build ID for caching\n  buildId: string;\n  // Config\n  databaseConfig: DatabaseConfig;\n  optionsConfig: OptionsConfig;\n  sources: EventSource[];\n  networks: Network[];\n  // Schema\n  schema: Schema;\n  graphqlSchema: GraphQLSchema;\n};\n\nexport type IndexingBuild = BaseBuild & {\n  indexingFunctions: IndexingFunctions;\n};\n\nexport type ApiBuild = BaseBuild & {\n  app: Hono;\n  routes: PonderRoutes;\n};\n\nexport type IndexingBuildResult =\n  | { status: \"success\"; build: IndexingBuild }\n  | { status: \"error\"; error: Error };\n\nexport type ApiBuildResult =\n  | { status: \"success\"; build: ApiBuild }\n  | { status: \"error\"; error: Error };\n\nexport const create = async ({\n  common,\n}: {\n  common: Common;\n}): Promise<Service> => {\n  const escapeRegex = /[.*+?^${}()|[\\]\\\\]/g;\n\n  const escapedIndexingDir = common.options.indexingDir\n    // If on Windows, use a POSIX path for this regex.\n    .replace(/\\\\/g, \"/\")\n    // Escape special characters in the path.\n    .replace(escapeRegex, \"\\\\$&\");\n  const indexingRegex = new RegExp(`^${escapedIndexingDir}/.*\\\\.(ts|js)$`);\n\n  const escapedApiDir = common.options.apiDir\n    // If on Windows, use a POSIX path for this regex.\n    .replace(/\\\\/g, \"/\")\n    // Escape special characters in the path.\n    .replace(escapeRegex, \"\\\\$&\");\n  const apiRegex = new RegExp(`^${escapedApiDir}/.*\\\\.(ts|js)$`);\n\n  const indexingPattern = path\n    .join(common.options.indexingDir, \"**/*.{js,mjs,ts,mts}\")\n    .replace(/\\\\/g, \"/\");\n\n  const apiPattern = path\n    .join(common.options.apiDir, \"**/*.{js,mjs,ts,mts}\")\n    .replace(/\\\\/g, \"/\");\n\n  const viteLogger = {\n    warnedMessages: new Set<string>(),\n    loggedErrors: new WeakSet<Error>(),\n    hasWarned: false,\n    clearScreen() {},\n    hasErrorLogged: (error: Error) => viteLogger.loggedErrors.has(error),\n    info: (msg: string) => {\n      common.logger.trace({ service: \"build(vite)\", msg });\n    },\n    warn: (msg: string) => {\n      viteLogger.hasWarned = true;\n      common.logger.trace({ service: \"build(vite)\", msg });\n    },\n    warnOnce: (msg: string) => {\n      if (viteLogger.warnedMessages.has(msg)) return;\n      viteLogger.hasWarned = true;\n      common.logger.trace({ service: \"build(vite)\", msg });\n      viteLogger.warnedMessages.add(msg);\n    },\n    error: (msg: string) => {\n      viteLogger.hasWarned = true;\n      common.logger.trace({ service: \"build(vite)\", msg });\n    },\n  };\n\n  const viteDevServer = await createServer({\n    root: common.options.rootDir,\n    cacheDir: path.join(common.options.ponderDir, \"vite\"),\n    publicDir: false,\n    customLogger: viteLogger,\n    server: { hmr: false },\n    plugins: [viteTsconfigPathsPlugin(), vitePluginPonder()],\n  });\n\n  // This is Vite boilerplate (initializes the Rollup container).\n  await viteDevServer.pluginContainer.buildStart({});\n\n  const viteNodeServer = new ViteNodeServer(viteDevServer);\n  installSourcemapsSupport({\n    getSourceMap: (source) => viteNodeServer.getSourceMap(source),\n  });\n\n  const viteNodeRunner = new ViteNodeRunner({\n    root: viteDevServer.config.root,\n    fetchModule: (id) => viteNodeServer.fetchModule(id, \"ssr\"),\n    resolveId: (id, importer) => viteNodeServer.resolveId(id, importer, \"ssr\"),\n  });\n\n  return {\n    common,\n    indexingRegex,\n    apiRegex,\n    indexingPattern,\n    apiPattern,\n    viteDevServer,\n    viteNodeServer,\n    viteNodeRunner,\n  };\n};\n\n/**\n * Execute, validate, and build the files the make up a Ponder app.\n * If `watch` is true (dev server), then use vite to re-execute changed files,\n * and validate and build again. This function only re-executes changes files,\n * but doesn't attempt to skip any validation or build steps.\n */\nexport const start = async (\n  buildService: Service,\n  {\n    watch,\n    onIndexingBuild,\n    onApiBuild,\n  }:\n    | {\n        watch: true;\n        onIndexingBuild: (buildResult: IndexingBuildResult) => void;\n        onApiBuild: (buildResult: ApiBuildResult) => void;\n      }\n    | { watch: false; onIndexingBuild?: never; onApiBuild?: never },\n): Promise<{ indexing: IndexingBuildResult; api: ApiBuildResult }> => {\n  const { common } = buildService;\n\n  // Note: Don't run these in parallel. If there are circular imports in user code,\n  // it's possible for ViteNodeRunner to return exports as undefined (a race condition).\n  const configResult = await executeConfig(buildService);\n  const schemaResult = await executeSchema(buildService);\n  const indexingResult = await executeIndexingFunctions(buildService);\n  const apiResult = await executeApiRoutes(buildService);\n\n  if (configResult.status === \"error\") {\n    return {\n      indexing: { status: \"error\", error: configResult.error },\n      api: { status: \"error\", error: configResult.error },\n    };\n  }\n  if (schemaResult.status === \"error\") {\n    return {\n      indexing: { status: \"error\", error: schemaResult.error },\n      api: { status: \"error\", error: schemaResult.error },\n    };\n  }\n  if (indexingResult.status === \"error\") {\n    return {\n      indexing: { status: \"error\", error: indexingResult.error },\n      api: { status: \"error\", error: indexingResult.error },\n    };\n  }\n  if (apiResult.status === \"error\") {\n    return {\n      indexing: { status: \"error\", error: apiResult.error },\n      api: { status: \"error\", error: apiResult.error },\n    };\n  }\n\n  let cachedConfigResult = configResult;\n  let cachedSchemaResult = schemaResult;\n  let cachedIndexingResult = indexingResult;\n  let cachedApiResult = apiResult;\n\n  // If watch is false (`ponder start` or `ponder serve`),\n  // don't register  any event handlers on the watcher.\n  if (watch) {\n    // Define the directories and files to ignore\n    const ignoredDirs = [common.options.generatedDir, common.options.ponderDir];\n    const ignoredFiles = [\n      path.join(common.options.rootDir, \"ponder-env.d.ts\"),\n      path.join(common.options.rootDir, \".env.local\"),\n    ];\n\n    const isFileIgnored = (filePath: string) => {\n      const isInIgnoredDir = ignoredDirs.some((dir) => {\n        const rel = path.relative(dir, filePath);\n        return !rel.startsWith(\"..\") && !path.isAbsolute(rel);\n      });\n\n      const isIgnoredFile = ignoredFiles.includes(filePath);\n      return isInIgnoredDir || isIgnoredFile;\n    };\n\n    const onFileChange = async (_file: string) => {\n      if (isFileIgnored(_file)) return;\n\n      // Note that `toFilePath` always returns a POSIX path, even if you pass a Windows path.\n      const file = toFilePath(\n        normalizeModuleId(_file),\n        common.options.rootDir,\n      ).path;\n\n      // Invalidate all modules that depend on the updated files.\n      // Note that `invalidateDepTree` accepts and returns POSIX paths, even on Windows.\n      const invalidated = [\n        ...buildService.viteNodeRunner.moduleCache.invalidateDepTree([file]),\n      ];\n\n      // If no files were invalidated, no need to reload.\n      if (invalidated.length === 0) return;\n\n      // Note that the paths in `invalidated` are POSIX, so we need to\n      // convert the paths in `options` to POSIX for this comparison.\n      // The `srcDir` regex is already converted to POSIX.\n      const hasConfigUpdate = invalidated.includes(\n        common.options.configFile.replace(/\\\\/g, \"/\"),\n      );\n      const hasSchemaUpdate = invalidated.includes(\n        common.options.schemaFile.replace(/\\\\/g, \"/\"),\n      );\n      const hasIndexingUpdate = invalidated.some(\n        (file) =>\n          buildService.indexingRegex.test(file) &&\n          !buildService.apiRegex.test(file),\n      );\n      const hasApiUpdate = invalidated.some((file) =>\n        buildService.apiRegex.test(file),\n      );\n\n      // This branch could trigger if you change a `note.txt` file within `src/`.\n      // Note: We could probably do a better job filtering out files in `isFileIgnored`.\n      if (\n        !hasConfigUpdate &&\n        !hasSchemaUpdate &&\n        !hasIndexingUpdate &&\n        !hasApiUpdate\n      ) {\n        return;\n      }\n\n      common.logger.info({\n        service: \"build\",\n        msg: `Hot reload ${invalidated\n          .map((f) => `'${path.relative(common.options.rootDir, f)}'`)\n          .join(\", \")}`,\n      });\n\n      if (hasConfigUpdate) {\n        const result = await executeConfig(buildService);\n        if (result.status === \"error\") {\n          onIndexingBuild({ status: \"error\", error: result.error });\n          return;\n        }\n        cachedConfigResult = result;\n      }\n\n      if (hasSchemaUpdate) {\n        const result = await executeSchema(buildService);\n        if (result.status === \"error\") {\n          onIndexingBuild({ status: \"error\", error: result.error });\n          return;\n        }\n        cachedSchemaResult = result;\n      }\n\n      if (hasIndexingUpdate) {\n        const files = glob.sync(buildService.indexingPattern, {\n          ignore: buildService.apiPattern,\n        });\n        buildService.viteNodeRunner.moduleCache.invalidateDepTree(files);\n        buildService.viteNodeRunner.moduleCache.deleteByModuleId(\"@/generated\");\n\n        const result = await executeIndexingFunctions(buildService);\n        if (result.status === \"error\") {\n          onIndexingBuild({ status: \"error\", error: result.error });\n          return;\n        }\n        cachedIndexingResult = result;\n      }\n\n      if (hasApiUpdate) {\n        const files = glob.sync(buildService.apiPattern);\n        buildService.viteNodeRunner.moduleCache.invalidateDepTree(files);\n        buildService.viteNodeRunner.moduleCache.deleteByModuleId(\"@/generated\");\n\n        const result = await executeApiRoutes(buildService);\n        if (result.status === \"error\") {\n          onApiBuild({ status: \"error\", error: result.error });\n          return;\n        }\n        cachedApiResult = result;\n      }\n\n      /**\n       * Build and validate updated indexing and api artifacts\n       *\n       * There are a few cases to handle:\n       * 1) config or schema is updated -> rebuild both api and indexing\n       * 2) indexing functions are updated -> rebuild indexing\n       * 3) api routes are updated -> rebuild api\n       *\n       * Note: the api build cannot be successful if the indexing\n       * build fails, this means that any indexing errors are always\n       * propogated to the api build.\n       */\n\n      const indexingBuildResult = await validateAndBuild(\n        buildService,\n        cachedConfigResult,\n        cachedSchemaResult,\n        cachedIndexingResult,\n      );\n      if (indexingBuildResult.status === \"error\") {\n        onIndexingBuild(indexingBuildResult);\n        onApiBuild(indexingBuildResult);\n        return;\n      }\n\n      // If schema or config is updated, rebuild both api and indexing\n      if (hasConfigUpdate || hasSchemaUpdate) {\n        onIndexingBuild(indexingBuildResult);\n        onApiBuild(\n          validateAndBuildApi(\n            buildService,\n            indexingBuildResult.build,\n            cachedApiResult,\n          ),\n        );\n      } else {\n        if (hasIndexingUpdate) {\n          onIndexingBuild(indexingBuildResult);\n        }\n\n        if (hasApiUpdate) {\n          onApiBuild(\n            validateAndBuildApi(\n              buildService,\n              indexingBuildResult.build,\n              cachedApiResult,\n            ),\n          );\n        }\n      }\n    };\n\n    buildService.viteDevServer.watcher.on(\"change\", onFileChange);\n  }\n\n  // Build and validate initial indexing and server build.\n  // Note: the api build cannot be successful if the indexing\n  // build fails\n\n  const initialBuildResult = await validateAndBuild(\n    buildService,\n    configResult,\n    schemaResult,\n    indexingResult,\n  );\n\n  if (initialBuildResult.status === \"error\") {\n    return {\n      indexing: { status: \"error\", error: initialBuildResult.error },\n      api: { status: \"error\", error: initialBuildResult.error },\n    };\n  }\n\n  const initialApiBuildResult = validateAndBuildApi(\n    buildService,\n    initialBuildResult.build,\n    apiResult,\n  );\n\n  return {\n    indexing: initialBuildResult,\n    api: initialApiBuildResult,\n  };\n};\n\nexport const kill = async (buildService: Service): Promise<void> => {\n  await buildService.viteDevServer?.close();\n  buildService.common.logger.debug({\n    service: \"build\",\n    msg: \"Killed build service\",\n  });\n};\n\nconst executeConfig = async (\n  buildService: Service,\n): Promise<\n  | { status: \"success\"; config: Config; contentHash: string }\n  | { status: \"error\"; error: Error }\n> => {\n  const executeResult = await executeFile(buildService, {\n    file: buildService.common.options.configFile,\n  });\n\n  if (executeResult.status === \"error\") {\n    buildService.common.logger.error({\n      service: \"build\",\n      msg: \"Error while executing 'ponder.config.ts':\",\n      error: executeResult.error,\n    });\n\n    return executeResult;\n  }\n\n  const config = executeResult.exports.default as Config;\n\n  const contentHash = createHash(\"sha256\")\n    .update(JSON.stringify(config))\n    .digest(\"hex\");\n\n  return { status: \"success\", config, contentHash } as const;\n};\n\nconst executeSchema = async (\n  buildService: Service,\n): Promise<\n  | { status: \"success\"; schema: Schema; contentHash: string }\n  | { status: \"error\"; error: Error }\n> => {\n  const executeResult = await executeFile(buildService, {\n    file: buildService.common.options.schemaFile,\n  });\n\n  if (executeResult.status === \"error\") {\n    buildService.common.logger.error({\n      service: \"build\",\n      msg: \"Error while executing 'ponder.schema.ts':\",\n      error: executeResult.error,\n    });\n\n    return executeResult;\n  }\n\n  const schema = executeResult.exports.default as Schema;\n\n  const contentHash = createHash(\"sha256\")\n    .update(JSON.stringify(schema))\n    .digest(\"hex\");\n\n  return { status: \"success\", schema, contentHash };\n};\n\nconst executeIndexingFunctions = async (\n  buildService: Service,\n): Promise<\n  | {\n      status: \"success\";\n      indexingFunctions: RawIndexingFunctions;\n      contentHash: string;\n    }\n  | { status: \"error\"; error: Error }\n> => {\n  const files = glob.sync(buildService.indexingPattern, {\n    ignore: buildService.apiPattern,\n  });\n  const executeResults = await Promise.all(\n    files.map(async (file) => ({\n      ...(await executeFile(buildService, { file })),\n      file,\n    })),\n  );\n\n  for (const executeResult of executeResults) {\n    if (executeResult.status === \"error\") {\n      buildService.common.logger.error({\n        service: \"build\",\n        msg: `Error while executing '${path.relative(\n          buildService.common.options.rootDir,\n          executeResult.file,\n        )}':`,\n        error: executeResult.error,\n      });\n\n      return executeResult;\n    }\n  }\n\n  // Note that we are only hashing the file contents, not the exports. This is\n  // different from the config/schema, where we include the serializable object itself.\n  const hash = createHash(\"sha256\");\n  for (const file of files) {\n    try {\n      const contents = fs.readFileSync(file, \"utf-8\");\n      hash.update(contents);\n    } catch (e) {\n      buildService.common.logger.warn({\n        service: \"build\",\n        msg: `Unable to read contents of file '${file}' while constructin build ID`,\n      });\n      hash.update(file);\n    }\n  }\n  const contentHash = hash.digest(\"hex\");\n\n  const exports = await buildService.viteNodeRunner.executeId(\"@/generated\");\n\n  return {\n    status: \"success\",\n    indexingFunctions: exports.ponder.fns,\n    contentHash,\n  };\n};\n\nconst executeApiRoutes = async (\n  buildService: Service,\n): Promise<\n  | {\n      status: \"success\";\n      app: Hono;\n      routes: PonderRoutes;\n    }\n  | { status: \"error\"; error: Error }\n> => {\n  const files = glob.sync(buildService.apiPattern);\n  const executeResults = await Promise.all(\n    files.map(async (file) => ({\n      ...(await executeFile(buildService, { file })),\n      file,\n    })),\n  );\n\n  for (const executeResult of executeResults) {\n    if (executeResult.status === \"error\") {\n      buildService.common.logger.error({\n        service: \"build\",\n        msg: `Error while executing '${path.relative(\n          buildService.common.options.rootDir,\n          executeResult.file,\n        )}':`,\n        error: executeResult.error,\n      });\n\n      return executeResult;\n    }\n  }\n\n  const exports = await buildService.viteNodeRunner.executeId(\"@/generated\");\n\n  return {\n    status: \"success\",\n    app: exports.ponder.hono,\n    routes: exports.ponder.routes,\n  };\n};\n\nconst validateAndBuild = async (\n  { common }: Pick<Service, \"common\">,\n  config: { config: Config; contentHash: string },\n  schema: { schema: Schema; contentHash: string },\n  indexingFunctions: {\n    indexingFunctions: RawIndexingFunctions;\n    contentHash: string;\n  },\n): Promise<IndexingBuildResult> => {\n  // Validate and build the schema\n  const buildSchemaResult = safeBuildSchema({\n    schema: schema.schema,\n  });\n  if (buildSchemaResult.status === \"error\") {\n    common.logger.error({\n      service: \"build\",\n      msg: \"Error while building schema:\",\n      error: buildSchemaResult.error,\n    });\n\n    return buildSchemaResult;\n  }\n\n  for (const log of buildSchemaResult.logs) {\n    common.logger[log.level]({ service: \"build\", msg: log.msg });\n  }\n\n  const graphqlSchema = buildGraphQLSchema(buildSchemaResult.schema);\n\n  // Validates and build the config\n  const buildConfigAndIndexingFunctionsResult =\n    await safeBuildConfigAndIndexingFunctions({\n      config: config.config,\n      rawIndexingFunctions: indexingFunctions.indexingFunctions,\n      options: common.options,\n    });\n  if (buildConfigAndIndexingFunctionsResult.status === \"error\") {\n    common.logger.error({\n      service: \"build\",\n      msg: \"Failed build\",\n      error: buildConfigAndIndexingFunctionsResult.error,\n    });\n\n    return buildConfigAndIndexingFunctionsResult;\n  }\n\n  for (const log of buildConfigAndIndexingFunctionsResult.logs) {\n    common.logger[log.level]({ service: \"build\", msg: log.msg });\n  }\n\n  const buildId = createHash(\"sha256\")\n    .update(BUILD_ID_VERSION)\n    .update(config.contentHash)\n    .update(schema.contentHash)\n    .update(indexingFunctions.contentHash)\n    .digest(\"hex\")\n    .slice(0, 10);\n\n  common.logger.debug({\n    service: \"build\",\n    msg: `Completed build with ID '${buildId}' (hash of project file contents)`,\n  });\n\n  return {\n    status: \"success\",\n    build: {\n      buildId,\n      databaseConfig: buildConfigAndIndexingFunctionsResult.databaseConfig,\n      optionsConfig: buildConfigAndIndexingFunctionsResult.optionsConfig,\n      networks: buildConfigAndIndexingFunctionsResult.networks,\n      sources: buildConfigAndIndexingFunctionsResult.sources,\n      schema: buildSchemaResult.schema,\n      graphqlSchema,\n      indexingFunctions:\n        buildConfigAndIndexingFunctionsResult.indexingFunctions,\n    },\n  };\n};\n\nconst validateAndBuildApi = (\n  { common }: Pick<Service, \"common\">,\n  baseBuild: BaseBuild,\n  api: { app: Hono; routes: PonderRoutes },\n): ApiBuildResult => {\n  for (const {\n    pathOrHandlers: [maybePathOrHandler],\n  } of api.routes) {\n    if (typeof maybePathOrHandler === \"string\") {\n      if (\n        maybePathOrHandler === \"/status\" ||\n        maybePathOrHandler === \"/metrics\" ||\n        maybePathOrHandler === \"/health\"\n      ) {\n        const error = new BuildError(\n          `Validation failed: API route \"${maybePathOrHandler}\" is reserved for internal use.`,\n        );\n        error.stack = undefined;\n        common.logger.error({ service: \"build\", msg: \"Failed build\", error });\n        return { status: \"error\", error } as const;\n      }\n    }\n  }\n\n  return {\n    status: \"success\",\n    build: {\n      ...baseBuild,\n      app: api.app,\n      routes: api.routes,\n    },\n  };\n};\n\nconst executeFile = async (\n  { common, viteNodeRunner }: Service,\n  { file }: { file: string },\n): Promise<\n  { status: \"success\"; exports: any } | { status: \"error\"; error: Error }\n> => {\n  try {\n    const exports = await viteNodeRunner.executeFile(file);\n    return { status: \"success\", exports } as const;\n  } catch (error_) {\n    const relativePath = path.relative(common.options.rootDir, file);\n    const error = parseViteNodeError(relativePath, error_ as Error);\n    return { status: \"error\", error } as const;\n  }\n};\n","import path from \"node:path\";\nimport { BuildError } from \"@/common/errors.js\";\nimport type { Options } from \"@/common/options.js\";\nimport {\n  buildAbiEvents,\n  buildAbiFunctions,\n  buildTopics,\n} from \"@/config/abi.js\";\nimport type { Config } from \"@/config/config.js\";\nimport type { DatabaseConfig } from \"@/config/database.js\";\nimport { buildChildAddressCriteria } from \"@/config/factories.js\";\nimport {\n  type Network,\n  getDefaultMaxBlockRange,\n  getFinalityBlockCount,\n  getRpcUrlsForClient,\n  isRpcUrlPublic,\n} from \"@/config/networks.js\";\nimport {\n  type BlockSource,\n  type CallTraceSource,\n  type FactoryCallTraceSource,\n  type FactoryLogSource,\n  type LogSource,\n  sourceIsCallTrace,\n  sourceIsFactoryCallTrace,\n} from \"@/config/sources.js\";\nimport { chains } from \"@/utils/chains.js\";\nimport { toLowerCase } from \"@/utils/lowercase.js\";\nimport { dedupe } from \"@ponder/common\";\nimport parse from \"pg-connection-string\";\nimport type { Hex, LogTopic } from \"viem\";\n\nexport type RawIndexingFunctions = {\n  name: string;\n  fn: (...args: any) => any;\n}[];\n\nexport type IndexingFunctions = {\n  [eventName: string]: (...args: any) => any;\n};\n\nexport async function buildConfigAndIndexingFunctions({\n  config,\n  rawIndexingFunctions,\n  options: { rootDir, ponderDir },\n}: {\n  config: Config;\n  rawIndexingFunctions: RawIndexingFunctions;\n  options: Pick<Options, \"ponderDir\" | \"rootDir\">;\n}) {\n  const logs: { level: \"warn\" | \"info\" | \"debug\"; msg: string }[] = [];\n\n  // Build database.\n  let databaseConfig: DatabaseConfig;\n\n  // Determine SQLite directory, preferring config.database.directory if available\n  const sqliteDir =\n    config.database?.kind === \"sqlite\" && config.database.directory\n      ? path.resolve(config.database.directory)\n      : path.join(ponderDir, \"sqlite\");\n\n  const sqlitePrintPath = path.relative(rootDir, sqliteDir);\n\n  if (config.database?.kind) {\n    if (config.database.kind === \"postgres\") {\n      let connectionString: string | undefined = undefined;\n      let source: string | undefined = undefined;\n\n      if (config.database.connectionString) {\n        connectionString = config.database.connectionString;\n        source = \"from ponder.config.ts\";\n      } else if (process.env.DATABASE_PRIVATE_URL) {\n        connectionString = process.env.DATABASE_PRIVATE_URL;\n        source = \"from DATABASE_PRIVATE_URL env var\";\n      } else if (process.env.DATABASE_URL) {\n        connectionString = process.env.DATABASE_URL;\n        source = \"from DATABASE_URL env var\";\n      } else {\n        throw new Error(\n          `Invalid database configuration: 'kind' is set to 'postgres' but no connection string was provided.`,\n        );\n      }\n\n      logs.push({\n        level: \"info\",\n        msg: `Using Postgres database '${getDatabaseName(connectionString)}' (${source})`,\n      });\n\n      let schema: string | undefined = undefined;\n      if (config.database.schema) {\n        schema = config.database.schema;\n        source = \"from ponder.config.ts\";\n      } else if (process.env.RAILWAY_DEPLOYMENT_ID) {\n        if (process.env.RAILWAY_SERVICE_NAME === undefined) {\n          throw new Error(\n            \"Invalid database configuration: RAILWAY_DEPLOYMENT_ID env var is defined, but RAILWAY_SERVICE_NAME env var is not.\",\n          );\n        }\n        schema = `${process.env.RAILWAY_SERVICE_NAME}_${process.env.RAILWAY_DEPLOYMENT_ID.slice(\n          0,\n          8,\n        )}`;\n        source = \"from RAILWAY_DEPLOYMENT_ID env var\";\n      } else {\n        schema = \"public\";\n        source = \"default\";\n      }\n      logs.push({\n        level: \"info\",\n        msg: `Using '${schema}' database schema for indexed tables (${source})`,\n      });\n\n      let publishSchema: string | undefined = undefined;\n      if (config.database.publishSchema !== undefined) {\n        publishSchema = config.database.publishSchema;\n        source = \"from ponder.config.ts\";\n      } else if (process.env.RAILWAY_DEPLOYMENT_ID !== undefined) {\n        publishSchema = \"public\";\n        source = \"default for Railway deployment\";\n      }\n      if (publishSchema !== undefined) {\n        logs.push({\n          level: \"info\",\n          msg: `Using '${publishSchema}' database schema for published views (${source})`,\n        });\n      } else {\n        logs.push({\n          level: \"debug\",\n          msg: \"Will not publish views (publish schema was not set in ponder.config.ts)\",\n        });\n      }\n\n      if (schema !== undefined && schema === publishSchema) {\n        throw new Error(\n          `Invalid database configuration: 'publishSchema' cannot be the same as 'schema' ('${schema}').`,\n        );\n      }\n\n      const poolConfig = {\n        max: config.database.poolConfig?.max ?? 30,\n        connectionString,\n      };\n\n      databaseConfig = {\n        kind: \"postgres\",\n        poolConfig,\n        schema,\n        publishSchema,\n      };\n    } else {\n      logs.push({\n        level: \"info\",\n        msg: `Using SQLite database in '${sqlitePrintPath}' (from ponder.config.ts)`,\n      });\n\n      databaseConfig = { kind: \"sqlite\", directory: sqliteDir };\n    }\n  } else {\n    let connectionString: string | undefined = undefined;\n    let source: string | undefined = undefined;\n    if (process.env.DATABASE_PRIVATE_URL) {\n      connectionString = process.env.DATABASE_PRIVATE_URL;\n      source = \"from DATABASE_PRIVATE_URL env var\";\n    } else if (process.env.DATABASE_URL) {\n      connectionString = process.env.DATABASE_URL;\n      source = \"from DATABASE_URL env var\";\n    }\n\n    // If either of the DATABASE_URL env vars are set, use Postgres.\n    if (connectionString !== undefined) {\n      logs.push({\n        level: \"info\",\n        msg: `Using Postgres database ${getDatabaseName(connectionString)} (${source})`,\n      });\n\n      let schema: string | undefined = undefined;\n      if (process.env.RAILWAY_DEPLOYMENT_ID !== undefined) {\n        schema = process.env.RAILWAY_DEPLOYMENT_ID;\n        if (process.env.RAILWAY_SERVICE_NAME === undefined) {\n          throw new Error(\n            \"Invalid database configuration: RAILWAY_DEPLOYMENT_ID env var is defined, but RAILWAY_SERVICE_NAME env var is not.\",\n          );\n        }\n        schema = `${process.env.RAILWAY_SERVICE_NAME}_${process.env.RAILWAY_DEPLOYMENT_ID.slice(\n          0,\n          8,\n        )}`;\n        source = \"from RAILWAY_DEPLOYMENT_ID env var\";\n      } else {\n        schema = \"public\";\n        source = \"default\";\n      }\n      logs.push({\n        level: \"info\",\n        msg: `Using '${schema}' database schema for indexed tables (${source})`,\n      });\n\n      let publishSchema: string | undefined = undefined;\n      if (process.env.RAILWAY_DEPLOYMENT_ID !== undefined) {\n        publishSchema = \"public\";\n        source = \"default for Railway deployment\";\n      }\n      if (publishSchema !== undefined) {\n        logs.push({\n          level: \"info\",\n          msg: `Using '${publishSchema}' database schema for published views (${source})`,\n        });\n      } else {\n        logs.push({\n          level: \"debug\",\n          msg: \"Will not publish views (publish schema was not set in ponder.config.ts)\",\n        });\n      }\n\n      if (schema !== undefined && schema === publishSchema) {\n        throw new Error(\n          `Invalid database configuration: 'publishSchema' cannot be the same as 'schema' ('${schema}').`,\n        );\n      }\n\n      const poolConfig = { max: 30, connectionString };\n\n      databaseConfig = {\n        kind: \"postgres\",\n        poolConfig,\n        schema,\n        publishSchema,\n      };\n    } else {\n      // Fall back to SQLite.\n      logs.push({\n        level: \"info\",\n        msg: `Using SQLite database at ${sqlitePrintPath} (default)`,\n      });\n\n      databaseConfig = { kind: \"sqlite\", directory: sqliteDir };\n    }\n  }\n\n  const networks: Network[] = await Promise.all(\n    Object.entries(config.networks).map(async ([networkName, network]) => {\n      const { chainId, transport } = network;\n\n      const defaultChain =\n        Object.values(chains).find((c) =>\n          \"id\" in c ? c.id === chainId : false,\n        ) ?? chains.mainnet!;\n      const chain = { ...defaultChain, name: networkName, id: chainId };\n\n      // Note: This can throw.\n      const rpcUrls = await getRpcUrlsForClient({ transport, chain });\n      rpcUrls.forEach((rpcUrl) => {\n        if (isRpcUrlPublic(rpcUrl)) {\n          logs.push({\n            level: \"warn\",\n            msg: `Network '${networkName}' is using a public RPC URL (${rpcUrl}). Most apps require an RPC URL with a higher rate limit.`,\n          });\n        }\n      });\n\n      if (\n        network.pollingInterval !== undefined &&\n        network.pollingInterval! < 100\n      ) {\n        throw new Error(\n          `Invalid 'pollingInterval' for network '${networkName}. Expected 100 milliseconds or greater, got ${network.pollingInterval} milliseconds.`,\n        );\n      }\n\n      return {\n        name: networkName,\n        chainId,\n        chain,\n        transport: network.transport({ chain }),\n        maxRequestsPerSecond: network.maxRequestsPerSecond ?? 50,\n        pollingInterval: network.pollingInterval ?? 1_000,\n        defaultMaxBlockRange: getDefaultMaxBlockRange({ chainId, rpcUrls }),\n        finalityBlockCount: getFinalityBlockCount({ chainId }),\n        maxHistoricalTaskConcurrency:\n          network.maxHistoricalTaskConcurrency ?? 20,\n        disableCache: network.disableCache ?? false,\n      } satisfies Network;\n    }),\n  );\n\n  // Validate and build indexing functions\n  let indexingFunctionCount = 0;\n  const indexingFunctions: IndexingFunctions = {};\n\n  for (const { name: eventName, fn } of rawIndexingFunctions) {\n    const eventNameComponents = eventName.includes(\".\")\n      ? eventName.split(\".\")\n      : eventName.split(\":\");\n    const [sourceName, sourceEventName] = eventNameComponents;\n    if (eventNameComponents.length !== 2 || !sourceName || !sourceEventName) {\n      throw new Error(\n        `Validation failed: Invalid event '${eventName}', expected format '{sourceName}:{eventName}' or '{sourceName}.{eventName}'.`,\n      );\n    }\n\n    if (eventName in indexingFunctions) {\n      throw new Error(\n        `Validation failed: Multiple indexing functions registered for event '${eventName}'.`,\n      );\n    }\n\n    // Validate that the indexing function uses a sourceName that is present in the config.\n    const matchedSourceName = Object.keys({\n      ...(config.contracts ?? {}),\n      ...(config.blocks ?? {}),\n    }).find((_sourceName) => _sourceName === sourceName);\n\n    if (!matchedSourceName) {\n      // Multi-network has N sources, but the hint here should not have duplicates.\n      const uniqueSourceNames = dedupe(\n        Object.keys({ ...(config.contracts ?? {}), ...(config.blocks ?? {}) }),\n      );\n      throw new Error(\n        `Validation failed: Invalid source name '${sourceName}'. Got '${sourceName}', expected one of [${uniqueSourceNames\n          .map((n) => `'${n}'`)\n          .join(\", \")}].`,\n      );\n    }\n\n    indexingFunctions[eventName] = fn;\n    indexingFunctionCount += 1;\n  }\n\n  if (indexingFunctionCount === 0) {\n    logs.push({ level: \"warn\", msg: \"No indexing functions were registered.\" });\n  }\n\n  const contractSources: (\n    | LogSource\n    | FactoryLogSource\n    | CallTraceSource\n    | FactoryCallTraceSource\n  )[] = Object.entries(config.contracts ?? {})\n    // First, apply any network-specific overrides and flatten the result.\n    .flatMap(([contractName, contract]) => {\n      if (contract.network === null || contract.network === undefined) {\n        throw new Error(\n          `Validation failed: Network for contract '${contractName}' is null or undefined. Expected one of [${networks\n            .map((n) => `'${n.name}'`)\n            .join(\", \")}].`,\n        );\n      }\n\n      const startBlockMaybeNan = contract.startBlock ?? 0;\n      const startBlock = Number.isNaN(startBlockMaybeNan)\n        ? 0\n        : startBlockMaybeNan;\n      const endBlockMaybeNan = contract.endBlock;\n      const endBlock = Number.isNaN(endBlockMaybeNan)\n        ? undefined\n        : endBlockMaybeNan;\n\n      if (endBlock !== undefined && endBlock < startBlock) {\n        throw new Error(\n          `Validation failed: Start block for contract '${contractName}' is after end block (${startBlock} > ${endBlock}).`,\n        );\n      }\n\n      // Single network case.\n      if (typeof contract.network === \"string\") {\n        return {\n          id: `log_${contractName}_${contract.network}`,\n          contractName,\n          networkName: contract.network,\n          abi: contract.abi,\n\n          address: \"address\" in contract ? contract.address : undefined,\n          factory: \"factory\" in contract ? contract.factory : undefined,\n          filter: contract.filter,\n\n          includeTransactionReceipts:\n            contract.includeTransactionReceipts ?? false,\n          includeCallTraces: contract.includeCallTraces ?? false,\n\n          startBlock,\n          endBlock,\n          maxBlockRange: contract.maxBlockRange,\n        };\n      }\n\n      type DefinedNetworkOverride = NonNullable<\n        Exclude<Config[\"contracts\"][string][\"network\"], string>[string]\n      >;\n\n      // Multiple networks case.\n      return Object.entries(contract.network)\n        .filter((n): n is [string, DefinedNetworkOverride] => !!n[1])\n        .map(([networkName, overrides]) => {\n          const startBlockMaybeNan =\n            overrides.startBlock ?? contract.startBlock ?? 0;\n          const startBlock = Number.isNaN(startBlockMaybeNan)\n            ? 0\n            : startBlockMaybeNan;\n          const endBlockMaybeNan = overrides.endBlock ?? contract.endBlock;\n          const endBlock = Number.isNaN(endBlockMaybeNan)\n            ? undefined\n            : endBlockMaybeNan;\n\n          if (endBlock !== undefined && endBlock < startBlock) {\n            throw new Error(\n              `Validation failed: Start block for contract '${contractName}' is after end block (${startBlock} > ${endBlock}).`,\n            );\n          }\n\n          return {\n            contractName,\n            networkName,\n            abi: contract.abi,\n\n            address:\n              (\"address\" in overrides ? overrides?.address : undefined) ??\n              (\"address\" in contract ? contract.address : undefined),\n            factory:\n              (\"factory\" in overrides ? overrides.factory : undefined) ??\n              (\"factory\" in contract ? contract.factory : undefined),\n            filter: overrides.filter ?? contract.filter,\n\n            includeTransactionReceipts:\n              overrides.includeTransactionReceipts ??\n              contract.includeTransactionReceipts ??\n              false,\n            includeCallTraces:\n              overrides.includeCallTraces ??\n              contract.includeCallTraces ??\n              false,\n\n            startBlock,\n            endBlock,\n            maxBlockRange: overrides.maxBlockRange ?? contract.maxBlockRange,\n          };\n        });\n    })\n    // Second, build and validate the factory or log source.\n    .flatMap(\n      (\n        rawContract,\n      ): (\n        | LogSource\n        | FactoryLogSource\n        | CallTraceSource\n        | FactoryCallTraceSource\n      )[] => {\n        const network = networks.find(\n          (n) => n.name === rawContract.networkName,\n        );\n        if (!network) {\n          throw new Error(\n            `Validation failed: Invalid network for contract '${\n              rawContract.contractName\n            }'. Got '${rawContract.networkName}', expected one of [${networks\n              .map((n) => `'${n.name}'`)\n              .join(\", \")}].`,\n          );\n        }\n\n        // Get indexing function that were registered for this contract\n        const registeredLogEvents: string[] = [];\n        const registeredCallTraceEvents: string[] = [];\n        for (const eventName of Object.keys(indexingFunctions)) {\n          // log event\n          if (eventName.includes(\":\")) {\n            const [logContractName, logEventName] = eventName.split(\":\") as [\n              string,\n              string,\n            ];\n            if (\n              logContractName === rawContract.contractName &&\n              logEventName !== \"setup\"\n            ) {\n              registeredLogEvents.push(logEventName);\n            }\n          }\n\n          // call trace event\n          if (eventName.includes(\".\")) {\n            const [functionContractName, functionName] = eventName.split(\n              \".\",\n            ) as [string, string];\n            if (functionContractName === rawContract.contractName) {\n              registeredCallTraceEvents.push(functionName);\n            }\n          }\n        }\n\n        // Note: This can probably throw for invalid ABIs. Consider adding explicit ABI validation before this line.\n        const abiEvents = buildAbiEvents({ abi: rawContract.abi });\n        const abiFunctions = buildAbiFunctions({ abi: rawContract.abi });\n\n        const registeredEventSelectors: Hex[] = [];\n        // Validate that the registered log events exist in the abi\n        for (const logEvent of registeredLogEvents) {\n          const abiEvent = abiEvents.bySafeName[logEvent];\n          if (abiEvent === undefined) {\n            throw new Error(\n              `Validation failed: Event name for event '${logEvent}' not found in the contract ABI. Got '${logEvent}', expected one of [${Object.keys(\n                abiEvents.bySafeName,\n              )\n                .map((eventName) => `'${eventName}'`)\n                .join(\", \")}].`,\n            );\n          }\n\n          registeredEventSelectors.push(abiEvent.selector);\n        }\n\n        const registeredFunctionSelectors: Hex[] = [];\n        for (const _function of registeredCallTraceEvents) {\n          const abiFunction = abiFunctions.bySafeName[_function];\n          if (abiFunction === undefined) {\n            throw new Error(\n              `Validation failed: Function name for function '${_function}' not found in the contract ABI. Got '${_function}', expected one of [${Object.keys(\n                abiFunctions.bySafeName,\n              )\n                .map((eventName) => `'${eventName}'`)\n                .join(\", \")}].`,\n            );\n          }\n\n          registeredFunctionSelectors.push(abiFunction.selector);\n        }\n\n        let topics: LogTopic[] = [registeredEventSelectors];\n\n        if (rawContract.filter !== undefined) {\n          if (\n            Array.isArray(rawContract.filter.event) &&\n            rawContract.filter.args !== undefined\n          ) {\n            throw new Error(\n              `Validation failed: Event filter for contract '${rawContract.contractName}' cannot contain indexed argument values if multiple events are provided.`,\n            );\n          }\n\n          const filterSafeEventNames = Array.isArray(rawContract.filter.event)\n            ? rawContract.filter.event\n            : [rawContract.filter.event];\n\n          for (const filterSafeEventName of filterSafeEventNames) {\n            const abiEvent = abiEvents.bySafeName[filterSafeEventName];\n            if (!abiEvent) {\n              throw new Error(\n                `Validation failed: Invalid filter for contract '${\n                  rawContract.contractName\n                }'. Got event name '${filterSafeEventName}', expected one of [${Object.keys(\n                  abiEvents.bySafeName,\n                )\n                  .map((n) => `'${n}'`)\n                  .join(\", \")}].`,\n              );\n            }\n          }\n\n          // TODO: Explicit validation of indexed argument value format (array or object).\n          // The first element of the array return from `buildTopics` being defined\n          // is an invariant of the current filter design.\n          // Note: This can throw.\n          const [topic0FromFilter, ...topicsFromFilter] = buildTopics(\n            rawContract.abi,\n            rawContract.filter,\n          ) as [Exclude<LogTopic, null>, ...LogTopic[]];\n\n          const filteredEventSelectors = Array.isArray(topic0FromFilter)\n            ? topic0FromFilter\n            : [topic0FromFilter];\n\n          // Validate that the topic0 value defined by the `eventFilter` is a superset of the\n          // registered indexing functions. Simply put, confirm that no indexing function is\n          // defined for a log event that is excluded by the filter.\n          for (const registeredEventSelector of registeredEventSelectors) {\n            if (!filteredEventSelectors.includes(registeredEventSelector)) {\n              const logEventName =\n                abiEvents.bySelector[registeredEventSelector]!.safeName;\n\n              throw new Error(\n                `Validation failed: Event '${logEventName}' is excluded by the event filter defined on the contract '${\n                  rawContract.contractName\n                }'. Got '${logEventName}', expected one of [${filteredEventSelectors\n                  .map((s) => abiEvents.bySelector[s]!.safeName)\n                  .map((eventName) => `'${eventName}'`)\n                  .join(\", \")}].`,\n              );\n            }\n          }\n\n          topics = [registeredEventSelectors, ...topicsFromFilter];\n        }\n\n        const baseContract = {\n          contractName: rawContract.contractName,\n          networkName: rawContract.networkName,\n          chainId: network.chainId,\n          abi: rawContract.abi,\n          startBlock: rawContract.startBlock,\n          endBlock: rawContract.endBlock,\n          maxBlockRange: rawContract.maxBlockRange,\n        };\n\n        const resolvedFactory = rawContract?.factory;\n        const resolvedAddress = rawContract?.address;\n\n        if (resolvedFactory !== undefined && resolvedAddress !== undefined) {\n          throw new Error(\n            `Validation failed: Contract '${baseContract.contractName}' cannot specify both 'factory' and 'address' options.`,\n          );\n        }\n\n        if (resolvedFactory) {\n          // Note that this can throw.\n          const childAddressCriteria =\n            buildChildAddressCriteria(resolvedFactory);\n\n          const factoryLogSource = {\n            ...baseContract,\n            id: `log_${rawContract.contractName}_${rawContract.networkName}`,\n            type: \"factoryLog\",\n            abiEvents: abiEvents,\n            criteria: {\n              ...childAddressCriteria,\n              includeTransactionReceipts:\n                rawContract.includeTransactionReceipts,\n              topics,\n            },\n          } satisfies FactoryLogSource;\n\n          if (rawContract.includeCallTraces) {\n            return [\n              factoryLogSource,\n              {\n                ...baseContract,\n                id: `callTrace_${rawContract.contractName}_${rawContract.networkName}`,\n                type: \"factoryCallTrace\",\n                abiFunctions,\n                criteria: {\n                  ...childAddressCriteria,\n                  functionSelectors: registeredFunctionSelectors,\n                  includeTransactionReceipts:\n                    rawContract.includeTransactionReceipts,\n                },\n              } satisfies FactoryCallTraceSource,\n            ];\n          }\n\n          return [factoryLogSource];\n        }\n\n        const validatedAddress = Array.isArray(resolvedAddress)\n          ? resolvedAddress.map((r) => toLowerCase(r))\n          : resolvedAddress\n            ? toLowerCase(resolvedAddress)\n            : undefined;\n\n        if (validatedAddress !== undefined) {\n          for (const address of Array.isArray(validatedAddress)\n            ? validatedAddress\n            : [validatedAddress]) {\n            if (!address.startsWith(\"0x\"))\n              throw new Error(\n                `Validation failed: Invalid prefix for address '${address}'. Got '${address.slice(\n                  0,\n                  2,\n                )}', expected '0x'.`,\n              );\n            if (address.length !== 42)\n              throw new Error(\n                `Validation failed: Invalid length for address '${address}'. Got ${address.length}, expected 42 characters.`,\n              );\n          }\n        }\n\n        const logSource = {\n          ...baseContract,\n          id: `log_${rawContract.contractName}_${rawContract.networkName}`,\n          type: \"log\",\n          abiEvents: abiEvents,\n          criteria: {\n            address: validatedAddress,\n            topics,\n            includeTransactionReceipts: rawContract.includeTransactionReceipts,\n          },\n        } satisfies LogSource;\n\n        if (rawContract.includeCallTraces) {\n          return [\n            logSource,\n            {\n              ...baseContract,\n              id: `callTrace_${rawContract.contractName}_${rawContract.networkName}`,\n              type: \"callTrace\",\n              abiFunctions,\n              criteria: {\n                toAddress: Array.isArray(validatedAddress)\n                  ? validatedAddress\n                  : validatedAddress === undefined\n                    ? undefined\n                    : [validatedAddress],\n                functionSelectors: registeredFunctionSelectors,\n                includeTransactionReceipts:\n                  rawContract.includeTransactionReceipts,\n              },\n            } satisfies CallTraceSource,\n          ];\n        } else return [logSource];\n      },\n    )\n    // Remove sources with no registered indexing functions\n    .filter((source) => {\n      const hasRegisteredIndexingFunctions =\n        sourceIsCallTrace(source) || sourceIsFactoryCallTrace(source)\n          ? source.criteria.functionSelectors.length !== 0\n          : source.criteria.topics[0]?.length !== 0;\n      if (!hasRegisteredIndexingFunctions) {\n        logs.push({\n          level: \"debug\",\n          msg: `No indexing functions were registered for '${\n            source.contractName\n          }' ${sourceIsCallTrace(source) ? \"call traces\" : \"logs\"}`,\n        });\n      }\n      return hasRegisteredIndexingFunctions;\n    });\n\n  const blockSources: BlockSource[] = Object.entries(config.blocks ?? {})\n    .flatMap(([sourceName, blockSourceConfig]) => {\n      const startBlockMaybeNan = blockSourceConfig.startBlock ?? 0;\n      const startBlock = Number.isNaN(startBlockMaybeNan)\n        ? 0\n        : startBlockMaybeNan;\n      const endBlockMaybeNan = blockSourceConfig.endBlock;\n      const endBlock = Number.isNaN(endBlockMaybeNan)\n        ? undefined\n        : endBlockMaybeNan;\n\n      if (endBlock !== undefined && endBlock < startBlock) {\n        throw new Error(\n          `Validation failed: Start block for block source '${sourceName}' is after end block (${startBlock} > ${endBlock}).`,\n        );\n      }\n\n      const intervalMaybeNan = blockSourceConfig.interval;\n      const interval = Number.isNaN(intervalMaybeNan) ? 0 : intervalMaybeNan;\n\n      if (!Number.isInteger(interval) || interval === 0) {\n        throw new Error(\n          `Validation failed: Invalid interval for block source '${sourceName}'. Got ${interval}, expected a non-zero integer.`,\n        );\n      }\n\n      if (typeof blockSourceConfig.network === \"string\") {\n        const network = networks.find(\n          (n) => n.name === blockSourceConfig.network,\n        );\n        if (!network) {\n          throw new Error(\n            `Validation failed: Invalid network for block source '${sourceName}'. Got '${\n              blockSourceConfig.network\n            }', expected one of [${networks.map((n) => `'${n.name}'`).join(\", \")}].`,\n          );\n        }\n\n        return {\n          type: \"block\",\n          id: `block_${sourceName}_${blockSourceConfig.network}`,\n          sourceName,\n          networkName: blockSourceConfig.network,\n          chainId: network.chainId,\n          startBlock,\n          endBlock,\n          criteria: {\n            interval: interval,\n            offset: startBlock % interval,\n          },\n        } as const;\n      }\n\n      type DefinedNetworkOverride = NonNullable<\n        Exclude<Config[\"blocks\"][string][\"network\"], string>[string]\n      >;\n\n      return Object.entries(blockSourceConfig.network)\n        .filter((n): n is [string, DefinedNetworkOverride] => !!n[1])\n        .map(([networkName, overrides]) => {\n          const network = networks.find((n) => n.name === networkName);\n          if (!network) {\n            throw new Error(\n              `Validation failed: Invalid network for block source '${sourceName}'. Got '${networkName}', expected one of [${networks\n                .map((n) => `'${n.name}'`)\n                .join(\", \")}].`,\n            );\n          }\n\n          const startBlockMaybeNan =\n            overrides.startBlock ?? blockSourceConfig.startBlock ?? 0;\n          const startBlock = Number.isNaN(startBlockMaybeNan)\n            ? 0\n            : startBlockMaybeNan;\n          const endBlockMaybeNan =\n            overrides.endBlock ?? blockSourceConfig.endBlock;\n          const endBlock = Number.isNaN(endBlockMaybeNan)\n            ? undefined\n            : endBlockMaybeNan;\n\n          if (endBlock !== undefined && endBlock < startBlock) {\n            throw new Error(\n              `Validation failed: Start block for block source '${sourceName}' is after end block (${startBlock} > ${endBlock}).`,\n            );\n          }\n\n          const intervalMaybeNan =\n            overrides.interval ?? blockSourceConfig.interval;\n          const interval = Number.isNaN(intervalMaybeNan)\n            ? 0\n            : intervalMaybeNan;\n\n          if (!Number.isInteger(interval) || interval === 0) {\n            throw new Error(\n              `Validation failed: Invalid interval for block source '${sourceName}'. Got ${interval}, expected a non-zero integer.`,\n            );\n          }\n\n          return {\n            type: \"block\",\n            id: `block_${sourceName}_${networkName}`,\n            sourceName,\n            networkName,\n            chainId: network.chainId,\n            startBlock,\n            endBlock,\n            criteria: {\n              interval: interval,\n              offset: startBlock % interval,\n            },\n          } as const;\n        });\n    })\n    .filter((blockSource) => {\n      const hasRegisteredIndexingFunction =\n        indexingFunctions[`${blockSource.sourceName}:block`] !== undefined;\n      if (!hasRegisteredIndexingFunction) {\n        logs.push({\n          level: \"debug\",\n          msg: `No indexing functions were registered for '${blockSource.sourceName}' blocks`,\n        });\n      }\n      return hasRegisteredIndexingFunction;\n    });\n\n  const sources = [...contractSources, ...blockSources];\n\n  // Filter out any networks that don't have any sources registered.\n  const networksWithSources = networks.filter((network) => {\n    const hasSources = sources.some(\n      (source) => source.networkName === network.name,\n    );\n    if (!hasSources) {\n      logs.push({\n        level: \"warn\",\n        msg: `No sources registered for network '${network.name}'`,\n      });\n    }\n    return hasSources;\n  });\n\n  const optionsConfig: Partial<Options> = {};\n  if (config.options?.maxHealthcheckDuration !== undefined) {\n    optionsConfig.maxHealthcheckDuration =\n      config.options.maxHealthcheckDuration;\n    logs.push({\n      level: \"info\",\n      msg: `Set max healthcheck duration to ${optionsConfig.maxHealthcheckDuration} seconds (from ponder.config.ts)`,\n    });\n  }\n\n  return {\n    databaseConfig,\n    optionsConfig,\n    networks: networksWithSources,\n    sources,\n    indexingFunctions,\n    logs,\n  };\n}\n\nexport async function safeBuildConfigAndIndexingFunctions({\n  config,\n  rawIndexingFunctions,\n  options,\n}: {\n  config: Config;\n  rawIndexingFunctions: RawIndexingFunctions;\n  options: Pick<Options, \"rootDir\" | \"ponderDir\">;\n}) {\n  try {\n    const result = await buildConfigAndIndexingFunctions({\n      config,\n      rawIndexingFunctions,\n      options,\n    });\n\n    return {\n      status: \"success\",\n      sources: result.sources,\n      networks: result.networks,\n      indexingFunctions: result.indexingFunctions,\n      databaseConfig: result.databaseConfig,\n      optionsConfig: result.optionsConfig,\n      logs: result.logs,\n    } as const;\n  } catch (_error) {\n    const buildError = new BuildError((_error as Error).message);\n    buildError.stack = undefined;\n    return { status: \"error\", error: buildError } as const;\n  }\n}\n\nfunction getDatabaseName(connectionString: string) {\n  const parsed = (parse as unknown as typeof parse.parse)(connectionString);\n  return `${parsed.host}:${parsed.port}/${parsed.database}`;\n}\n","/**\n * Returns a Set containing all the duplicate elements in an array of strings.\n * @param arr - The input array of strings.\n * @returns A Set object containing the duplicate elements found in the input array.\n */\nexport function getDuplicateElements(arr: string[]): Set<string> {\n  const uniqueElements = new Set<string>();\n  const duplicates = new Set<string>();\n\n  arr.forEach((element: string) => {\n    if (uniqueElements.has(element)) {\n      duplicates.add(element);\n    } else {\n      uniqueElements.add(element);\n    }\n  });\n\n  return duplicates;\n}\n","import { getDuplicateElements } from \"@/utils/duplicates.js\";\nimport {\n  type Abi,\n  type AbiEvent,\n  type AbiFunction,\n  formatAbiItem,\n} from \"abitype\";\nimport {\n  type GetEventArgs,\n  type Hex,\n  type LogTopic,\n  encodeEventTopics,\n  getAbiItem,\n  getEventSelector,\n  getFunctionSelector,\n  parseAbiItem,\n} from \"viem\";\nimport type { Config } from \"./config.js\";\n\n/**\n * Fix issue with Array.isArray not checking readonly arrays\n * {@link https://github.com/microsoft/TypeScript/issues/17002}\n */\ndeclare global {\n  interface ArrayConstructor {\n    isArray(arg: ReadonlyArray<any> | any): arg is ReadonlyArray<any>;\n  }\n}\n\ntype AbiEventMeta = {\n  // Event name (if no overloads) or full event signature (if name is overloaded).\n  // This is the event name used when registering indexing functions using `ponder.on(\"ContractName:EventName\", ...)`\n  safeName: string;\n  // Full event signature, e.g. `event Deposit(address indexed from,bytes32 indexed id,uint value);`\n  signature: string;\n  // Keccak256 hash of the event signature (topic[0]).\n  selector: Hex;\n  // ABI item used for decoding raw logs.\n  item: AbiEvent;\n};\n\ntype AbiFunctionMeta = {\n  // Function name (if no overloads) or full function signature (if name is overloaded).\n  // This is the function name used when registering indexing functions using `ponder.on(\"ContractName.FunctionName\", ...)`\n  safeName: string;\n  // Full function signature, e.g. `function transfer(address to,uint256 amount)`\n  signature: string;\n  // Keccak256 hash of the function signature.\n  selector: Hex;\n  // ABI item used for decoding input and output data.\n  item: AbiFunction;\n};\n\nexport type AbiEvents = {\n  bySafeName: { [key: string]: AbiEventMeta | undefined };\n  bySelector: { [key: Hex]: AbiEventMeta | undefined };\n};\n\nexport type AbiFunctions = {\n  bySafeName: { [key: string]: AbiFunctionMeta | undefined };\n  bySelector: { [key: Hex]: AbiFunctionMeta | undefined };\n};\n\nexport const buildAbiEvents = ({ abi }: { abi: Abi }) => {\n  const abiEvents = abi\n    .filter((item): item is AbiEvent => item.type === \"event\")\n    .filter((item) => item.anonymous === undefined || item.anonymous === false);\n\n  const overloadedEventNames = getDuplicateElements(\n    abiEvents.map((item) => item.name),\n  );\n\n  return abiEvents.reduce<AbiEvents>(\n    (acc, item) => {\n      const signature = formatAbiItem(item);\n      const safeName = overloadedEventNames.has(item.name)\n        ? signature.split(\"event \")[1]!\n        : item.name;\n      const selector = getEventSelector(item);\n\n      const abiEventMeta = { safeName, signature, selector, item };\n\n      acc.bySafeName[safeName] = abiEventMeta;\n      acc.bySelector[selector] = abiEventMeta;\n\n      return acc;\n    },\n    { bySafeName: {}, bySelector: {} },\n  );\n};\n\nexport function buildTopics(\n  abi: Abi,\n  filter: NonNullable<Config[\"contracts\"][string][\"filter\"]>,\n): LogTopic[] {\n  if (Array.isArray(filter.event)) {\n    // List of event signatures\n    return [\n      filter.event.map((event) => getEventSelector(findAbiEvent(abi, event))),\n    ];\n  } else {\n    // Single event with args\n    return encodeEventTopics({\n      abi: [findAbiEvent(abi, filter.event)],\n      args: filter.args as GetEventArgs<Abi, string>,\n    });\n  }\n}\n\n/**\n * Finds the event ABI item for the event name or event signature.\n *\n * @param eventName Event name or event signature if there are duplicates\n */\nconst findAbiEvent = (abi: Abi, eventName: string): AbiEvent => {\n  if (eventName.includes(\"(\")) {\n    // full event signature\n    return parseAbiItem(`event ${eventName}`) as AbiEvent;\n  } else {\n    return getAbiItem({ abi, name: eventName }) as AbiEvent;\n  }\n};\n\nexport const buildAbiFunctions = ({ abi }: { abi: Abi }) => {\n  const abiFunctions = abi.filter(\n    (item): item is AbiFunction => item.type === \"function\",\n  );\n\n  const overloadedFunctionNames = getDuplicateElements(\n    abiFunctions.map((item) => item.name),\n  );\n\n  return abiFunctions.reduce<AbiFunctions>(\n    (acc, item) => {\n      const signature = formatAbiItem(item);\n      const safeName = overloadedFunctionNames.has(item.name)\n        ? signature.split(\"function \")[1]!\n        : `${item.name}()`;\n      const selector = getFunctionSelector(item);\n\n      const abiEventMeta = { safeName, signature, selector, item };\n\n      acc.bySafeName[safeName] = abiEventMeta;\n      acc.bySelector[selector] = abiEventMeta;\n\n      return acc;\n    },\n    { bySafeName: {}, bySelector: {} },\n  );\n};\n","/**\n * Transforms the input string to lower case.\n */\nexport function toLowerCase<T extends string>(value: T) {\n  return value.toLowerCase() as Lowercase<T>;\n}\n","import type { AbiParameter } from \"abitype\";\nimport { InvalidAbiDecodingTypeError } from \"viem\";\n\n// Adapted from viem.\n// https://github.com/wagmi-dev/viem/blob/5c95fafceffe7f399b5b5ee32119e2d78a0c8acd/src/utils/abi/decodeEventLog.ts\n\nexport function getBytesConsumedByParam(param: AbiParameter): number {\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents) {\n    const [length, innerType] = arrayComponents;\n\n    // If the array is dynamic or has dynamic children, it uses the\n    // dynamic encoding scheme (32 byte header).\n    if (!length || hasDynamicChild(param)) {\n      return 32;\n    }\n\n    // If the length of the array is known in advance,\n    // and the length of each element in the array is known,\n    // the array data is encoded contiguously after the array.\n    const bytesConsumedByInnerType = getBytesConsumedByParam({\n      ...param,\n      type: innerType,\n    });\n    return length * bytesConsumedByInnerType;\n  }\n\n  if (param.type === \"tuple\") {\n    // If the tuple has dynamic children, it uses the dynamic encoding\n    // scheme (32 byte header).\n    if (hasDynamicChild(param)) {\n      return 32;\n    }\n\n    // Otherwise the tuple has static children, so we can just decode\n    // each component in sequence.\n    let consumed = 0;\n    for (const component of (param as any).components ?? []) {\n      consumed += getBytesConsumedByParam(component);\n    }\n    return consumed;\n  }\n\n  // Otherwise, it's a dynamic string or bytes (32 bytes),\n  // or a static number, address, or bool (32 bytes).\n  if (\n    param.type === \"string\" ||\n    param.type.startsWith(\"bytes\") ||\n    param.type.startsWith(\"uint\") ||\n    param.type.startsWith(\"int\") ||\n    param.type === \"address\" ||\n    param.type === \"bool\"\n  ) {\n    return 32;\n  }\n\n  throw new InvalidAbiDecodingTypeError(param.type, {\n    docsPath: \"/docs/contract/decodeAbiParameters\",\n  });\n}\n\nfunction hasDynamicChild(param: AbiParameter) {\n  const { type } = param;\n  if (type === \"string\") return true;\n  if (type === \"bytes\") return true;\n  if (type.endsWith(\"[]\")) return true;\n\n  if (type === \"tuple\") return (param as any).components?.some(hasDynamicChild);\n\n  const arrayComponents = getArrayComponents(param.type);\n  if (\n    arrayComponents &&\n    hasDynamicChild({ ...param, type: arrayComponents[1] } as AbiParameter)\n  )\n    return true;\n\n  return false;\n}\n\nfunction getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n  return matches\n    ? // Return `null` if the array is dynamic.\n      [matches[2] ? Number(matches[2]) : null, matches[1]!]\n    : undefined;\n}\n","import { toLowerCase } from \"@/utils/lowercase.js\";\nimport { getBytesConsumedByParam } from \"@/utils/offset.js\";\nimport type { AbiEvent } from \"abitype\";\nimport { getEventSelector } from \"viem\";\nimport type { ChildAddressCriteria } from \"./sources.js\";\n\nexport function buildChildAddressCriteria({\n  address: _address,\n  event,\n  parameter,\n}: {\n  address: `0x${string}`;\n  event: AbiEvent;\n  parameter: string;\n}): ChildAddressCriteria {\n  const address = toLowerCase(_address);\n  const eventSelector = getEventSelector(event);\n\n  // Check if the provided parameter is present in the list of indexed inputs.\n  const indexedInputPosition = event.inputs\n    .filter((x) => \"indexed\" in x && x.indexed)\n    .findIndex((input) => input.name === parameter);\n\n  if (indexedInputPosition > -1) {\n    return {\n      address,\n      eventSelector,\n      // Add 1 because inputs will not contain an element for topic0 (the signature).\n      childAddressLocation: `topic${(indexedInputPosition + 1) as 1 | 2 | 3}`,\n    };\n  }\n\n  const nonIndexedInputs = event.inputs.filter(\n    (x) => !(\"indexed\" in x && x.indexed),\n  );\n  const nonIndexedInputPosition = nonIndexedInputs.findIndex(\n    (input) => input.name === parameter,\n  );\n\n  if (nonIndexedInputPosition === -1) {\n    throw new Error(\n      `Factory event parameter not found in factory event signature. Got '${parameter}', expected one of [${event.inputs\n        .map((i) => `'${i.name}'`)\n        .join(\", \")}].`,\n    );\n  }\n\n  let offset = 0;\n  for (let i = 0; i < nonIndexedInputPosition; i++) {\n    offset += getBytesConsumedByParam(nonIndexedInputs[i]!);\n  }\n\n  return {\n    address,\n    eventSelector,\n    childAddressLocation: `offset${offset}`,\n  };\n}\n","import * as _chains from \"viem/chains\";\n\nexport const chains = _chains as unknown as Record<string, _chains.Chain>;\n","import { chains } from \"@/utils/chains.js\";\nimport type { Chain, Client, Transport } from \"viem\";\n\nexport type Network = {\n  name: string;\n  chainId: number;\n  chain: Chain;\n  transport: ReturnType<Transport>;\n  pollingInterval: number;\n  maxRequestsPerSecond: number;\n  maxHistoricalTaskConcurrency: number;\n  defaultMaxBlockRange: number;\n  finalityBlockCount: number;\n  disableCache: boolean;\n};\n\nexport function getDefaultMaxBlockRange({\n  chainId,\n  rpcUrls,\n}: {\n  chainId: number;\n  rpcUrls: (string | undefined)[];\n}) {\n  let maxBlockRange: number;\n  switch (chainId) {\n    // Mainnet and mainnet testnets.\n    case 1:\n    case 3:\n    case 4:\n    case 5:\n    case 42:\n    case 11155111:\n      maxBlockRange = 2_000;\n      break;\n    // Optimism.\n    case 10:\n    case 420:\n      maxBlockRange = 50_000;\n      break;\n    // Polygon.\n    case 137:\n    case 80001:\n      maxBlockRange = 50_000;\n      break;\n    // Arbitrum.\n    case 42161:\n    case 421613:\n      maxBlockRange = 50_000;\n      break;\n    default:\n      maxBlockRange = 50_000;\n  }\n\n  const isQuickNode = rpcUrls\n    .filter((url): url is string => url !== undefined)\n    .some((url) => url.includes(\"quiknode\"));\n\n  const isCloudflare = rpcUrls\n    .filter((url): url is string => url !== undefined)\n    .some((url) => url.includes(\"cloudflare-eth\"));\n\n  if (isQuickNode) {\n    maxBlockRange = Math.min(maxBlockRange, 10_000);\n  } else if (isCloudflare) {\n    maxBlockRange = Math.min(maxBlockRange, 800);\n  }\n\n  return maxBlockRange;\n}\n\n/**\n * Returns the number of blocks that must pass before a block is considered final.\n * Note that a value of `0` indicates that blocks are considered final immediately.\n *\n * @param network The network to get the finality block count for.\n * @returns The finality block count.\n */\nexport function getFinalityBlockCount({ chainId }: { chainId: number }) {\n  let finalityBlockCount: number;\n  switch (chainId) {\n    // Mainnet and mainnet testnets.\n    case 1:\n    case 3:\n    case 4:\n    case 5:\n    case 42:\n    case 11155111:\n      finalityBlockCount = 65;\n      break;\n    // Polygon.\n    case 137:\n    case 80001:\n      finalityBlockCount = 200;\n      break;\n    // Arbitrum.\n    case 42161:\n    case 42170:\n    case 421611:\n    case 421613:\n      finalityBlockCount = 240;\n      break;\n    default:\n      // Assume a 2-second block time, e.g. OP stack chains.\n      finalityBlockCount = 30;\n  }\n\n  return finalityBlockCount;\n}\n\n/**\n * Returns the list of RPC URLs backing a Transport.\n *\n * @param transport A viem Transport.\n * @returns Array of RPC URLs.\n */\nexport async function getRpcUrlsForClient(parameters: {\n  transport: Transport;\n  chain: Chain;\n}) {\n  // This is how viem converts a Transport into the Client.transport type.\n  const { config, value } = parameters.transport({\n    chain: parameters.chain,\n    pollingInterval: 4_000, // default viem value\n    retryCount: 0,\n  });\n  const transport = { ...config, ...value } as Client[\"transport\"];\n\n  async function getRpcUrlsForTransport(transport: Client[\"transport\"]) {\n    switch (transport.type) {\n      case \"http\": {\n        return [transport.url ?? parameters.chain.rpcUrls.default.http[0]];\n      }\n      case \"webSocket\": {\n        try {\n          const socket = await transport.getSocket();\n          return [socket.url];\n        } catch (e) {\n          const symbol = Object.getOwnPropertySymbols(e).find(\n            (symbol) => symbol.toString() === \"Symbol(kTarget)\",\n          );\n          if (!symbol) return [];\n          const url = (e as any)[symbol]?._url;\n          if (!url) return [];\n          return [url.replace(/\\/$/, \"\")];\n        }\n      }\n      case \"fallback\": {\n        // This is how viem converts a TransportConfig into the Client.transport type.\n        const fallbackTransports = transport.transports.map((t: any) => ({\n          ...t.config,\n          ...t.value,\n        })) as Client[\"transport\"][];\n\n        const urls: (string | undefined)[] = [];\n        for (const fallbackTransport of fallbackTransports) {\n          urls.push(...(await getRpcUrlsForTransport(fallbackTransport)));\n        }\n\n        return urls;\n      }\n      default: {\n        // TODO: Consider logging a warning here. This will catch \"custom\" and unknown transports,\n        // which we might not want to support.\n        return [];\n      }\n    }\n  }\n\n  return getRpcUrlsForTransport(transport);\n}\n\nlet publicRpcUrls: Set<string> | undefined = undefined;\n\n/**\n * Returns `true` if the RPC URL is found in the list of public RPC URLs\n * included in viem/chains. Handles both HTTP and WebSocket RPC URLs.\n *\n * @param rpcUrl An RPC URL.\n * @returns Boolean indicating if the RPC URL is public.\n */\nexport function isRpcUrlPublic(rpcUrl: string | undefined) {\n  if (rpcUrl === undefined) return true;\n\n  if (!publicRpcUrls) {\n    // By default, viem uses `chain.default.{http|webSocket}.[0]` if it exists.\n    publicRpcUrls = Object.values(chains).reduce<Set<string>>((acc, chain) => {\n      chain.rpcUrls.default.http.forEach((httpRpcUrl) => {\n        acc.add(httpRpcUrl);\n      });\n\n      (\n        (chain.rpcUrls.default as unknown as { webSocket?: string[] })\n          .webSocket ?? []\n      ).forEach((webSocketRpcUrl) => {\n        acc.add(webSocketRpcUrl);\n      });\n\n      return acc;\n    }, new Set<string>());\n  }\n\n  return publicRpcUrls.has(rpcUrl);\n}\n","import type { Abi, Address, Hex, LogTopic } from \"viem\";\nimport type { AbiEvents, AbiFunctions } from \"./abi.js\";\n\nexport type ChildAddressCriteria = {\n  address: Address;\n  eventSelector: Hex;\n  childAddressLocation: \"topic1\" | \"topic2\" | \"topic3\" | `offset${number}`;\n};\n\nexport type LogFilterCriteria = {\n  address?: Address | Address[];\n  topics: LogTopic[];\n  includeTransactionReceipts: boolean;\n};\n\nexport type FactoryLogFilterCriteria = ChildAddressCriteria & {\n  topics: LogTopic[];\n  includeTransactionReceipts: boolean;\n};\n\nexport type BlockFilterCriteria = {\n  interval: number;\n  offset: number;\n};\n\nexport type CallTraceFilterCriteria = {\n  fromAddress?: Address[];\n  toAddress?: Address[];\n  includeTransactionReceipts: boolean;\n  functionSelectors: Hex[];\n};\n\nexport type FactoryCallTraceFilterCriteria = ChildAddressCriteria & {\n  fromAddress?: Address[];\n  includeTransactionReceipts: boolean;\n  functionSelectors: Hex[];\n};\n\nexport type LogSource = {\n  type: \"log\";\n  /** `log_${contractName}_${networkName}` */\n  id: string;\n  criteria: LogFilterCriteria;\n  contractName: string;\n  networkName: string;\n  chainId: number;\n  abi: Abi;\n  abiEvents: AbiEvents;\n  startBlock: number;\n  endBlock?: number;\n  maxBlockRange?: number;\n};\n\nexport type FactoryLogSource = {\n  type: \"factoryLog\";\n  /** `log_${contractName}_${networkName}` */\n  id: string;\n  criteria: FactoryLogFilterCriteria;\n  contractName: string;\n  networkName: string;\n  chainId: number;\n  abi: Abi;\n  abiEvents: AbiEvents;\n  startBlock: number;\n  endBlock?: number;\n  maxBlockRange?: number;\n};\n\nexport type BlockSource = {\n  type: \"block\";\n  /** `block_${sourceName}_${networkName}` */\n  id: string;\n  criteria: BlockFilterCriteria;\n  sourceName: string;\n  networkName: string;\n  chainId: number;\n  startBlock: number;\n  endBlock?: number;\n};\n\nexport type CallTraceSource = {\n  type: \"callTrace\";\n  /** `callTrace_${contractName}_${networkName}` */\n  id: string;\n  criteria: CallTraceFilterCriteria;\n  contractName: string;\n  networkName: string;\n  chainId: number;\n  abi: Abi;\n  abiFunctions: AbiFunctions;\n  startBlock: number;\n  endBlock?: number;\n  maxBlockRange?: number;\n};\n\nexport type FactoryCallTraceSource = {\n  type: \"factoryCallTrace\";\n  /** `callTrace_${contractName}_${networkName}` */\n  id: string;\n  criteria: FactoryCallTraceFilterCriteria;\n  contractName: string;\n  networkName: string;\n  chainId: number;\n  abi: Abi;\n  abiFunctions: AbiFunctions;\n  startBlock: number;\n  endBlock?: number;\n  maxBlockRange?: number;\n};\n\nexport type EventSource =\n  | LogSource\n  | FactoryLogSource\n  | CallTraceSource\n  | FactoryCallTraceSource\n  | BlockSource;\n\nexport const sourceIsLog = (\n  source: Pick<EventSource, \"type\">,\n): source is LogSource => source.type === \"log\";\n\nexport const sourceIsFactoryLog = (\n  source: Pick<EventSource, \"type\">,\n): source is FactoryLogSource => source.type === \"factoryLog\";\n\nexport const sourceIsCallTrace = (\n  source: Pick<EventSource, \"type\">,\n): source is CallTraceSource => source.type === \"callTrace\";\n\nexport const sourceIsFactoryCallTrace = (\n  source: Pick<EventSource, \"type\">,\n): source is FactoryCallTraceSource => source.type === \"factoryCallTrace\";\n\nexport const sourceIsBlock = (\n  source: Pick<EventSource, \"type\">,\n): source is BlockSource => source.type === \"block\";\n","export type PromiseWithResolvers<TPromise> = {\n  resolve: (arg: TPromise) => void;\n  reject: (error: Error) => void;\n  promise: Promise<TPromise>;\n};\n\n/**\n * @description Application level polyfill.\n */\nexport const promiseWithResolvers = <\n  TPromise,\n>(): PromiseWithResolvers<TPromise> => {\n  let resolve: (arg: TPromise) => void;\n  let reject: (error: Error) => void;\n  const promise = new Promise<TPromise>((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  return { resolve: resolve!, reject: reject!, promise };\n};\n","/**\n * Creates a debounced function that waits ms milliseconds between invocations.\n * If the function is called multiple times between invocations, the latest\n * arguments passed to the function will be used.\n */\nexport function debounce<param extends unknown[], returnType>(\n  ms: number,\n  fn: (...x: param) => returnType,\n) {\n  let args: param;\n  let timeoutSet = false;\n  let timeout: NodeJS.Timeout;\n\n  return {\n    call: (..._args: param) => {\n      args = _args;\n\n      if (!timeoutSet) {\n        timeoutSet = true;\n        timeout = setTimeout(() => {\n          timeoutSet = false;\n          fn(...args);\n        }, ms);\n      }\n    },\n    cancel: () => {\n      clearTimeout(timeout);\n    },\n  };\n}\n","/**\n * Remove duplicate values from an array.\n *\n * @param getId callback used to calculate a unique value for an element of the array.\n *\n * @example\n * dedupe([1,1,2,3]) // [1,2,3]\n *\n * dedupe(\n *   [\n *     { a: 1, b: 2 },\n *     { a: 1, b: 2 },\n *     { a: 2, b: 2 },\n *   ],\n *   (e) => `${e.a}_${e.b}`,\n * ) // [{a: 1, b: 2}, {a: 2, b: 2}]\n *\n */\nexport function dedupe<item, id>(arr: item[], getId?: (x: item) => id): item[] {\n  const seen = new Set<id | item>();\n\n  return arr.filter((x) => {\n    if (seen.has(getId ? getId(x) : x)) return false;\n\n    seen.add(x);\n    return true;\n  });\n}\n\ndedupe(\n  [\n    { a: 1, b: 2 },\n    { a: 1, b: 2 },\n    { a: 2, b: 2 },\n  ],\n  (e) => `${e.a}_${e.b}`,\n);\n","import {\n  type PromiseWithResolvers,\n  promiseWithResolvers,\n} from \"./promiseWithResolvers.js\";\n\nexport type InnerQueue<returnType, taskType> = {\n  task: taskType;\n  resolve: (arg: returnType) => void;\n  reject: (error: Error) => void;\n}[];\n\nexport type Queue<returnType, taskType> = {\n  size: () => number;\n  pending: () => Promise<number>;\n  add: (task: taskType) => Promise<returnType>;\n  clear: () => void;\n  isStarted: () => boolean;\n  start: () => Promise<void>;\n  pause: () => void;\n  onIdle: () => Promise<void>;\n  onEmpty: () => Promise<void>;\n  setParameters: (\n    parameters: Pick<\n      CreateQueueParameters<unknown, unknown>,\n      \"frequency\" | \"concurrency\"\n    >,\n  ) => void;\n};\n\nexport type CreateQueueParameters<returnType, taskType> = {\n  worker: (task: taskType) => Promise<returnType>;\n  initialStart?: boolean;\n  browser?: boolean;\n} & (\n  | {\n      concurrency: number;\n      frequency: number;\n    }\n  | { concurrency: number; frequency?: undefined }\n  | { concurrency?: undefined; frequency: number }\n);\n\nconst validateParameters = ({\n  concurrency,\n  frequency,\n}: Pick<\n  CreateQueueParameters<unknown, unknown>,\n  \"frequency\" | \"concurrency\"\n>) => {\n  if (concurrency === undefined && frequency === undefined) {\n    throw new Error(\n      \"Invalid queue configuration, must specify either 'concurrency' or 'frequency'.\",\n    );\n  }\n\n  if (concurrency !== undefined && concurrency <= 0) {\n    throw new Error(\n      `Invalid value for queue 'concurrency' option. Got ${concurrency}, expected a number greater than zero.`,\n    );\n  }\n\n  if (frequency !== undefined && frequency <= 0) {\n    throw new Error(\n      `Invalid value for queue 'frequency' option. Got ${frequency}, expected a number greater than zero.`,\n    );\n  }\n};\n\nexport const createQueue = <returnType, taskType = void>({\n  worker,\n  initialStart = false,\n  browser = true,\n  ..._parameters\n}: CreateQueueParameters<returnType, taskType>): Queue<\n  returnType,\n  taskType\n> => {\n  validateParameters(_parameters);\n\n  const parameters: Pick<\n    CreateQueueParameters<unknown, unknown>,\n    \"frequency\" | \"concurrency\"\n  > = _parameters;\n  let queue = new Array<InnerQueue<returnType, taskType>[number]>();\n  let pending = 0;\n  let timestamp = 0;\n  let requests = 0;\n  let isStarted = initialStart;\n\n  let timer: NodeJS.Timeout | undefined;\n\n  let emptyPromiseWithResolvers:\n    | (PromiseWithResolvers<void> & { completed: boolean })\n    | undefined = undefined;\n  let idlePromiseWithResolvers:\n    | (PromiseWithResolvers<void> & { completed: boolean })\n    | undefined = undefined;\n\n  const next = () => {\n    if (!isStarted) return;\n\n    const _timestamp = Date.now();\n\n    if (Math.floor(_timestamp / 1_000) !== timestamp) {\n      requests = 0;\n      timestamp = Math.floor(_timestamp / 1_000);\n    }\n\n    if (timer) return;\n\n    while (\n      (parameters.frequency !== undefined\n        ? requests < parameters.frequency\n        : true) &&\n      (parameters.concurrency !== undefined\n        ? pending < parameters.concurrency\n        : true) &&\n      queue.length > 0\n    ) {\n      const { task, resolve, reject } = queue.shift()!;\n\n      requests++;\n      pending++;\n\n      worker(task)\n        .then(resolve)\n        .catch(reject)\n        .finally(() => {\n          pending--;\n\n          if (\n            idlePromiseWithResolvers !== undefined &&\n            queue.length === 0 &&\n            pending === 0\n          ) {\n            idlePromiseWithResolvers.resolve();\n            idlePromiseWithResolvers.completed = true;\n          }\n\n          browser ? next() : process.nextTick(next);\n        });\n\n      if (emptyPromiseWithResolvers !== undefined && queue.length === 0) {\n        emptyPromiseWithResolvers.resolve();\n        emptyPromiseWithResolvers.completed = true;\n      }\n    }\n\n    if (\n      parameters.frequency !== undefined &&\n      requests >= parameters.frequency\n    ) {\n      timer = setTimeout(\n        () => {\n          timer = undefined;\n          next();\n        },\n        1_000 - (_timestamp % 1_000),\n      );\n      return;\n    }\n  };\n\n  return {\n    size: () => queue.length,\n    pending: () => {\n      if (browser) {\n        return new Promise<number>((resolve) =>\n          setTimeout(() => resolve(pending)),\n        );\n      } else {\n        return new Promise<number>((resolve) =>\n          setImmediate(() => resolve(pending)),\n        );\n      }\n    },\n    add: (task: taskType) => {\n      const { promise, resolve, reject } = promiseWithResolvers<returnType>();\n      queue.push({ task, resolve, reject });\n\n      next();\n\n      return promise;\n    },\n    clear: () => {\n      queue = new Array<InnerQueue<returnType, taskType>[number]>();\n      clearTimeout(timer);\n      timer = undefined;\n    },\n    isStarted: () => isStarted,\n    start: () => {\n      if (browser) {\n        return new Promise<number>((resolve) =>\n          setTimeout(() => resolve(pending)),\n        ).then(() => {\n          isStarted = true;\n          next();\n        });\n      } else {\n        return new Promise<number>((resolve) =>\n          process.nextTick(() => resolve(pending)),\n        ).then(() => {\n          isStarted = true;\n          next();\n        });\n      }\n    },\n    pause: () => {\n      isStarted = false;\n    },\n    onIdle: () => {\n      if (\n        idlePromiseWithResolvers === undefined ||\n        idlePromiseWithResolvers.completed\n      ) {\n        if (queue.length === 0 && pending === 0) return Promise.resolve();\n\n        idlePromiseWithResolvers = {\n          ...promiseWithResolvers<void>(),\n          completed: false,\n        };\n      }\n      return idlePromiseWithResolvers.promise;\n    },\n    onEmpty: () => {\n      if (\n        emptyPromiseWithResolvers === undefined ||\n        emptyPromiseWithResolvers.completed\n      ) {\n        if (queue.length === 0) return Promise.resolve();\n\n        emptyPromiseWithResolvers = {\n          ...promiseWithResolvers<void>(),\n          completed: false,\n        };\n      }\n      return emptyPromiseWithResolvers.promise;\n    },\n    setParameters: (_parameters) => {\n      validateParameters(_parameters);\n\n      if (\"frequency\" in _parameters) {\n        parameters.frequency = _parameters.frequency;\n      }\n      if (\"concurrency\" in _parameters) {\n        parameters.concurrency = _parameters.concurrency;\n      }\n    },\n  } as Queue<returnType, taskType>;\n};\n","import type { Plugin } from \"vite\";\n\nconst virtualModule = `import { Hono } from \"hono\";\n\nconst ponderHono = {\n  routes: [],\n  get(...maybePathOrHandlers) {\n    this.routes.push({ method: \"GET\", pathOrHandlers: maybePathOrHandlers });\n    return this;\n  },\n  post(...maybePathOrHandlers) {\n    this.routes.push({ method: \"POST\", pathOrHandlers: maybePathOrHandlers });\n    return this;\n  },\n  use(...maybePathOrHandlers) {\n    this.routes.push({ method: \"USE\", pathOrHandlers: maybePathOrHandlers });\n    return this;\n  },\n};\n\nconst ponder = {\n  ...ponderHono,\n  hono: new Hono(),\n  fns: [],\n  on(name, fn) {\n    this.fns.push({ name, fn });\n  },\n};\n\nexport { ponder };\n`;\n\nexport const vitePluginPonder = (): Plugin => {\n  return {\n    name: \"ponder\",\n    load: (id) => {\n      if (id === \"@/generated\") return virtualModule;\n      return null;\n    },\n  };\n};\n","import { BuildError } from \"@/common/errors.js\";\nimport type { Schema } from \"@/schema/common.js\";\nimport {\n  extractReferenceTable,\n  getEnums,\n  getTables,\n  isEnumColumn,\n  isJSONColumn,\n  isListColumn,\n  isManyColumn,\n  isOneColumn,\n  isOptionalColumn,\n  isReferenceColumn,\n} from \"@/schema/utils.js\";\nimport { dedupe } from \"@ponder/common\";\n\nexport const buildSchema = ({ schema }: { schema: Schema }) => {\n  const logs: { level: \"warn\" | \"info\" | \"debug\"; msg: string }[] = [];\n\n  // Validate enums\n  Object.entries(getEnums(schema)).forEach(([name, _enum]) => {\n    validateTableOrColumnName(name, \"Enum\");\n\n    const enumValues = new Set<string>();\n    for (const enumValue of _enum) {\n      if (enumValues.has(enumValue)) {\n        throw new Error(\n          `Validation failed: Enum '${name}' contains duplicate value '${enumValue}'.`,\n        );\n      }\n      enumValues.add(enumValue);\n    }\n  });\n\n  // Validate tables\n  Object.entries(getTables(schema)).forEach(\n    ([tableName, { table, constraints }]) => {\n      validateTableOrColumnName(tableName, \"Table\");\n\n      // Validate the id column\n      if (table.id === undefined)\n        throw new Error(\n          `Validation failed: Table '${tableName}' does not have an 'id' column.`,\n        );\n\n      if (isJSONColumn(table.id))\n        throw new Error(\n          `Validation failed: Invalid type for ID column '${tableName}.id'. Got 'json', expected one of ['string', 'hex', 'bigint', 'int'].`,\n        );\n      if (isEnumColumn(table.id))\n        throw new Error(\n          `Validation failed: Invalid type for ID column '${tableName}.id'. Got 'enum', expected one of ['string', 'hex', 'bigint', 'int'].`,\n        );\n      if (isOneColumn(table.id))\n        throw new Error(\n          `Validation failed: Invalid type for ID column '${tableName}.id'. Got 'one', expected one of ['string', 'hex', 'bigint', 'int'].`,\n        );\n      if (isManyColumn(table.id))\n        throw new Error(\n          `Validation failed: Invalid type for ID column '${tableName}.id'. Got 'many', expected one of ['string', 'hex', 'bigint', 'int'].`,\n        );\n      if (isReferenceColumn(table.id))\n        throw new Error(\n          `Validation failed: Invalid type for ID column '${tableName}.id'. ID columns cannot use the '.references' modifier.`,\n        );\n\n      if (\n        table.id[\" scalar\"] !== \"bigint\" &&\n        table.id[\" scalar\"] !== \"string\" &&\n        table.id[\" scalar\"] !== \"hex\" &&\n        table.id[\" scalar\"] !== \"int\"\n      )\n        throw new Error(\n          `Validation failed: Invalid type for ID column '${tableName}.id'. Got '${table.id[\" scalar\"]}', expected one of ['string', 'hex', 'bigint', 'int'].`,\n        );\n\n      if (isOptionalColumn(table.id))\n        throw new Error(\n          `Validation failed: Invalid type for ID column '${tableName}.id'. ID columns cannot be optional.`,\n        );\n      if (isListColumn(table.id))\n        throw new Error(\n          `Validation failed: Invalid type for ID column '${tableName}.id'. ID columns cannot be a list.`,\n        );\n\n      // Validate all other columns\n      Object.entries(table).forEach(([columnName, column]) => {\n        if (columnName === \"id\") return;\n\n        validateTableOrColumnName(columnName, \"Column\");\n\n        if (isOneColumn(column)) {\n          const usedColumn = Object.entries(table).find(\n            ([c]) => c === column[\" reference\"],\n          );\n\n          if (usedColumn === undefined) {\n            const otherColumns = Object.keys(table).filter(\n              (c) => c !== columnName,\n            );\n            throw new Error(\n              `Validation failed. Relationship column '${tableName}.${columnName}' uses a column that does not exist. Got '${\n                column[\" reference\"]\n              }', expected one of [${otherColumns.map((c) => `'${c}'`).join(\", \")}].`,\n            );\n          }\n\n          if (!isReferenceColumn(usedColumn[1])) {\n            const foreignKeyColumns = Object.keys(table).filter(\n              (c) => c !== columnName && isReferenceColumn(table[c]!),\n            );\n            throw new Error(\n              `Validation failed. Relationship column '${tableName}.${columnName}' uses a column that is not foreign key column. Got '${\n                column[\" reference\"]\n              }', expected one of [${foreignKeyColumns.map((c) => `'${c}'`).join(\", \")}].`,\n            );\n          }\n        }\n\n        if (isManyColumn(column)) {\n          const usedTable = Object.entries(getTables(schema)).find(\n            ([name]) => name === column[\" referenceTable\"],\n          );\n\n          if (usedTable === undefined) {\n            const otherTables = Object.keys(getTables(schema)).filter(\n              (t) => t !== tableName,\n            );\n\n            throw new Error(\n              `Validation failed. Relationship column '${tableName}.${columnName}' uses a table that does not exist. Got '${\n                column[\" referenceTable\"]\n              }', expected one of [${otherTables.map((t) => `'${t}'`).join(\", \")}].`,\n            );\n          }\n\n          const usedTableColumns = Object.entries(usedTable[1].table);\n          const usedColumn = usedTableColumns.find(\n            ([columnName]) => columnName === column[\" referenceColumn\"],\n          );\n\n          if (usedColumn === undefined) {\n            throw new Error(\n              `Validation failed. Relationship column '${tableName}.${columnName}' uses a column that does not exist. Got '${\n                column[\" referenceTable\"]\n              }.${column[\" referenceTable\"]}', expected one of [${usedTableColumns\n                .map((c) => `'${usedTable[0]}.${c}'`)\n                .join(\", \")}].`,\n            );\n          }\n\n          if (!isReferenceColumn(usedColumn[1])) {\n            const foreignKeyColumnNames = usedTableColumns.filter(([, c]) =>\n              isReferenceColumn(c),\n            );\n            throw new Error(\n              `Validation failed. Relationship column '${tableName}.${columnName}' uses a column that is not foreign key column. Got '${\n                column[\" referenceTable\"]\n              }.${column[\" referenceTable\"]}', expected one of [${foreignKeyColumnNames\n                .map((c) => `'${usedTable[0]}.${c}'`)\n                .join(\", \")}].`,\n            );\n          }\n        }\n\n        if (isEnumColumn(column)) {\n          const referencedEnum = Object.entries(getEnums(schema)).find(\n            ([enumName]) => enumName === column[\" enum\"],\n          );\n          if (referencedEnum === undefined) {\n            throw new Error(\n              `Validation failed: Enum column '${tableName}.${columnName}' doesn't reference a valid enum. Got '${\n                column[\" enum\"]\n              }', expected one of [${Object.keys(getEnums(schema))\n                .map((e) => `'${e}'`)\n                .join(\", \")}].`,\n            );\n          }\n        }\n\n        if (isReferenceColumn(column)) {\n          const referencedTable = Object.entries(getTables(schema)).find(\n            ([tableName]) => tableName === extractReferenceTable(column),\n          );\n\n          if (referencedTable === undefined) {\n            throw new Error(\n              `Validation failed: Foreign key column '${tableName}.${columnName}' does not reference a valid ID column. Got '${extractReferenceTable(\n                column,\n              )}', expected one of [${Object.keys(getTables(schema))\n                .map((t) => `'${t}.id'`)\n                .join(\", \")}].`,\n            );\n          }\n\n          if (referencedTable[1].table.id[\" scalar\"] !== column[\" scalar\"]) {\n            throw new Error(\n              `Validation failed: Foreign key column '${tableName}.${columnName}' type does not match the referenced table's ID column type. Got '${column[\" scalar\"]}', expected '${referencedTable[1].table.id[\" scalar\"]}'.`,\n            );\n          }\n\n          // NOTE: This is unreachable, but worth documenting here.\n          // if (column.list) {\n          //   throw new Error(\n          //     `Validation failed: Foreign key column '${tableName}.${columnName}' cannot use the 'list' modifier.`,\n          //   );\n          // }\n        }\n\n        // NOTE: This is unreachable, but worth documenting here.\n        // if (isPrimitiveColumn(column)) {\n        //   if (\n        //     column.type !== \"bigint\" &&\n        //     column.type !== \"string\" &&\n        //     column.type !== \"boolean\" &&\n        //     column.type !== \"int\" &&\n        //     column.type !== \"float\" &&\n        //     column.type !== \"hex\"\n        //   ) {\n        //     throw new Error(\n        //       `Validation failed: Primitive column '${tableName}.${columnName}' type is invalid. Got '${column.type}', expected one of ['bigint', 'string', 'boolean', 'int', 'float', 'hex'].`,\n        //     );\n        //   }\n        // }\n      });\n\n      // Validate constraints\n      if (constraints === undefined) return;\n\n      for (const [name, index] of Object.entries(constraints)) {\n        validateTableOrColumnName(name, \"index\");\n        const column = index[\" column\"];\n\n        if (Array.isArray(column)) {\n          if (column.length === 0)\n            throw new Error(\n              `Validation failed: Index '${name}' cannot be empty.`,\n            );\n\n          if (column.length !== dedupe(column as string[]).length)\n            throw new Error(\n              `Validation failed: Index '${name}' cannot contain duplicate columns.`,\n            );\n\n          for (const c of column) {\n            if (table[c] === undefined)\n              throw new Error(\n                `Validation failed: Index '${name}' does not reference a valid column. Got '${c}', expected one of [${Object.keys(\n                  table,\n                ).join(\", \")}].`,\n              );\n\n            if (isJSONColumn(table[c]!))\n              throw new Error(\n                `Validation failed: Invalid type for column '${column}' referenced by index '${name}'. Got 'json', expected one of ['string', 'hex', 'bigint', 'int', 'boolean', 'float'].`,\n              );\n\n            if (isOneColumn(table[c]!))\n              throw new Error(\n                `Validation failed: Invalid type for column '${column}' referenced by index '${name}'. Got 'one', expected one of ['string', 'hex', 'bigint', 'int', 'boolean', 'float'].`,\n              );\n\n            if (isManyColumn(table[c]!))\n              throw new Error(\n                `Validation failed: Invalid type for column '${column}' referenced by index '${name}'. Got 'many', expected one of ['string', 'hex', 'bigint', 'int', 'boolean', 'float'].`,\n              );\n          }\n        } else {\n          if (column === \"id\") {\n            logs.push({\n              level: \"warn\",\n              msg: `Ignoring index '${name}'. Column 'id' has a primary key constraint by default.`,\n            });\n            delete constraints[name];\n            continue;\n          }\n\n          if (table[column] === undefined)\n            throw new Error(\n              `Validation failed: Index '${name}' does not reference a valid column. Got '${column}', expected one of [${Object.entries(\n                table,\n              )\n                .filter(\n                  ([_, column]) =>\n                    !isOneColumn(column) && !isManyColumn(column),\n                )\n                .map(([columnName]) => columnName)\n                .join(\", \")}].`,\n            );\n\n          if (isJSONColumn(table[column]!))\n            throw new Error(\n              `Validation failed: Invalid type for column '${column}' referenced by index '${name}'. Got 'json', expected one of ['string', 'hex', 'bigint', 'int', 'boolean', 'float'].`,\n            );\n\n          if (isOneColumn(table[column]!))\n            throw new Error(\n              `Validation failed: Invalid type for column '${column}' referenced by index '${name}'. Got 'one', expected one of ['string', 'hex', 'bigint', 'int', 'boolean', 'float'].`,\n            );\n\n          if (isManyColumn(table[column]!))\n            throw new Error(\n              `Validation failed: Invalid type for column '${column}' referenced by index '${name}'. Got 'many', expected one of ['string', 'hex', 'bigint', 'int', 'boolean', 'float'].`,\n            );\n        }\n      }\n    },\n  );\n\n  return { schema, logs };\n};\n\nconst validateTableOrColumnName = (key: string, type: string) => {\n  if (key === \"\")\n    throw new Error(\n      `Validation failed: ${type} name can't be an empty string.`,\n    );\n\n  if (!/^[a-z|A-Z|0-9]+$/.test(key))\n    throw new Error(\n      `Validation failed: ${type} name '${key}' contains an invalid character.`,\n    );\n};\n\nexport function safeBuildSchema({ schema }: { schema: Schema }) {\n  try {\n    const result = buildSchema({ schema });\n    return {\n      status: \"success\",\n      schema: result.schema,\n      logs: result.logs,\n    } as const;\n  } catch (_error) {\n    const buildError = new BuildError((_error as Error).message);\n    buildError.stack = undefined;\n    return { status: \"error\", error: buildError } as const;\n  }\n}\n","import { readFileSync } from \"node:fs\";\nimport { codeFrameColumns } from \"@babel/code-frame\";\nimport { parse as parseStackTrace } from \"stacktrace-parser\";\n\nclass ESBuildTransformError extends Error {\n  override name = \"ESBuildTransformError\";\n}\n\nclass ESBuildBuildError extends Error {\n  override name = \"ESBuildBuildError\";\n}\n\nclass ESBuildContextError extends Error {\n  override name = \"ESBuildContextError\";\n}\n\ntype ViteNodeError =\n  | ESBuildTransformError\n  | ESBuildBuildError\n  | ESBuildContextError\n  | Error;\n\nexport function parseViteNodeError(file: string, error: Error): ViteNodeError {\n  let resolvedError: ViteNodeError;\n\n  if (/^(Transform failed|Build failed|Context failed)/.test(error.message)) {\n    // Handle ESBuild errors based on this error message construction logic:\n    // https://github.com/evanw/esbuild/blob/4e11b50fe3178ed0a78c077df78788d66304d379/lib/shared/common.ts#L1659\n    const errorKind = error.message.split(\" with \")[0] as\n      | \"Transform failed\"\n      | \"Build failed\"\n      | \"Context failed\";\n    const innerError = error.message\n      .split(\"\\n\")\n      .slice(1)\n      .map((message) => {\n        let location: string | undefined = undefined;\n        let detail: string | undefined = undefined;\n        if (message.includes(\": ERROR: \")) {\n          // /path/to/file.ts:11:9: ERROR: Expected \")\" but found \";\"\n          const s = message.split(\": ERROR: \");\n          location = s[0];\n          detail = s[1];\n        } else {\n          // error: some error without a location\n          detail = message.slice(7);\n        }\n        return { location, detail };\n      })[0];\n\n    // If we aren't able to extract an inner error, just return the original.\n    if (!innerError) return error;\n\n    resolvedError =\n      errorKind === \"Transform failed\"\n        ? new ESBuildTransformError(innerError.detail)\n        : errorKind === \"Build failed\"\n          ? new ESBuildBuildError(innerError.detail)\n          : new ESBuildContextError(innerError.detail);\n    if (innerError.location)\n      resolvedError.stack = `    at ${innerError.location}`;\n  }\n  // If it's not an ESBuild error, it's a user-land vm.runModuleInContext execution error.\n  // Attempt to build a user-land stack trace.\n  else if (error.stack) {\n    const stackFrames = parseStackTrace(error.stack);\n\n    const userStackFrames = [];\n    for (const rawStackFrame of stackFrames) {\n      if (rawStackFrame.methodName.includes(\"ViteNodeRunner.runModule\")) break;\n      userStackFrames.push(rawStackFrame);\n    }\n\n    const userStack = userStackFrames\n      .map(({ file, lineNumber, column, methodName }) => {\n        const prefix = \"    at\";\n        const path = `${file}${lineNumber !== null ? `:${lineNumber}` : \"\"}${\n          column !== null ? `:${column}` : \"\"\n        }`;\n        if (methodName === null || methodName === \"<unknown>\") {\n          return `${prefix} ${path}`;\n        } else {\n          return `${prefix} ${methodName} (${path})`;\n        }\n      })\n      .join(\"\\n\");\n\n    resolvedError = error;\n    resolvedError.stack = userStack;\n  }\n  // Still a vm.runModuleInContext execution error, but no stack.\n  else {\n    resolvedError = error;\n  }\n\n  // Attempt to build a code frame for the top of the user stack. This works for\n  // both ESBuild and vm.runModuleInContext errors.\n  if (resolvedError.stack) {\n    const userStackFrames = parseStackTrace(resolvedError.stack);\n\n    let codeFrame: string | undefined = undefined;\n    for (const { file, lineNumber, column } of userStackFrames) {\n      if (file !== null && lineNumber !== null) {\n        try {\n          const sourceFileContents = readFileSync(file, { encoding: \"utf-8\" });\n          codeFrame = codeFrameColumns(\n            sourceFileContents,\n            { start: { line: lineNumber, column: column ?? undefined } },\n            { highlightCode: true },\n          );\n          break;\n        } catch (err) {\n          // No-op.\n        }\n      }\n    }\n\n    resolvedError.stack = `${resolvedError.name}: ${resolvedError.message}\\n${resolvedError.stack}`;\n    if (codeFrame) resolvedError.stack += `\\n${codeFrame}`;\n  }\n\n  // Finally, add a useful relative file name and verb to the error message.\n  const verb =\n    resolvedError.name === \"ESBuildTransformError\"\n      ? \"transforming\"\n      : resolvedError.name === \"ESBuildBuildError\" ||\n          resolvedError.name === \"ESBuildContextError\"\n        ? \"building\"\n        : \"executing\";\n  resolvedError.message = `Error while ${verb} ${file}: ${resolvedError.message}`;\n\n  return resolvedError;\n}\n","import { type Extend, extend } from \"@/utils/extend.js\";\nimport { create, kill, start } from \"./service.js\";\nimport type {\n  ApiBuild,\n  ApiBuildResult,\n  IndexingBuild,\n  IndexingBuildResult,\n  Service,\n} from \"./service.js\";\n\nconst methods = { start, kill };\n\nexport const createBuildService = extend(create, methods);\n\nexport type BuildService = Extend<Service, typeof methods>;\n\nexport type { IndexingBuild, IndexingBuildResult, ApiBuild, ApiBuildResult };\n","import { mkdirSync, writeFileSync } from \"node:fs\";\nimport path from \"node:path\";\nimport type { Common } from \"@/common/common.js\";\nimport { type GraphQLSchema, printSchema } from \"graphql\";\n\nexport const ponderEnv = `// This file enables type checking and editor autocomplete for this Ponder project.\n// After upgrading, you may find that changes have been made to this file.\n// If this happens, please commit the changes. Do not manually edit this file.\n// See https://ponder.sh/docs/getting-started/installation#typescript for more information.\n\ndeclare module \"@/generated\" {\n  import type { Virtual } from \"@ponder/core\";\n\n  type config = typeof import(\"./ponder.config.ts\").default;\n  type schema = typeof import(\"./ponder.schema.ts\").default;\n\n  export const ponder: Virtual.Registry<config, schema>;\n\n  export type EventNames = Virtual.EventNames<config>;\n  export type Event<name extends EventNames = EventNames> = Virtual.Event<\n    config,\n    name\n  >;\n  export type Context<name extends EventNames = EventNames> = Virtual.Context<\n    config,\n    schema,\n    name\n  >;\n  export type ApiContext = Virtual.Drizzle<schema>;\n  export type IndexingFunctionArgs<name extends EventNames = EventNames> =\n    Virtual.IndexingFunctionArgs<config, schema, name>;\n  export type Schema = Virtual.Schema<schema>;\n}\n`;\n\nexport function runCodegen({\n  common,\n  graphqlSchema,\n}: {\n  common: Common;\n  graphqlSchema: GraphQLSchema;\n}) {\n  writeFileSync(\n    path.join(common.options.rootDir, \"ponder-env.d.ts\"),\n    ponderEnv,\n    \"utf8\",\n  );\n\n  common.logger.debug({\n    service: \"codegen\",\n    msg: \"Wrote new file at ponder-env.d.ts\",\n  });\n\n  mkdirSync(common.options.generatedDir, { recursive: true });\n  writeFileSync(\n    path.join(common.options.generatedDir, \"schema.graphql\"),\n    printSchema(graphqlSchema),\n    \"utf-8\",\n  );\n\n  common.logger.debug({\n    service: \"codegen\",\n    msg: \"Wrote new file at generated/schema.graphql\",\n  });\n}\n","import type { Prettify } from \"@/types/utils.js\";\nimport pc from \"picocolors\";\nimport { type DestinationStream, type LevelWithSilent, pino } from \"pino\";\n\nexport type LogMode = \"pretty\" | \"json\";\nexport type LogLevel = Prettify<LevelWithSilent>;\nexport type Logger = ReturnType<typeof createLogger>;\n\ntype Log = {\n  // Pino properties\n  level: 60 | 50 | 40 | 30 | 20 | 10;\n  time: number;\n\n  service: string;\n  msg: string;\n\n  error?: Error;\n};\n\nexport function createLogger({\n  level,\n  mode = \"pretty\",\n}: { level: LogLevel; mode?: LogMode }) {\n  const stream: DestinationStream = {\n    write(logString: string) {\n      if (mode === \"json\") {\n        console.log(logString.trimEnd());\n        return;\n      }\n\n      const log = JSON.parse(logString) as Log;\n      const prettyLog = format(log);\n      console.log(prettyLog);\n    },\n  };\n\n  const logger = pino(\n    {\n      level,\n      serializers: {\n        error: pino.stdSerializers.wrapErrorSerializer((error) => {\n          error.meta = Array.isArray(error.meta)\n            ? error.meta.join(\"\\n\")\n            : error.meta;\n          //@ts-ignore\n          error.type = undefined;\n          return error;\n        }),\n      },\n      // Removes \"pid\" and \"hostname\" properties from the log.\n      base: undefined,\n    },\n    stream,\n  );\n\n  return {\n    fatal(options: Omit<Log, \"level\" | \"time\">) {\n      logger.fatal(options);\n    },\n    error(options: Omit<Log, \"level\" | \"time\">) {\n      logger.error(options);\n    },\n    warn(options: Omit<Log, \"level\" | \"time\">) {\n      logger.warn(options);\n    },\n    info(options: Omit<Log, \"level\" | \"time\">) {\n      logger.info(options);\n    },\n    debug(options: Omit<Log, \"level\" | \"time\">) {\n      logger.debug(options);\n    },\n    trace(options: Omit<Log, \"level\" | \"time\">) {\n      logger.trace(options);\n    },\n    async kill() {},\n  };\n}\n\nconst levels = {\n  60: { label: \"FATAL\", colorLabel: pc.bgRed(\"FATAL\") },\n  50: { label: \"ERROR\", colorLabel: pc.red(\"ERROR\") },\n  40: { label: \"WARN \", colorLabel: pc.yellow(\"WARN \") },\n  30: { label: \"INFO \", colorLabel: pc.green(\"INFO \") },\n  20: { label: \"DEBUG\", colorLabel: pc.blue(\"DEBUG\") },\n  10: { label: \"TRACE\", colorLabel: pc.gray(\"TRACE\") },\n} as const;\n\nconst timeFormatter = new Intl.DateTimeFormat(undefined, {\n  hour: \"numeric\",\n  minute: \"numeric\",\n  second: \"numeric\",\n});\n\nconst format = (log: Log) => {\n  const time = timeFormatter.format(new Date(log.time));\n  const levelObject = levels[log.level ?? 30];\n\n  let prettyLog: string[];\n  if (pc.isColorSupported) {\n    const level = levelObject.colorLabel;\n    const service = log.service ? pc.cyan(log.service.padEnd(10, \" \")) : \"\";\n    const messageText = pc.reset(log.msg);\n\n    prettyLog = [`${pc.gray(time)} ${level} ${service} ${messageText}`];\n  } else {\n    const level = levelObject.label;\n    const service = log.service ? log.service.padEnd(10, \" \") : \"\";\n\n    prettyLog = [`${time} ${level} ${service} ${log.msg}`];\n  }\n\n  if (log.error) {\n    if (log.error.stack) {\n      prettyLog.push(log.error.stack);\n    } else {\n      prettyLog.push(`${log.error.name}: ${log.error.message}`);\n    }\n\n    if (\"meta\" in log.error) {\n      prettyLog.push(log.error.meta as string);\n    }\n  }\n  return prettyLog.join(\"\\n\");\n};\n","import prometheus from \"prom-client\";\n\nconst databaseQueryDurationMs = [\n  0.05, 0.1, 1, 5, 10, 25, 50, 75, 100, 250, 500, 750, 1_000, 2_500, 5_000,\n  7_500, 10_000, 25_000,\n];\n\nconst httpRequestDurationMs = [\n  5, 10, 25, 50, 75, 100, 250, 500, 750, 1_000, 2_500, 5_000, 7_500, 10_000,\n  25_000,\n];\n\nconst httpRequestSizeBytes = [\n  10, 100, 1_000, 5_000, 10_000, 50_000, 100_000, 500_000, 1_000_000, 5_000_000,\n  10_000_000,\n];\n\nexport class MetricsService {\n  registry: prometheus.Registry;\n\n  ponder_indexing_total_seconds: prometheus.Gauge;\n  ponder_indexing_completed_seconds: prometheus.Gauge;\n  ponder_indexing_completed_events: prometheus.Gauge<\"network\" | \"event\">;\n\n  ponder_indexing_completed_timestamp: prometheus.Gauge;\n  ponder_indexing_has_error: prometheus.Gauge;\n\n  ponder_indexing_function_duration: prometheus.Histogram<\"network\" | \"event\">;\n  ponder_indexing_function_error_total: prometheus.Counter<\"network\" | \"event\">;\n\n  ponder_historical_start_timestamp: prometheus.Gauge<\"network\">;\n  ponder_historical_total_blocks: prometheus.Gauge<\n    \"network\" | \"source\" | \"type\"\n  >;\n  ponder_historical_cached_blocks: prometheus.Gauge<\n    \"network\" | \"source\" | \"type\"\n  >;\n  ponder_historical_completed_blocks: prometheus.Gauge<\n    \"network\" | \"source\" | \"type\"\n  >;\n\n  ponder_realtime_is_connected: prometheus.Gauge<\"network\">;\n  ponder_realtime_latest_block_number: prometheus.Gauge<\"network\">;\n  ponder_realtime_latest_block_timestamp: prometheus.Gauge<\"network\">;\n  ponder_realtime_reorg_total: prometheus.Counter<\"network\">;\n\n  ponder_database_method_duration: prometheus.Histogram<\"service\" | \"method\">;\n  ponder_database_method_error_total: prometheus.Counter<\"service\" | \"method\">;\n\n  ponder_http_server_port: prometheus.Gauge;\n  ponder_http_server_active_requests: prometheus.Gauge<\"method\" | \"path\">;\n  ponder_http_server_request_duration_ms: prometheus.Histogram<\n    \"method\" | \"path\" | \"status\"\n  >;\n  ponder_http_server_request_size_bytes: prometheus.Histogram<\n    \"method\" | \"path\" | \"status\"\n  >;\n  ponder_http_server_response_size_bytes: prometheus.Histogram<\n    \"method\" | \"path\" | \"status\"\n  >;\n\n  ponder_rpc_request_duration: prometheus.Histogram<\"network\" | \"method\">;\n  ponder_rpc_request_lag: prometheus.Histogram<\"network\" | \"method\">;\n\n  ponder_postgres_pool_connections: prometheus.Gauge<\"pool\" | \"kind\"> = null!;\n  ponder_postgres_query_queue_size: prometheus.Gauge<\"pool\"> = null!;\n  ponder_postgres_query_total: prometheus.Counter<\"pool\"> = null!;\n\n  ponder_sqlite_query_total: prometheus.Counter<\"database\"> = null!;\n\n  constructor() {\n    this.registry = new prometheus.Registry();\n\n    this.ponder_indexing_total_seconds = new prometheus.Gauge({\n      name: \"ponder_indexing_total_seconds\",\n      help: \"Total number of seconds that are required\",\n      registers: [this.registry],\n    });\n    this.ponder_indexing_completed_seconds = new prometheus.Gauge({\n      name: \"ponder_indexing_completed_seconds\",\n      help: \"Number of seconds that have been completed\",\n      registers: [this.registry],\n    });\n    this.ponder_indexing_completed_events = new prometheus.Gauge({\n      name: \"ponder_indexing_completed_events\",\n      help: \"Number of events that have been processed\",\n      labelNames: [\"network\", \"event\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_indexing_completed_timestamp = new prometheus.Gauge({\n      name: \"ponder_indexing_completed_timestamp\",\n      help: \"Timestamp through which all events have been completed\",\n      registers: [this.registry],\n    });\n    this.ponder_indexing_has_error = new prometheus.Gauge({\n      name: \"ponder_indexing_has_error\",\n      help: \"Boolean (0 or 1) indicating if there is an indexing error\",\n      registers: [this.registry],\n    });\n    this.ponder_indexing_function_duration = new prometheus.Histogram({\n      name: \"ponder_indexing_function_duration\",\n      help: \"Duration of indexing function execution\",\n      labelNames: [\"network\", \"event\"] as const,\n      buckets: databaseQueryDurationMs,\n      registers: [this.registry],\n    });\n    this.ponder_indexing_function_error_total = new prometheus.Counter({\n      name: \"ponder_indexing_function_error_total\",\n      help: \"Total number of errors encountered during indexing function execution\",\n      labelNames: [\"network\", \"event\"] as const,\n      registers: [this.registry],\n    });\n\n    this.ponder_historical_start_timestamp = new prometheus.Gauge({\n      name: \"ponder_historical_start_timestamp\",\n      help: \"Unix timestamp (ms) when the historical sync service started\",\n      labelNames: [\"network\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_historical_total_blocks = new prometheus.Gauge({\n      name: \"ponder_historical_total_blocks\",\n      help: \"Number of blocks required for the historical sync\",\n      labelNames: [\"network\", \"source\", \"type\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_historical_cached_blocks = new prometheus.Gauge({\n      name: \"ponder_historical_cached_blocks\",\n      help: \"Number of blocks that were found in the cache for the historical sync\",\n      labelNames: [\"network\", \"source\", \"type\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_historical_completed_blocks = new prometheus.Gauge({\n      name: \"ponder_historical_completed_blocks\",\n      help: \"Number of blocks that have been processed for the historical sync\",\n      labelNames: [\"network\", \"source\", \"type\"] as const,\n      registers: [this.registry],\n    });\n\n    this.ponder_realtime_is_connected = new prometheus.Gauge({\n      name: \"ponder_realtime_is_connected\",\n      help: \"Boolean (0 or 1) indicating if the historical sync service is connected\",\n      labelNames: [\"network\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_realtime_latest_block_number = new prometheus.Gauge({\n      name: \"ponder_realtime_latest_block_number\",\n      help: \"Block number of the latest synced block\",\n      labelNames: [\"network\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_realtime_latest_block_timestamp = new prometheus.Gauge({\n      name: \"ponder_realtime_latest_block_timestamp\",\n      help: \"Block timestamp of the latest synced block\",\n      labelNames: [\"network\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_realtime_reorg_total = new prometheus.Counter({\n      name: \"ponder_realtime_reorg_total\",\n      help: \"Count of how many re-orgs have occurred.\",\n      labelNames: [\"network\"] as const,\n      registers: [this.registry],\n    });\n\n    this.ponder_database_method_duration = new prometheus.Histogram({\n      name: \"ponder_database_method_duration\",\n      help: \"Duration of database operations\",\n      labelNames: [\"service\", \"method\"] as const,\n      buckets: databaseQueryDurationMs,\n      registers: [this.registry],\n    });\n    this.ponder_database_method_error_total = new prometheus.Counter({\n      name: \"ponder_database_method_error_total\",\n      help: \"Total number of errors encountered during database operations\",\n      labelNames: [\"service\", \"method\"] as const,\n      registers: [this.registry],\n    });\n\n    this.ponder_http_server_port = new prometheus.Gauge({\n      name: \"ponder_http_server_port\",\n      help: \"Port that the server is listening on\",\n      registers: [this.registry],\n    });\n    this.ponder_http_server_active_requests = new prometheus.Gauge({\n      name: \"ponder_http_server_active_requests\",\n      help: \"Number of active HTTP server requests\",\n      labelNames: [\"method\", \"path\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_http_server_request_duration_ms = new prometheus.Histogram({\n      name: \"ponder_http_server_request_duration_ms\",\n      help: \"Duration of HTTP responses served the server\",\n      labelNames: [\"method\", \"path\", \"status\"] as const,\n      buckets: httpRequestDurationMs,\n      registers: [this.registry],\n    });\n    this.ponder_http_server_request_size_bytes = new prometheus.Histogram({\n      name: \"ponder_http_server_request_size_bytes\",\n      help: \"Size of HTTP requests received by the server\",\n      labelNames: [\"method\", \"path\", \"status\"] as const,\n      buckets: httpRequestSizeBytes,\n      registers: [this.registry],\n    });\n    this.ponder_http_server_response_size_bytes = new prometheus.Histogram({\n      name: \"ponder_http_server_response_size_bytes\",\n      help: \"Size of HTTP responses served the server\",\n      labelNames: [\"method\", \"path\", \"status\"] as const,\n      buckets: httpRequestSizeBytes,\n      registers: [this.registry],\n    });\n\n    this.ponder_rpc_request_duration = new prometheus.Histogram({\n      name: \"ponder_rpc_request_duration\",\n      help: \"Duration of RPC requests\",\n      labelNames: [\"network\", \"method\"] as const,\n      buckets: httpRequestDurationMs,\n      registers: [this.registry],\n    });\n    this.ponder_rpc_request_lag = new prometheus.Histogram({\n      name: \"ponder_rpc_request_lag\",\n      help: \"Time RPC requests spend waiting in the request queue\",\n      labelNames: [\"network\", \"method\"] as const,\n      buckets: databaseQueryDurationMs,\n      registers: [this.registry],\n    });\n\n    prometheus.collectDefaultMetrics({ register: this.registry });\n  }\n\n  /**\n   * Get string representation for all metrics.\n   * @returns Metrics encoded using Prometheus v0.0.4 format.\n   */\n  async getMetrics() {\n    return await this.registry.metrics();\n  }\n\n  resetMetrics() {\n    this.registry.resetMetrics();\n  }\n}\n\nexport async function getHistoricalSyncProgress(metrics: MetricsService) {\n  // Historical sync table\n  const startTimestampMetric =\n    (await metrics.ponder_historical_start_timestamp.get()).values?.[0]\n      ?.value ?? Date.now();\n\n  /** Aggregate block metrics for different \"types\" of sources. */\n  const reduceBlockMetrics = (\n    values: prometheus.MetricValue<\"network\" | \"source\" | \"type\">[],\n  ) =>\n    values.reduce<{\n      [id: string]: {\n        labels: { source: string; network: string };\n        value: number;\n      };\n    }>((acc, cur) => {\n      const id = `${cur.labels.source}_${cur.labels.network}_${\n        cur.labels.type === \"block\" ? \"block\" : \"contract\"\n      }`;\n\n      if (acc[id] === undefined) {\n        acc[id] = {\n          labels: {\n            source: cur.labels.source as string,\n            network: cur.labels.network as string,\n          },\n          value: cur.value,\n        };\n      } else {\n        // Note: entries in `values` with the same `id` have the same \"total\"\n        // block range. Using `Math.min()` ensures that a contract with both\n        // \"callTrace\" and \"log\" type sources are displayed correctly.\n        acc[id]!.value = Math.min(acc[id]!.value, cur.value);\n      }\n\n      return acc;\n    }, {});\n\n  const cachedBlocksMetric = await metrics.ponder_historical_cached_blocks\n    .get()\n    .then(({ values }) => reduceBlockMetrics(values));\n  const totalBlocksMetric = await metrics.ponder_historical_total_blocks\n    .get()\n    .then(({ values }) => reduceBlockMetrics(values));\n  const completedBlocksMetric = await metrics.ponder_historical_completed_blocks\n    .get()\n    .then(({ values }) => reduceBlockMetrics(values));\n\n  const sources = Object.entries(totalBlocksMetric).map(\n    ([\n      id,\n      {\n        labels: { source, network },\n        value: totalBlocks,\n      },\n    ]) => {\n      const cachedBlocks = cachedBlocksMetric[id]?.value;\n      const completedBlocks = completedBlocksMetric[id]?.value ?? 0;\n\n      // If cachedBlocks is not set, setup is not complete.\n      if (cachedBlocks === undefined) {\n        return {\n          sourceName: source,\n          networkName: network,\n          totalBlocks,\n          completedBlocks,\n        };\n      }\n\n      const progress = (completedBlocks + cachedBlocks) / totalBlocks;\n\n      const elapsed = Date.now() - startTimestampMetric;\n      const total = elapsed / (completedBlocks / (totalBlocks - cachedBlocks));\n      // The ETA is low quality if we've completed only one or two blocks.\n      const eta = completedBlocks >= 3 ? total - elapsed : undefined;\n\n      return {\n        sourceName: source,\n        networkName: network,\n        totalBlocks,\n        cachedBlocks,\n        completedBlocks,\n        progress,\n        eta,\n      };\n    },\n  );\n\n  const totalBlocks = sources.reduce((a, c) => a + c.totalBlocks, 0);\n  const cachedBlocks = sources.reduce((a, c) => a + (c.cachedBlocks ?? 0), 0);\n  const completedBlocks = sources.reduce(\n    (a, c) => a + (c.completedBlocks ?? 0),\n    0,\n  );\n  const progress =\n    totalBlocks === 0 ? 0 : (completedBlocks + cachedBlocks) / totalBlocks;\n\n  return {\n    overall: { totalBlocks, cachedBlocks, completedBlocks, progress },\n    sources,\n  };\n}\n\nexport async function getIndexingProgress(metrics: MetricsService) {\n  const hasErrorMetric = (await metrics.ponder_indexing_has_error.get())\n    .values[0]?.value;\n  const hasError = hasErrorMetric === 1;\n\n  const totalSeconds =\n    (await metrics.ponder_indexing_total_seconds.get()).values[0]?.value ?? 0;\n  const completedSeconds =\n    (await metrics.ponder_indexing_completed_seconds.get()).values[0]?.value ??\n    0;\n  const completedToTimestamp =\n    (await metrics.ponder_indexing_completed_timestamp.get()).values[0]!\n      .value ?? 0;\n\n  const progress = totalSeconds === 0 ? 0 : completedSeconds / totalSeconds;\n\n  const indexingCompletedEventsMetric = (\n    await metrics.ponder_indexing_completed_events.get()\n  ).values;\n  const indexingFunctionErrorMetric = (\n    await metrics.ponder_indexing_function_error_total.get()\n  ).values;\n  const indexingFunctionDurationMetric = (\n    await metrics.ponder_indexing_function_duration.get()\n  ).values;\n\n  const indexingDurationSum: Record<string, Record<string, number>> = {};\n  const indexingDurationCount: Record<string, Record<string, number>> = {};\n  for (const m of indexingFunctionDurationMetric) {\n    if (m.metricName === \"ponder_indexing_function_duration_sum\")\n      (indexingDurationSum[m.labels.event!] ??= {})[m.labels.network!] =\n        m.value;\n    if (m.metricName === \"ponder_indexing_function_duration_count\")\n      (indexingDurationCount[m.labels.event!] ??= {})[m.labels.network!] =\n        m.value;\n  }\n\n  const events = indexingCompletedEventsMetric.map((m) => {\n    const eventName = m.labels.event as string;\n    const networkName = m.labels.network as string;\n    const count = m.value;\n\n    const durationSum = indexingDurationSum[eventName]?.[networkName] ?? 0;\n    const durationCount = indexingDurationCount[eventName]?.[networkName] ?? 0;\n    const averageDuration =\n      durationCount === 0 ? 0 : durationSum / durationCount;\n\n    const errorCount =\n      indexingFunctionErrorMetric.find(\n        (e) => e.labels.event === eventName && e.labels.network === networkName,\n      )?.value ?? 0;\n\n    return { eventName, networkName, count, averageDuration, errorCount };\n  });\n\n  const totalEvents = events.reduce((a, e) => a + e.count, 0);\n\n  return {\n    hasError,\n    overall: {\n      completedSeconds,\n      totalSeconds,\n      progress,\n      completedToTimestamp,\n      totalEvents,\n    },\n    events,\n  };\n}\n","import os from \"node:os\";\nimport path from \"node:path\";\nimport type { CliOptions } from \"@/bin/ponder.js\";\nimport type { LevelWithSilent } from \"pino\";\n\nexport type Options = {\n  command: \"dev\" | \"start\" | \"serve\" | \"codegen\";\n\n  configFile: string;\n  schemaFile: string;\n  rootDir: string;\n  indexingDir: string;\n  apiDir: string;\n  generatedDir: string;\n  ponderDir: string;\n  logDir: string;\n\n  port: number;\n  hostname?: string;\n  maxHealthcheckDuration: number;\n\n  telemetryUrl: string;\n  telemetryDisabled: boolean;\n  telemetryConfigDir: string | undefined;\n\n  logLevel: LevelWithSilent;\n  logFormat: \"json\" | \"pretty\";\n\n  databaseHeartbeatInterval: number;\n  databaseHeartbeatTimeout: number;\n  databaseMaxQueryParameters: number;\n  databaseMaxRowLimit: number;\n\n  indexingCacheMaxBytes: number;\n  indexingCacheFlushRatio: number;\n\n  syncStoreMaxIntervals: number;\n  syncEventsQuerySize: number;\n};\n\nexport const buildOptions = ({ cliOptions }: { cliOptions: CliOptions }) => {\n  let rootDir: string;\n  if (cliOptions.root !== undefined) {\n    rootDir = path.resolve(cliOptions.root);\n  } else {\n    rootDir = path.resolve(\".\");\n  }\n\n  let logLevel: LevelWithSilent;\n  if (cliOptions.logLevel) {\n    logLevel = cliOptions.logLevel as LevelWithSilent;\n  } else if (cliOptions.trace === true) {\n    logLevel = \"trace\";\n  } else if (cliOptions.debug === true) {\n    logLevel = \"debug\";\n  } else if (\n    process.env.PONDER_LOG_LEVEL !== undefined &&\n    [\"silent\", \"fatal\", \"error\", \"warn\", \"info\", \"debug\", \"trace\"].includes(\n      process.env.PONDER_LOG_LEVEL,\n    )\n  ) {\n    logLevel = process.env.PONDER_LOG_LEVEL as LevelWithSilent;\n  } else {\n    logLevel = \"info\";\n  }\n\n  const port =\n    process.env.PORT !== undefined\n      ? Number(process.env.PORT)\n      : cliOptions.port !== undefined\n        ? cliOptions.port\n        : 42069;\n\n  const hostname = cliOptions.hostname;\n\n  return {\n    command: cliOptions.command,\n\n    rootDir,\n    configFile: path.join(rootDir, cliOptions.config),\n    schemaFile: path.join(rootDir, \"ponder.schema.ts\"),\n    indexingDir: path.join(rootDir, \"src\"),\n    apiDir: path.join(rootDir, \"src\", \"api\"),\n    generatedDir: path.join(rootDir, \"generated\"),\n    ponderDir: path.join(rootDir, \".ponder\"),\n    logDir: path.join(rootDir, \".ponder\", \"logs\"),\n\n    port,\n    hostname,\n    maxHealthcheckDuration: 240, // 4 minutes\n\n    telemetryUrl: \"https://ponder.sh/api/telemetry\",\n    telemetryDisabled: Boolean(process.env.PONDER_TELEMETRY_DISABLED),\n    telemetryConfigDir: undefined,\n\n    logLevel,\n    logFormat: cliOptions.logFormat! as Options[\"logFormat\"],\n\n    databaseHeartbeatInterval: 10 * 1000,\n    databaseHeartbeatTimeout: 25 * 1000,\n    // Half of the max query parameters for SQLite\n    databaseMaxQueryParameters: 16_000,\n    databaseMaxRowLimit: 1_000,\n\n    // os.freemem() / 4, bucketed closest to 64, 128, 256, 512, 1024, 2048 mB\n    indexingCacheMaxBytes:\n      2 **\n        Math.min(\n          Math.max(Math.round(Math.log2(os.freemem() / 1_024 / 1_024 / 4)), 6),\n          11,\n        ) *\n      1_024 *\n      1_024,\n    indexingCacheFlushRatio: 0.35,\n\n    syncStoreMaxIntervals: 50_000,\n    syncEventsQuerySize: 10_000,\n  } satisfies Options;\n};\n","import { exec } from \"node:child_process\";\nimport { createHash, randomBytes } from \"node:crypto\";\nimport { existsSync, readFileSync } from \"node:fs\";\nimport os from \"node:os\";\nimport path from \"node:path\";\nimport { promisify } from \"node:util\";\nimport type { IndexingBuild } from \"@/build/service.js\";\nimport type { Options } from \"@/common/options.js\";\nimport { getTables } from \"@/schema/utils.js\";\nimport { startClock } from \"@/utils/timer.js\";\nimport { wait } from \"@/utils/wait.js\";\nimport { createQueue } from \"@ponder/common\";\nimport Conf from \"conf\";\nimport { type PM, detect, getNpmVersion } from \"detect-package-manager\";\nimport type { Logger } from \"./logger.js\";\n\nconst HEARTBEAT_INTERVAL_MS = 60_000;\n\ntype TelemetryEvent =\n  | {\n      name: \"lifecycle:session_start\";\n      properties: { cli_command: string };\n    }\n  | {\n      name: \"lifecycle:session_end\";\n      properties: { duration_seconds: number };\n    }\n  | {\n      name: \"lifecycle:heartbeat_send\";\n      properties: { duration_seconds: number };\n    };\n\ntype CommonProperties = {\n  // Identification\n  project_id: string;\n  session_id: string;\n  is_internal: boolean;\n};\n\ntype SessionProperties = {\n  // Environment and package versions\n  package_manager: string;\n  package_manager_version: string;\n  node_version: string;\n  ponder_core_version: string;\n  viem_version: string;\n  // System and hardware\n  system_platform: NodeJS.Platform;\n  system_release: string;\n  system_architecture: string;\n  cpu_count: number;\n  cpu_model: string;\n  cpu_speed: number;\n  total_memory_bytes: number;\n};\n\ntype DeviceConf = {\n  notifiedAt?: string;\n  anonymousId?: string;\n  salt?: string;\n};\n\nexport type Telemetry = ReturnType<typeof createTelemetry>;\n\nexport function createTelemetry({\n  options,\n  logger,\n}: { options: Options; logger: Logger }) {\n  if (options.telemetryDisabled) {\n    return { record: (_event: TelemetryEvent) => {}, kill: async () => {} };\n  }\n\n  const conf = new Conf<DeviceConf>({\n    projectName: \"ponder\",\n    cwd: options.telemetryConfigDir,\n  });\n\n  if (conf.get(\"notifiedAt\") === undefined) {\n    conf.set(\"notifiedAt\", Date.now().toString());\n    logger.info({\n      service: \"telemetry\",\n      msg: \"Ponder collects anonymous telemetry data to identify issues and prioritize features. See https://ponder.sh/docs/advanced/telemetry for more information.\",\n    });\n  }\n\n  const sessionId = randomBytes(8).toString(\"hex\");\n\n  let anonymousId = conf.get(\"anonymousId\") as string;\n  if (anonymousId === undefined) {\n    anonymousId = randomBytes(8).toString(\"hex\");\n    conf.set(\"anonymousId\", anonymousId);\n  }\n  // Before 0.4.3, the anonymous ID was 64 characters long. Truncate it to 16\n  // here to align with new ID lengths.\n  if (anonymousId.length > 16) anonymousId = anonymousId.slice(0, 16);\n\n  let salt = conf.get(\"salt\") as string;\n  if (salt === undefined) {\n    salt = randomBytes(8).toString(\"hex\");\n    conf.set(\"salt\", salt);\n  }\n\n  // Prepend the value with a secret salt to ensure a credible one-way hash.\n  const oneWayHash = (value: string) => {\n    const hash = createHash(\"sha256\");\n    hash.update(salt);\n    hash.update(value);\n    return hash.digest(\"hex\").slice(0, 16);\n  };\n\n  const buildContext = async () => {\n    // Project ID is a one-way hash of the git remote URL OR the current working directory.\n    const gitRemoteUrl = await getGitRemoteUrl();\n    const projectIdRaw = gitRemoteUrl ?? process.cwd();\n    const projectId = oneWayHash(projectIdRaw);\n\n    const { packageManager, packageManagerVersion } = await getPackageManager();\n\n    // Attempt to find and read the users package.json file.\n    const packageJson = getPackageJson(options.rootDir);\n    const ponderCoreVersion =\n      packageJson?.dependencies?.[\"@ponder/core\"] ?? \"unknown\";\n    const viemVersion = packageJson?.dependencies?.viem ?? \"unknown\";\n\n    // Make a guess as to whether the project is internal (within the monorepo) or not.\n    const isInternal = ponderCoreVersion === \"workspace:*\";\n\n    const cpus = os.cpus();\n\n    return {\n      common: {\n        session_id: sessionId,\n        project_id: projectId,\n        is_internal: isInternal,\n      } satisfies CommonProperties,\n      session: {\n        ponder_core_version: ponderCoreVersion,\n        viem_version: viemVersion,\n        package_manager: packageManager,\n        package_manager_version: packageManagerVersion,\n        node_version: process.versions.node,\n        system_platform: os.platform(),\n        system_release: os.release(),\n        system_architecture: os.arch(),\n        cpu_count: cpus.length,\n        cpu_model: cpus.length > 0 ? cpus[0]!.model : \"unknown\",\n        cpu_speed: cpus.length > 0 ? cpus[0]!.speed : 0,\n        total_memory_bytes: os.totalmem(),\n      } satisfies SessionProperties,\n    };\n  };\n\n  let context: Awaited<ReturnType<typeof buildContext>> | undefined = undefined;\n  const contextPromise = buildContext();\n\n  const controller = new AbortController();\n  let isKilled = false;\n\n  const queue = createQueue({\n    initialStart: true,\n    concurrency: 10,\n    worker: async (event: TelemetryEvent) => {\n      const endClock = startClock();\n      try {\n        if (context === undefined) context = await contextPromise;\n\n        const properties =\n          event.name === \"lifecycle:session_start\"\n            ? { ...event.properties, ...context.common, ...context.session }\n            : { ...event.properties, ...context.common };\n\n        const body = JSON.stringify({\n          distinctId: anonymousId,\n          event: event.name,\n          properties,\n        });\n\n        await fetch(options.telemetryUrl, {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body,\n          signal: controller.signal,\n        });\n        logger.trace({\n          service: \"telemetry\",\n          msg: `Sent '${event.name}' event in ${endClock()}ms`,\n        });\n      } catch (error_) {\n        const error = error_ as Error;\n        logger.trace({\n          service: \"telemetry\",\n          msg: `Failed to send '${event.name}' event after ${endClock()}ms`,\n          error,\n        });\n      }\n    },\n  });\n\n  const record = (event: TelemetryEvent) => {\n    if (isKilled) return;\n    queue.add(event);\n  };\n\n  const heartbeatInterval = setInterval(() => {\n    record({\n      name: \"lifecycle:heartbeat_send\",\n      properties: { duration_seconds: process.uptime() },\n    });\n  }, HEARTBEAT_INTERVAL_MS);\n\n  const kill = async () => {\n    clearInterval(heartbeatInterval);\n    isKilled = true;\n    // If there are any events in the queue that have not started, drop them.\n    queue.clear();\n    // Wait at most 1 second for any in-flight events to complete.\n    await Promise.race([queue.onIdle(), wait(1_000)]);\n  };\n\n  return { record, kill };\n}\n\nasync function getPackageManager() {\n  let packageManager: PM = \"unknown\" as PM;\n  let packageManagerVersion = \"unknown\";\n  try {\n    packageManager = await detect();\n    packageManagerVersion = await getNpmVersion(packageManager);\n  } catch (e) {}\n  return { packageManager, packageManagerVersion };\n}\n\nconst execa = promisify(exec);\n\nasync function getGitRemoteUrl() {\n  const result = await execa(\"git config --local --get remote.origin.url\", {\n    timeout: 250,\n    windowsHide: true,\n  }).catch(() => undefined);\n\n  return result?.stdout.trim();\n}\n\ntype PackageJson = {\n  name?: string;\n  version?: string;\n  dependencies?: { [key: string]: string };\n  devDependencies?: { [key: string]: string };\n};\n\nfunction getPackageJson(rootDir: string) {\n  try {\n    const rootPath = path.join(rootDir, \"package.json\");\n    const cwdPath = path.join(process.cwd(), \"package.json\");\n\n    const packageJsonPath = existsSync(rootPath)\n      ? rootPath\n      : existsSync(cwdPath)\n        ? cwdPath\n        : undefined;\n    if (packageJsonPath === undefined) return undefined;\n\n    const packageJsonString = readFileSync(packageJsonPath, \"utf8\");\n    const packageJson = JSON.parse(packageJsonString) as PackageJson;\n\n    return packageJson;\n  } catch (e) {\n    return undefined;\n  }\n}\n\nexport function buildPayload(build: IndexingBuild) {\n  const table_count = Object.keys(getTables(build.schema)).length;\n  const indexing_function_count = Object.values(build.indexingFunctions).reduce(\n    (acc, f) => acc + Object.keys(f).length,\n    0,\n  );\n\n  return {\n    database_kind: build.databaseConfig.kind,\n    contract_count: build.sources.length,\n    network_count: build.networks.length,\n    table_count,\n    indexing_function_count,\n  };\n}\n","/**\n * Measures the elapsed wall clock time in milliseconds (ms) between two points.\n * @returns A function returning the elapsed time in milliseconds (ms).\n */\nexport function startClock() {\n  const start = process.hrtime();\n  return () => hrTimeToMs(process.hrtime(start));\n}\n\n/**\n * Converts a process.hrtime() measurement to milliseconds (ms).\n * @returns The timestamp in milliseconds (ms).\n */\nexport function hrTimeToMs(diff: [number, number]) {\n  const ns = diff[0] * 10 ** 9 + diff[1];\n  return ns / 10 ** 6;\n}\n","/** Waits at least a specified amount of time.\n *\n * @param milliseconds Minimum number of milliseconds to wait.\n */\nexport async function wait(milliseconds: number) {\n  return new Promise<void>((res) => setTimeout(res, milliseconds));\n}\n","import os from \"node:os\";\nimport readline from \"node:readline\";\nimport type { Common } from \"@/common/common.js\";\nimport { IgnorableError } from \"@/common/errors.js\";\n\nconst SHUTDOWN_GRACE_PERIOD_MS = 5_000;\n\n/**\n * Sets up shutdown handlers for the process. Accepts additional cleanup logic to run.\n */\nexport function setupShutdown({\n  common,\n  cleanup,\n}: {\n  common: Common;\n  cleanup: () => Promise<void>;\n}) {\n  let isShuttingDown = false;\n\n  const shutdown = async ({\n    reason,\n    code,\n  }: { reason: string; code: 0 | 1 }) => {\n    if (isShuttingDown) return;\n    isShuttingDown = true;\n    setTimeout(async () => {\n      common.logger.fatal({\n        service: \"process\",\n        msg: \"Failed to shutdown within 5 seconds, terminating (exit code 1)\",\n      });\n      await common.logger.kill();\n      process.exit(1);\n    }, SHUTDOWN_GRACE_PERIOD_MS);\n\n    if (reason !== undefined) {\n      common.logger.warn({\n        service: \"process\",\n        msg: `${reason}, starting shutdown sequence`,\n      });\n    }\n    common.telemetry.record({\n      name: \"lifecycle:session_end\",\n      properties: { duration_seconds: process.uptime() },\n    });\n\n    await cleanup();\n\n    const level = code === 0 ? \"info\" : \"fatal\";\n    common.logger[level]({\n      service: \"process\",\n      msg: `Finished shutdown sequence, terminating (exit code ${code})`,\n    });\n\n    await common.logger.kill();\n    process.exit(code);\n  };\n\n  if (os.platform() === \"win32\") {\n    const readlineInterface = readline.createInterface({\n      input: process.stdin,\n      output: process.stdout,\n    });\n    readlineInterface.on(\"SIGINT\", () =>\n      shutdown({ reason: \"Received SIGINT\", code: 0 }),\n    );\n  }\n\n  process.on(\"SIGINT\", () => shutdown({ reason: \"Received SIGINT\", code: 0 }));\n  process.on(\"SIGTERM\", () =>\n    shutdown({ reason: \"Received SIGTERM\", code: 0 }),\n  );\n  process.on(\"SIGQUIT\", () =>\n    shutdown({ reason: \"Received SIGQUIT\", code: 0 }),\n  );\n\n  process.on(\"uncaughtException\", (error: Error) => {\n    if (error instanceof IgnorableError) return;\n    common.logger.error({\n      service: \"process\",\n      msg: \"Caught uncaughtException event\",\n      error,\n    });\n    shutdown({ reason: \"Received uncaughtException\", code: 1 });\n  });\n  process.on(\"unhandledRejection\", (error: Error) => {\n    if (error instanceof IgnorableError) return;\n    common.logger.error({\n      service: \"process\",\n      msg: \"Caught unhandledRejection event\",\n      error,\n    });\n    shutdown({ reason: \"Received unhandledRejection\", code: 1 });\n  });\n\n  return shutdown;\n}\n","import { createBuildService } from \"@/build/index.js\";\nimport { runCodegen } from \"@/common/codegen.js\";\nimport { createLogger } from \"@/common/logger.js\";\nimport { MetricsService } from \"@/common/metrics.js\";\nimport { buildOptions } from \"@/common/options.js\";\nimport { createTelemetry } from \"@/common/telemetry.js\";\nimport type { CliOptions } from \"../ponder.js\";\nimport { setupShutdown } from \"../utils/shutdown.js\";\n\nexport async function codegen({ cliOptions }: { cliOptions: CliOptions }) {\n  const options = buildOptions({ cliOptions });\n\n  const logger = createLogger({\n    level: options.logLevel,\n    mode: options.logFormat,\n  });\n\n  const [major, minor, _patch] = process.versions.node\n    .split(\".\")\n    .map(Number) as [number, number, number];\n  if (major < 18 || (major === 18 && minor < 14)) {\n    logger.fatal({\n      service: \"process\",\n      msg: `Invalid Node.js version. Expected >=18.14, detected ${major}.${minor}.`,\n    });\n    await logger.kill();\n    process.exit(1);\n  }\n\n  const metrics = new MetricsService();\n  const telemetry = createTelemetry({ options, logger });\n  const common = { options, logger, metrics, telemetry };\n\n  const buildService = await createBuildService({ common });\n\n  const cleanup = async () => {\n    await buildService.kill();\n    await telemetry.kill();\n  };\n\n  const shutdown = setupShutdown({ common, cleanup });\n\n  const { indexing } = await buildService.start({ watch: false });\n\n  if (indexing.status === \"error\") {\n    logger.error({\n      service: \"process\",\n      msg: \"Failed schema build\",\n      error: indexing.error,\n    });\n    await shutdown({ reason: \"Failed schema build\", code: 1 });\n    return;\n  }\n\n  telemetry.record({\n    name: \"lifecycle:session_start\",\n    properties: { cli_command: \"codegen\" },\n  });\n\n  runCodegen({ common, graphqlSchema: indexing.build.graphqlSchema });\n\n  logger.info({ service: \"codegen\", msg: \"Wrote ponder-env.d.ts\" });\n  logger.info({ service: \"codegen\", msg: \"Wrote schema.graphql\" });\n\n  await shutdown({ reason: \"Success\", code: 0 });\n}\n","import { existsSync } from \"node:fs\";\nimport path from \"node:path\";\nimport {\n  type ApiBuildResult,\n  type IndexingBuildResult,\n  createBuildService,\n} from \"@/build/index.js\";\nimport { createLogger } from \"@/common/logger.js\";\nimport { MetricsService } from \"@/common/metrics.js\";\nimport { buildOptions } from \"@/common/options.js\";\nimport { buildPayload, createTelemetry } from \"@/common/telemetry.js\";\nimport { UiService } from \"@/ui/service.js\";\nimport { createQueue } from \"@ponder/common\";\nimport type { CliOptions } from \"../ponder.js\";\nimport { run } from \"../utils/run.js\";\nimport { runServer } from \"../utils/runServer.js\";\nimport { setupShutdown } from \"../utils/shutdown.js\";\n\nexport async function dev({ cliOptions }: { cliOptions: CliOptions }) {\n  const options = buildOptions({ cliOptions });\n\n  const logger = createLogger({\n    level: options.logLevel,\n    mode: options.logFormat,\n  });\n\n  const [major, minor, _patch] = process.versions.node\n    .split(\".\")\n    .map(Number) as [number, number, number];\n  if (major < 18 || (major === 18 && minor < 14)) {\n    logger.fatal({\n      service: \"process\",\n      msg: `Invalid Node.js version. Expected >=18.14, detected ${major}.${minor}.`,\n    });\n    await logger.kill();\n    process.exit(1);\n  }\n\n  if (!existsSync(path.join(options.rootDir, \".env.local\"))) {\n    logger.warn({\n      service: \"app\",\n      msg: \"Local environment file (.env.local) not found\",\n    });\n  }\n\n  const configRelPath = path.relative(options.rootDir, options.configFile);\n  logger.debug({\n    service: \"app\",\n    msg: `Started using config file: ${configRelPath}`,\n  });\n\n  const metrics = new MetricsService();\n  const telemetry = createTelemetry({ options, logger });\n  const common = { options, logger, metrics, telemetry };\n\n  const buildService = await createBuildService({ common });\n\n  const uiService = new UiService({ common });\n\n  let indexingCleanupReloadable = () => Promise.resolve();\n  let apiCleanupReloadable = () => Promise.resolve();\n\n  const cleanup = async () => {\n    await indexingCleanupReloadable();\n    await apiCleanupReloadable();\n    await buildService.kill();\n    await telemetry.kill();\n    uiService.kill();\n  };\n\n  const shutdown = setupShutdown({ common, cleanup });\n\n  const indexingBuildQueue = createQueue({\n    initialStart: true,\n    concurrency: 1,\n    worker: async (result: IndexingBuildResult) => {\n      await indexingCleanupReloadable();\n\n      if (result.status === \"success\") {\n        uiService.reset();\n        metrics.resetMetrics();\n\n        indexingCleanupReloadable = await run({\n          common,\n          build: result.build,\n          onFatalError: () => {\n            shutdown({ reason: \"Received fatal error\", code: 1 });\n          },\n          onReloadableError: (error) => {\n            indexingBuildQueue.clear();\n            indexingBuildQueue.add({ status: \"error\", error });\n          },\n        });\n      } else {\n        // This handles build failures and indexing errors on hot reload.\n        uiService.setReloadableError();\n        indexingCleanupReloadable = () => Promise.resolve();\n      }\n    },\n  });\n\n  const apiBuildQueue = createQueue({\n    initialStart: true,\n    concurrency: 1,\n    worker: async (result: ApiBuildResult) => {\n      await apiCleanupReloadable();\n\n      if (result.status === \"success\") {\n        apiCleanupReloadable = await runServer({\n          common,\n          build: result.build,\n        });\n      } else {\n        // This handles build failures on hot reload.\n        uiService.setReloadableError();\n        apiCleanupReloadable = () => Promise.resolve();\n      }\n    },\n  });\n\n  const { api, indexing } = await buildService.start({\n    watch: true,\n    onIndexingBuild: (buildResult) => {\n      indexingBuildQueue.clear();\n      indexingBuildQueue.add(buildResult);\n    },\n    onApiBuild: (buildResult) => {\n      apiBuildQueue.clear();\n      apiBuildQueue.add(buildResult);\n    },\n  });\n\n  if (indexing.status === \"error\" || api.status === \"error\") {\n    await shutdown({ reason: \"Failed intial build\", code: 1 });\n    return cleanup;\n  }\n\n  telemetry.record({\n    name: \"lifecycle:session_start\",\n    properties: {\n      cli_command: \"dev\",\n      ...buildPayload(indexing.build),\n    },\n  });\n\n  indexingBuildQueue.add(indexing);\n  apiBuildQueue.add(api);\n\n  return async () => {\n    indexingBuildQueue.pause();\n    apiBuildQueue.pause();\n    await cleanup();\n  };\n}\n","export const formatEta = (ms: number) => {\n  // If less than 1 second, return ms.\n  if (ms < 1000) return `${Math.round(ms)}ms`;\n  const seconds = Math.floor(ms / 1000);\n\n  const h = Math.floor(seconds / 3600);\n  const m = Math.floor((seconds - h * 3600) / 60);\n  const s = seconds - h * 3600 - m * 60;\n\n  const hstr = h > 0 ? `${h}h ` : \"\";\n  const mstr = m > 0 || h > 0 ? `${m}m ` : \"\";\n  const sstr = s > 0 || m > 0 ? `${s}s` : \"\";\n\n  return `${hstr}${mstr}${sstr}`;\n};\n\nexport const formatPercentage = (cacheRate: number) => {\n  const decimal = Math.round(cacheRate * 1000) / 10;\n  return Number.isInteger(decimal) && decimal < 100\n    ? `${decimal}.0%`\n    : `${decimal}%`;\n};\n","import { formatEta, formatPercentage } from \"@/utils/format.js\";\nimport { Box, Text, render as inkRender } from \"ink\";\nimport React from \"react\";\nimport { ProgressBar } from \"./ProgressBar.js\";\nimport Table from \"./Table.js\";\n\nexport type UiState = {\n  port: number;\n\n  historical: {\n    overall: {\n      totalBlocks: number;\n      cachedBlocks: number;\n      completedBlocks: number;\n      progress: number;\n    };\n    sources: {\n      sourceName: string;\n      networkName: string;\n      totalBlocks: number;\n      completedBlocks: number;\n      cachedBlocks?: number;\n      progress?: number;\n      eta?: number;\n    }[];\n  };\n\n  indexing: {\n    hasError: boolean;\n    overall: {\n      completedSeconds: number;\n      totalSeconds: number;\n      progress: number;\n      completedToTimestamp: number;\n      totalEvents: number;\n    };\n    events: {\n      eventName: string;\n      networkName: string;\n      count: number;\n      averageDuration: number;\n      errorCount: number;\n    }[];\n  };\n\n  realtimeSyncNetworks: {\n    name: string;\n    isConnected: boolean;\n  }[];\n};\n\nexport const buildUiState = () => {\n  const ui: UiState = {\n    historical: {\n      overall: {\n        totalBlocks: 0,\n        cachedBlocks: 0,\n        completedBlocks: 0,\n        progress: 0,\n      },\n      sources: [],\n    },\n\n    realtimeSyncNetworks: [],\n\n    indexing: {\n      hasError: false,\n      overall: {\n        completedSeconds: 0,\n        totalSeconds: 0,\n        progress: 0,\n        completedToTimestamp: 0,\n        totalEvents: 0,\n      },\n      events: [],\n    },\n\n    port: 0,\n  };\n\n  return ui;\n};\n\nconst App = (ui: UiState) => {\n  const { historical, indexing, port } = ui;\n\n  if (indexing.hasError) {\n    return (\n      <Box flexDirection=\"column\">\n        <Text> </Text>\n\n        <Text color=\"cyan\">\n          Resolve the error and save your changes to reload the server.\n        </Text>\n      </Box>\n    );\n  }\n\n  let historicalElement: JSX.Element;\n  if (historical.overall.progress === 0) {\n    historicalElement = (\n      <>\n        <Text bold={true}>Historical sync</Text>\n        <Text>Waiting to start...</Text>\n        <Text> </Text>\n      </>\n    );\n  } else if (historical.overall.progress === 1) {\n    historicalElement = (\n      <>\n        <Text>\n          <Text bold={true}>Historical sync </Text>(\n          <Text color=\"greenBright\">done</Text>)\n        </Text>\n        <Text> </Text>\n      </>\n    );\n  } else {\n    historicalElement = (\n      <>\n        <Text>\n          <Text bold={true}>Historical sync </Text>(\n          <Text color=\"yellowBright\">in progress</Text>)\n        </Text>\n        <Box flexDirection=\"row\">\n          <ProgressBar\n            current={historical.overall.progress}\n            end={1}\n            width={50}\n          />\n          <Text>\n            {\" \"}\n            {historical.overall.progress === 1 ? (\n              <Text color=\"greenBright\">done</Text>\n            ) : (\n              formatPercentage(historical.overall.progress)\n            )}{\" \"}\n            (\n            {historical.overall.cachedBlocks +\n              historical.overall.completedBlocks}{\" \"}\n            blocks)\n          </Text>\n        </Box>\n        <Text> </Text>\n\n        <Table\n          rows={historical.sources}\n          columns={[\n            { title: \"Source\", key: \"sourceName\", align: \"left\" },\n            { title: \"Network\", key: \"networkName\", align: \"left\" },\n            {\n              title: \"Cached\",\n              key: \"cachedBlocks\",\n              align: \"right\",\n              format: (_, row) =>\n                row.cachedBlocks !== undefined ? row.cachedBlocks : \"-\",\n            },\n            {\n              title: \"Completed\",\n              key: \"completedBlocks\",\n              align: \"right\",\n            },\n            { title: \"Total\", key: \"totalBlocks\", align: \"right\" },\n            {\n              title: \"Progress\",\n              key: \"progress\",\n              align: \"right\",\n              format: (v) => (v ? formatPercentage(v) : \"-\"),\n            },\n            {\n              title: \"ETA\",\n              key: \"eta\",\n              align: \"right\",\n              format: (v) => (v ? formatEta(v) : \"-\"),\n            },\n          ]}\n        />\n        <Text> </Text>\n      </>\n    );\n  }\n\n  let indexingElement: JSX.Element;\n\n  // Edge case: If all matched events occurred in the same unix timestamp (second), progress will\n  // be zero, even though indexing is complete. When this happens, totalEvents will be non-zero.\n  const indexingProgress =\n    indexing.overall.progress === 0 && indexing.overall.totalEvents > 0\n      ? 1\n      : indexing.overall.progress;\n\n  if (indexingProgress === 0) {\n    indexingElement = (\n      <>\n        <Text bold={true}>Indexing </Text>\n        <Text>Waiting to start...</Text>\n        <Text> </Text>\n      </>\n    );\n  } else {\n    const effectiveProgress = indexingProgress * historical.overall.progress;\n    indexingElement = (\n      <>\n        <Text>\n          <Text bold={true}>Indexing </Text>(\n          {effectiveProgress === 1 ? (\n            <Text color=\"greenBright\">done</Text>\n          ) : (\n            <Text color=\"yellowBright\">in progress</Text>\n          )}\n          )\n        </Text>\n        <Box flexDirection=\"row\">\n          <ProgressBar current={effectiveProgress} end={1} width={50} />\n          <Text> ({indexing.overall.totalEvents} events)</Text>\n        </Box>\n        <Text> </Text>\n\n        <Table\n          rows={indexing.events}\n          columns={[\n            { title: \"Event\", key: \"eventName\", align: \"left\" },\n            { title: \"Network\", key: \"networkName\", align: \"left\" },\n            { title: \"Count\", key: \"count\", align: \"right\" },\n            {\n              title: \"Error count\",\n              key: \"errorCount\",\n              align: \"right\",\n              format: (v, row) => (row.count > 0 ? v : \"-\"),\n            },\n            {\n              title: \"Duration (avg)\",\n              key: \"averageDuration\",\n              align: \"right\",\n              format: (v) =>\n                v > 0\n                  ? v < 1\n                    ? `${(v * 1_000).toFixed(2)}μs`\n                    : `${v.toFixed(2)}ms`\n                  : \"-\",\n            },\n          ]}\n        />\n        <Text> </Text>\n      </>\n    );\n  }\n\n  return (\n    <Box flexDirection=\"column\">\n      <Text> </Text>\n\n      {historicalElement}\n\n      {indexingElement}\n\n      {/* <Text bold={true}>Historical sync</Text>\n      {historical.overall.progress > 0 ? (\n        <>\n          <Box flexDirection=\"row\">\n            <ProgressBar\n              current={historical.overall.progress}\n              end={1}\n              width={40}\n            />\n            <Text>\n              {\" \"}\n              {historical.overall.progress === 1 ? (\n                <Text color=\"greenBright\">done</Text>\n              ) : (\n                formatPercentage(historical.overall.progress)\n              )}{\" \"}\n              ({historical.overall.totalBlocks} blocks)\n            </Text>\n          </Box>\n          <Text> </Text>\n\n          <Table\n            rows={historical.contracts}\n            columns={[\n              { title: \"Contract\", key: \"contractName\", align: \"left\" },\n              { title: \"Network\", key: \"networkName\", align: \"left\" },\n              { title: \"Total blocks\", key: \"totalBlocks\", align: \"right\" },\n              {\n                title: \"Cached %\",\n                key: \"cachedBlocks\",\n                align: \"right\",\n                format: (_, row) =>\n                  row.cachedBlocks !== undefined\n                    ? formatPercentage(row.cachedBlocks / row.totalBlocks)\n                    : \"-\",\n              },\n              {\n                title: \"Progress\",\n                key: \"progress\",\n                align: \"right\",\n                format: (v) => (v ? formatPercentage(v) : \"-\"),\n              },\n              {\n                title: \"ETA\",\n                key: \"eta\",\n                align: \"right\",\n                format: (v) => (v ? formatEta(v) : \"-\"),\n              },\n            ]}\n          />\n        </>\n      ) : (\n        <Text>Waiting to start...</Text>\n      )} */}\n\n      {/* <Text bold={true}>Indexing</Text>\n      {indexing.overall.progress > 0 ? (\n        <>\n          <Box flexDirection=\"row\">\n            <ProgressBar\n              current={indexing.overall.progress}\n              end={1}\n              width={40}\n            />\n            <Text>\n              {\" \"}\n              {indexing.overall.progress === 1 ? (\n                <Text color=\"greenBright\">up to date</Text>\n              ) : (\n                formatPercentage(indexing.overall.progress)\n              )}{\" \"}\n              ({indexing.overall.totalEvents} events)\n            </Text>\n          </Box>\n          <Text> </Text>\n\n          <Table\n            rows={indexing.events}\n            columns={[\n              { title: \"Event\", key: \"eventName\", align: \"left\" },\n              { title: \"Network\", key: \"networkName\", align: \"left\" },\n              { title: \"Count\", key: \"count\", align: \"right\" },\n              {\n                title: \"Error count\",\n                key: \"errorCount\",\n                align: \"right\",\n                format: (v, row) => (row.count > 0 ? v : \"-\"),\n              },\n              {\n                title: \"Duration (avg)\",\n                key: \"averageDuration\",\n                align: \"right\",\n                format: (v) => (v > 0 ? `${v.toFixed(2)}ms` : \"-\"),\n              },\n            ]}\n          />\n        </>\n      ) : (\n        <Text>Waiting to start...</Text>\n      )}\n      <Text> </Text> */}\n\n      {/* {realtimeSyncNetworks.length > 0 && (\n        <Box flexDirection=\"column\">\n          <Text bold={true}>Realtime sync </Text>\n          {realtimeSyncNetworks.map(({ name, isConnected }) => (\n            <Box flexDirection=\"row\" key={name}>\n              <Text>\n                {name.slice(0, 1).toUpperCase() + name.slice(1)} (\n                {isConnected ? \"live\" : \"disconnected\"})\n              </Text>\n            </Box>\n          ))}\n          <Text> </Text>\n        </Box>\n      )} */}\n\n      <Box flexDirection=\"column\">\n        <Text bold>GraphQL </Text>\n        <Box flexDirection=\"row\">\n          <Text>Server live at http://localhost:{port}</Text>\n        </Box>\n      </Box>\n    </Box>\n  );\n};\n\nexport const setupInkApp = (ui: UiState) => {\n  const { rerender, unmount: inkUnmount, clear } = inkRender(<App {...ui} />);\n\n  const render = (ui: UiState) => {\n    rerender(<App {...ui} />);\n  };\n\n  const unmount = () => {\n    clear();\n    inkUnmount();\n  };\n  return { render, unmount };\n};\n","import { Text } from \"ink\";\nimport React from \"react\";\n\nexport const ProgressBar = ({ current = 5, end = 10, width = 36 }) => {\n  const maxCount = width || process.stdout.columns || 80;\n\n  const fraction = current / end;\n  const count = Math.min(Math.floor(maxCount * fraction), maxCount);\n\n  return (\n    <Text>\n      <Text>{\"█\".repeat(count)}</Text>\n      <Text>{\"░\".repeat(maxCount - count)}</Text>\n    </Text>\n  );\n};\n","import { Box, Text } from \"ink\"; // Assuming you're using ink for CLI UI components\nimport React from \"react\";\n\nconst MAX_COLUMN_WIDTH = 24;\n\nexport function Table<TRow extends { [key: string]: any }>(props: {\n  columns: {\n    title: string;\n    key: keyof TRow;\n    align: \"left\" | \"right\";\n    format?: (value: any, row: TRow) => string | number | React.JSX.Element;\n  }[];\n  rows: TRow[];\n}) {\n  const { columns, rows } = props;\n\n  const formattedRows = rows.map((row) =>\n    columns.reduce(\n      (acc, column) => ({\n        ...acc,\n        [column.key.toString()]: column.format\n          ? column.format(row[column.key], row)\n          : row[column.key],\n      }),\n      {} as TRow,\n    ),\n  );\n\n  const columnWidths = columns.map((column) => {\n    let maxWidth = Math.max(\n      ...formattedRows.map((row) =>\n        row[column.key] !== undefined ? row[column.key].toString().length : 9,\n      ),\n      column.title.length,\n    );\n    maxWidth = Math.min(maxWidth, MAX_COLUMN_WIDTH);\n    return maxWidth;\n  });\n\n  return (\n    <Box flexDirection=\"column\">\n      {/* Column Titles */}\n      <Box flexDirection=\"row\" key=\"title\">\n        {columns.map(({ title, align }, index) => (\n          <React.Fragment key={`title-${title}`}>\n            <Text>│</Text>\n            <Box\n              width={columnWidths[index]}\n              justifyContent={align === \"left\" ? \"flex-start\" : \"flex-end\"}\n              marginX={1}\n            >\n              <Text bold wrap=\"truncate-end\">\n                {title}\n              </Text>\n            </Box>\n          </React.Fragment>\n        ))}\n        <Text>│</Text>\n      </Box>\n\n      {/* Separator Line */}\n      <Box flexDirection=\"row\" key=\"border\">\n        <Text>├</Text>\n        {columnWidths.map((width, index) => (\n          // biome-ignore lint/suspicious/noArrayIndexKey: <explanation>\n          <Text key={index}>\n            {\"─\".repeat(width + 2)}\n            {index < columns.length - 1 ? \"┼\" : \"┤\"}\n          </Text>\n        ))}\n      </Box>\n\n      {/* Rows of Data */}\n      {formattedRows.map((row, rowIndex) => (\n        <Box\n          flexDirection=\"row\"\n          // biome-ignore lint/suspicious/noArrayIndexKey: <explanation>\n          key={rowIndex}\n        >\n          {columns.map(({ key, align }, index) => (\n            // biome-ignore lint/suspicious/noArrayIndexKey: <explanation>\n            <React.Fragment key={index}>\n              <Text>│</Text>\n              <Box\n                width={columnWidths[index]}\n                justifyContent={align === \"left\" ? \"flex-start\" : \"flex-end\"}\n                marginX={1}\n              >\n                <Text wrap=\"truncate-end\">{row[key]}</Text>\n              </Box>\n            </React.Fragment>\n          ))}\n          <Text>│</Text>\n        </Box>\n      ))}\n    </Box>\n  );\n}\n\nexport default Table;\n","import type { Common } from \"@/common/common.js\";\nimport {\n  getHistoricalSyncProgress,\n  getIndexingProgress,\n} from \"@/common/metrics.js\";\nimport { buildUiState, setupInkApp } from \"./app.js\";\n\nexport class UiService {\n  private common: Common;\n\n  private ui = buildUiState();\n  private renderInterval?: NodeJS.Timeout;\n  private render?: () => void;\n  private unmount?: () => void;\n  private isKilled = false;\n\n  constructor({ common }: { common: Common }) {\n    this.common = common;\n\n    const { render, unmount } = setupInkApp(this.ui);\n    this.render = () => render(this.ui);\n    this.unmount = unmount;\n  }\n\n  reset() {\n    this.ui = buildUiState();\n    const metrics = this.common.metrics;\n\n    this.renderInterval = setInterval(async () => {\n      // Historical sync\n      this.ui.historical = await getHistoricalSyncProgress(metrics);\n\n      // Realtime sync\n      // const connectedNetworks = (\n      //   await metrics.ponder_realtime_is_connected.get()\n      // ).values\n      //   .filter((m) => m.value === 1)\n      //   .map((m) => m.labels.network)\n      //   .filter((n): n is string => typeof n === \"string\");\n      // const allNetworks = [\n      //   ...new Set(\n      //     sources\n      //       .filter((s) => s.endBlock === undefined)\n      //       .map((s) => s.networkName),\n      //   ),\n      // ];\n      // this.ui.realtimeSyncNetworks = allNetworks.map((networkName) => ({\n      //   name: networkName,\n      //   isConnected: connectedNetworks.includes(networkName),\n      // }));\n\n      // Indexing\n      this.ui.indexing = await getIndexingProgress(metrics);\n\n      // Server\n      const port = (await metrics.ponder_http_server_port.get()).values[0]!\n        .value;\n      this.ui.port = port;\n\n      if (this.isKilled) return;\n      this.render?.();\n    }, 17);\n  }\n\n  setReloadableError() {\n    this.ui.indexing.hasError = true;\n    this.render?.();\n  }\n\n  kill() {\n    this.isKilled = true;\n    clearInterval(this.renderInterval);\n    this.unmount?.();\n  }\n}\n","import type { Common } from \"@/common/common.js\";\nimport type { Kysely, Migration, MigrationProvider } from \"kysely\";\nimport { sql } from \"kysely\";\n\nconst migrations: Record<string, Migration> = {\n  \"2023_05_15_0_initial\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createTable(\"blocks\")\n        .addColumn(\"baseFeePerGas\", sql`bytea`) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"difficulty\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"extraData\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"gasLimit\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"gasUsed\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"hash\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logsBloom\", \"text\", (col) => col.notNull())\n        .addColumn(\"miner\", \"text\", (col) => col.notNull())\n        .addColumn(\"mixHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"nonce\", \"text\", (col) => col.notNull())\n        .addColumn(\"number\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"parentHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"receiptsRoot\", \"text\", (col) => col.notNull())\n        .addColumn(\"sha3Uncles\", \"text\", (col) => col.notNull())\n        .addColumn(\"size\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"stateRoot\", \"text\", (col) => col.notNull())\n        .addColumn(\"timestamp\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"totalDifficulty\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"transactionsRoot\", \"text\", (col) => col.notNull())\n        .execute();\n\n      await db.schema\n        .createTable(\"transactions\")\n        .addColumn(\"accessList\", \"text\")\n        .addColumn(\"blockHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"from\", \"text\", (col) => col.notNull())\n        .addColumn(\"gas\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"gasPrice\", sql`bytea`) // BigInt\n        .addColumn(\"hash\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"input\", \"text\", (col) => col.notNull())\n        .addColumn(\"maxFeePerGas\", sql`bytea`) // BigInt\n        .addColumn(\"maxPriorityFeePerGas\", sql`bytea`) // BigInt\n        .addColumn(\"nonce\", \"integer\", (col) => col.notNull())\n        .addColumn(\"r\", \"text\", (col) => col.notNull())\n        .addColumn(\"s\", \"text\", (col) => col.notNull())\n        .addColumn(\"to\", \"text\")\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"type\", \"text\", (col) => col.notNull())\n        .addColumn(\"value\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"v\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .execute();\n\n      await db.schema\n        .createTable(\"logs\")\n        .addColumn(\"address\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"topic0\", \"text\")\n        .addColumn(\"topic1\", \"text\")\n        .addColumn(\"topic2\", \"text\")\n        .addColumn(\"topic3\", \"text\")\n        .addColumn(\"transactionHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .execute();\n\n      await db.schema\n        .createTable(\"contractReadResults\")\n        .addColumn(\"address\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"result\", \"text\", (col) => col.notNull())\n        .addPrimaryKeyConstraint(\"contractReadResultPrimaryKey\", [\n          \"chainId\",\n          \"blockNumber\",\n          \"address\",\n          \"data\",\n        ])\n        .execute();\n\n      await db.schema\n        .createTable(\"logFilterCachedRanges\")\n        .addColumn(\"endBlock\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"endBlockTimestamp\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"filterKey\", \"text\", (col) => col.notNull())\n        // The `id` column should not be included in INSERT statements.\n        // This column uses Postgres SERIAL type which autoincrements.\n        .addColumn(\"id\", \"serial\", (col) => col.notNull().primaryKey())\n        .addColumn(\"startBlock\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .execute();\n    },\n  },\n  \"2023_06_20_0_indices\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createIndex(\"log_events_index\")\n        .on(\"logs\")\n        .columns([\"address\", \"chainId\", \"blockHash\"])\n        .execute();\n\n      await db.schema\n        .createIndex(\"blocks_index\")\n        .on(\"blocks\")\n        .columns([\"timestamp\", \"number\"])\n        .execute();\n\n      await db.schema\n        .createIndex(\"logFilterCachedRanges_index\")\n        .on(\"logFilterCachedRanges\")\n        .columns([\"filterKey\"])\n        .execute();\n    },\n  },\n  \"2023_07_18_0_better_indices\": {\n    async up(db: Kysely<any>) {\n      // Drop old indices.\n      await db.schema.dropIndex(\"log_events_index\").execute();\n      await db.schema.dropIndex(\"blocks_index\").execute();\n\n      // Block hash is a join key.\n      await db.schema\n        .createIndex(\"log_block_hash_index\")\n        .on(\"logs\")\n        .column(\"blockHash\")\n        .execute();\n\n      // Chain ID, address and topic0 are all used in WHERE clauses.\n      await db.schema\n        .createIndex(\"log_chain_id_index\")\n        .on(\"logs\")\n        .column(\"chainId\")\n        .execute();\n      await db.schema\n        .createIndex(\"log_address_index\")\n        .on(\"logs\")\n        .column(\"address\")\n        .execute();\n      await db.schema\n        .createIndex(\"log_topic0_index\")\n        .on(\"logs\")\n        .column(\"topic0\")\n        .execute();\n\n      // Block timestamp and number are both used in WHERE and SORT clauses.\n      await db.schema\n        .createIndex(\"block_timestamp_index\")\n        .on(\"blocks\")\n        .column(\"timestamp\")\n        .execute();\n      await db.schema\n        .createIndex(\"block_number_index\")\n        .on(\"blocks\")\n        .column(\"number\")\n        .execute();\n    },\n  },\n  \"2023_07_24_0_drop_finalized\": {\n    async up(db: Kysely<any>) {\n      await db.schema.alterTable(\"blocks\").dropColumn(\"finalized\").execute();\n      await db.schema\n        .alterTable(\"transactions\")\n        .dropColumn(\"finalized\")\n        .execute();\n      await db.schema.alterTable(\"logs\").dropColumn(\"finalized\").execute();\n      await db.schema\n        .alterTable(\"contractReadResults\")\n        .dropColumn(\"finalized\")\n        .execute();\n    },\n  },\n  \"2023_09_19_0_new_sync_design\": {\n    async up(db: Kysely<any>) {\n      /** This table is no longer being used. */\n      await db.schema.dropTable(\"logFilterCachedRanges\").execute();\n\n      /** Drop and re-create all tables to fix bigint encoding. */\n      await db.schema.dropTable(\"blocks\").execute();\n      await db.schema\n        .createTable(\"blocks\")\n        .addColumn(\"baseFeePerGas\", \"numeric(78, 0)\")\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"difficulty\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"extraData\", \"text\", (col) => col.notNull())\n        .addColumn(\"gasLimit\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"gasUsed\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"hash\", \"varchar(66)\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logsBloom\", \"varchar(514)\", (col) => col.notNull())\n        .addColumn(\"miner\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"mixHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"nonce\", \"varchar(18)\", (col) => col.notNull())\n        .addColumn(\"number\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"parentHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"receiptsRoot\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"sha3Uncles\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"size\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"stateRoot\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"timestamp\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"totalDifficulty\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"transactionsRoot\", \"varchar(66)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"blockTimestampIndex\")\n        .on(\"blocks\")\n        .column(\"timestamp\")\n        .execute();\n      await db.schema\n        .createIndex(\"blockNumberIndex\")\n        .on(\"blocks\")\n        .column(\"number\")\n        .execute();\n\n      await db.schema.dropTable(\"transactions\").execute();\n      await db.schema\n        .createTable(\"transactions\")\n        .addColumn(\"accessList\", \"text\")\n        .addColumn(\"blockHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"from\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"gas\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"gasPrice\", \"numeric(78, 0)\")\n        .addColumn(\"hash\", \"varchar(66)\", (col) => col.notNull().primaryKey())\n        .addColumn(\"input\", \"text\", (col) => col.notNull())\n        .addColumn(\"maxFeePerGas\", \"numeric(78, 0)\")\n        .addColumn(\"maxPriorityFeePerGas\", \"numeric(78, 0)\")\n        .addColumn(\"nonce\", \"integer\", (col) => col.notNull())\n        .addColumn(\"r\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"s\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"to\", \"varchar(42)\")\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"type\", \"text\", (col) => col.notNull())\n        .addColumn(\"value\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"v\", \"numeric(78, 0)\", (col) => col.notNull())\n        .execute();\n\n      await db.schema.dropTable(\"logs\").execute();\n      await db.schema\n        .createTable(\"logs\")\n        .addColumn(\"address\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"blockHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"topic0\", \"varchar(66)\")\n        .addColumn(\"topic1\", \"varchar(66)\")\n        .addColumn(\"topic2\", \"varchar(66)\")\n        .addColumn(\"topic3\", \"varchar(66)\")\n        .addColumn(\"transactionHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"logBlockHashIndex\")\n        .on(\"logs\")\n        .column(\"blockHash\")\n        .execute();\n      await db.schema\n        .createIndex(\"logChainIdIndex\")\n        .on(\"logs\")\n        .column(\"chainId\")\n        .execute();\n      await db.schema\n        .createIndex(\"logAddressIndex\")\n        .on(\"logs\")\n        .column(\"address\")\n        .execute();\n      await db.schema\n        .createIndex(\"logTopic0Index\")\n        .on(\"logs\")\n        .column(\"topic0\")\n        .execute();\n\n      await db.schema.dropTable(\"contractReadResults\").execute();\n      await db.schema\n        .createTable(\"contractReadResults\")\n        .addColumn(\"address\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"result\", \"text\", (col) => col.notNull())\n        .addPrimaryKeyConstraint(\"contractReadResultPrimaryKey\", [\n          \"chainId\",\n          \"blockNumber\",\n          \"address\",\n          \"data\",\n        ])\n        .execute();\n\n      /** Add new log filter and factory contract interval tables. */\n      await db.schema\n        .createTable(\"logFilters\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${address}_${topic0}_${topic1}_${topic2}_${topic3}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"address\", \"varchar(66)\")\n        .addColumn(\"topic0\", \"varchar(66)\")\n        .addColumn(\"topic1\", \"varchar(66)\")\n        .addColumn(\"topic2\", \"varchar(66)\")\n        .addColumn(\"topic3\", \"varchar(66)\")\n        .execute();\n      await db.schema\n        .createTable(\"logFilterIntervals\")\n        .addColumn(\"id\", \"serial\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"logFilterId\", \"text\", (col) =>\n          col.notNull().references(\"logFilters.id\"),\n        )\n        .addColumn(\"startBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"logFilterIntervalsLogFilterId\")\n        .on(\"logFilterIntervals\")\n        .column(\"logFilterId\")\n        .execute();\n\n      await db.schema\n        .createTable(\"factories\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${address}_${eventSelector}_${childAddressLocation}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"address\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"eventSelector\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"childAddressLocation\", \"text\", (col) => col.notNull()) // `topic${number}` or `offset${number}`\n        .addColumn(\"topic0\", \"varchar(66)\")\n        .addColumn(\"topic1\", \"varchar(66)\")\n        .addColumn(\"topic2\", \"varchar(66)\")\n        .addColumn(\"topic3\", \"varchar(66)\")\n        .execute();\n      await db.schema\n        .createTable(\"factoryLogFilterIntervals\")\n        .addColumn(\"id\", \"serial\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"factoryId\", \"text\", (col) =>\n          col.notNull().references(\"factories.id\"),\n        )\n        .addColumn(\"startBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"factoryLogFilterIntervalsFactoryId\")\n        .on(\"factoryLogFilterIntervals\")\n        .column(\"factoryId\")\n        .execute();\n    },\n  },\n  \"2023_11_06_0_new_rpc_cache_design\": {\n    async up(db: Kysely<any>) {\n      await db.schema.dropTable(\"contractReadResults\").execute();\n\n      /**\n       * Formatting for \"request\" field values:\n       *\n       * eth_call: eth_call_{to}_{data}\n       * eth_getBalance: eth_getBalance_{address}\n       * eth_getCode: eth_getCode_{address}\n       * eth_getStorageAt: eth_getStorageAt_{address}_{slot}\n       */\n      await db.schema\n        .createTable(\"rpcRequestResults\")\n        .addColumn(\"request\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"result\", \"text\", (col) => col.notNull())\n        .addPrimaryKeyConstraint(\"rpcRequestResultPrimaryKey\", [\n          \"request\",\n          \"chainId\",\n          \"blockNumber\",\n        ])\n        .execute();\n    },\n  },\n  \"2024_01_30_0_change_chain_id_type\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .alterTable(\"blocks\")\n        .alterColumn(\"chainId\", (col) => col.setDataType(\"int8\"))\n        .execute();\n\n      await db.schema\n        .alterTable(\"transactions\")\n        .alterColumn(\"chainId\", (col) => col.setDataType(\"int8\"))\n        .execute();\n\n      await db.schema\n        .alterTable(\"logs\")\n        .alterColumn(\"chainId\", (col) => col.setDataType(\"int8\"))\n        .execute();\n\n      await db.schema\n        .alterTable(\"logFilters\")\n        .alterColumn(\"chainId\", (col) => col.setDataType(\"int8\"))\n        .execute();\n\n      await db.schema\n        .alterTable(\"factories\")\n        .alterColumn(\"chainId\", (col) => col.setDataType(\"int8\"))\n        .execute();\n\n      await db.schema\n        .alterTable(\"rpcRequestResults\")\n        .alterColumn(\"chainId\", (col) => col.setDataType(\"int8\"))\n        .execute();\n    },\n  },\n  \"2024_02_1_0_nullable_block_columns\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .alterTable(\"blocks\")\n        .alterColumn(\"mixHash\", (col) => col.dropNotNull())\n        .execute();\n      await db.schema\n        .alterTable(\"blocks\")\n        .alterColumn(\"nonce\", (col) => col.dropNotNull())\n        .execute();\n    },\n  },\n  \"2024_03_00_0_log_transaction_hash_index\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createIndex(\"log_transaction_hash_index\")\n        .on(\"logs\")\n        .column(\"transactionHash\")\n        .execute();\n    },\n  },\n  \"2024_03_13_0_nullable_block_columns_sha3uncles\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .alterTable(\"blocks\")\n        .alterColumn(\"sha3Uncles\", (col) => col.dropNotNull())\n        .execute();\n    },\n  },\n  \"2024_03_14_0_nullable_transaction_rsv\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .alterTable(\"transactions\")\n        .alterColumn(\"r\", (col) => col.dropNotNull())\n        .execute();\n      await db.schema\n        .alterTable(\"transactions\")\n        .alterColumn(\"s\", (col) => col.dropNotNull())\n        .execute();\n      await db.schema\n        .alterTable(\"transactions\")\n        .alterColumn(\"v\", (col) => col.dropNotNull())\n        .execute();\n    },\n  },\n  \"2024_03_20_0_checkpoint_in_logs_table\": {\n    async up(_db: Kysely<any>) {\n      // no-op migration to avoid crashing databases that successfully ran this migration\n      return;\n    },\n  },\n  \"2024_04_04_0_log_events_indexes\": {\n    async up(db: Kysely<any>) {\n      await db.schema.dropIndex(\"blockNumberIndex\").ifExists().execute();\n      await db.schema.dropIndex(\"blockTimestampIndex\").ifExists().execute();\n\n      await db.schema\n        .createIndex(\"logBlockNumberIndex\")\n        .on(\"logs\")\n        .column(\"blockNumber\")\n        .execute();\n    },\n  },\n  \"2024_04_14_0_nullable_block_total_difficulty\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .alterTable(\"blocks\")\n        .alterColumn(\"totalDifficulty\", (col) => col.dropNotNull())\n        .execute();\n    },\n  },\n  \"2024_04_14_1_add_checkpoint_column_to_logs_table\": {\n    async up(db: Kysely<any>) {\n      await db.executeQuery(\n        sql`\n        ALTER TABLE ponder_sync.logs \n        ADD COLUMN IF NOT EXISTS \n        checkpoint varchar(75)`.compile(db),\n      );\n    },\n  },\n  \"2024_04_14_2_set_checkpoint_in_logs_table\": {\n    async up(db: Kysely<any>) {\n      await db.executeQuery(sql`SET statement_timeout = 3600000;`.compile(db));\n      await db.executeQuery(\n        sql`\n        CREATE TEMP TABLE cp_vals AS \n        SELECT\n          logs.id,\n          (lpad(blocks.timestamp::text, 10, '0') ||\n          lpad(blocks.\"chainId\"::text, 16, '0') ||\n          lpad(blocks.number::text, 16, '0') ||\n          lpad(logs.\"transactionIndex\"::text, 16, '0') ||\n          '5' ||\n          lpad(logs.\"logIndex\"::text, 16, '0')) AS checkpoint\n        FROM ponder_sync.logs logs\n        JOIN ponder_sync.blocks blocks ON logs.\"blockHash\" = blocks.hash;\n        `.compile(db),\n      );\n\n      await db.executeQuery(\n        sql`\n        CREATE INDEX ON cp_vals(id)\n        `.compile(db),\n      );\n\n      await db.executeQuery(\n        sql`\n          UPDATE ponder_sync.logs\n          SET checkpoint=cp_vals.checkpoint\n          FROM cp_vals\n          WHERE ponder_sync.logs.id = cp_vals.id\n        `.compile(db),\n      );\n    },\n  },\n  \"2024_04_14_3_index_on_logs_checkpoint\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createIndex(\"logs_checkpoint_index\")\n        .ifNotExists()\n        .on(\"logs\")\n        .column(\"checkpoint\")\n        .execute();\n    },\n  },\n  \"2024_04_22_0_transaction_receipts\": {\n    async up(db: Kysely<any>) {\n      // Update the log filter ID keys to include the integer includeTransactionReceipts value.\n      // Note that we have to remove the FK constraint, which is fine given our app logic.\n      await db.schema\n        .alterTable(\"logFilterIntervals\")\n        .dropConstraint(\"logFilterIntervals_logFilterId_fkey\")\n        .execute();\n      await db\n        .updateTable(\"logFilters\")\n        .set({ id: sql`\"id\" || '_0'` })\n        .execute();\n      await db\n        .updateTable(\"logFilterIntervals\")\n        .set({ logFilterId: sql`\"logFilterId\" || '_0'` })\n        .execute();\n      // Add the includeTransactionReceipts column. By setting a default in the ADD COLUMN statement,\n      // Postgres will automatically populate all existing rows with the default value. But, we don't\n      // actually want a default (want to require a value on insertion), so immediately drop the default.\n      await db.schema\n        .alterTable(\"logFilters\")\n        .addColumn(\"includeTransactionReceipts\", \"integer\", (col) =>\n          col.notNull().defaultTo(0),\n        )\n        .execute();\n      await db.schema\n        .alterTable(\"logFilters\")\n        .alterColumn(\"includeTransactionReceipts\", (col) => col.dropDefault())\n        .execute();\n\n      // Repeat the same 2 steps for the factory tables.\n      await db.schema\n        .alterTable(\"factoryLogFilterIntervals\")\n        .dropConstraint(\"factoryLogFilterIntervals_factoryId_fkey\")\n        .execute();\n      await db\n        .updateTable(\"factories\")\n        .set({ id: sql`\"id\" || '_0'` })\n        .execute();\n      await db\n        .updateTable(\"factoryLogFilterIntervals\")\n        .set({ factoryId: sql`\"factoryId\" || '_0'` })\n        .execute();\n      await db.schema\n        .alterTable(\"factories\")\n        .addColumn(\"includeTransactionReceipts\", \"integer\", (col) =>\n          col.notNull().defaultTo(0),\n        )\n        .execute();\n      await db.schema\n        .alterTable(\"factories\")\n        .alterColumn(\"includeTransactionReceipts\", (col) => col.dropDefault())\n        .execute();\n\n      await db.schema\n        .createTable(\"transactionReceipts\")\n        .addColumn(\"blockHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"contractAddress\", \"varchar(66)\")\n        .addColumn(\"cumulativeGasUsed\", \"numeric(78, 0)\", (col) =>\n          col.notNull(),\n        )\n        .addColumn(\"effectiveGasPrice\", \"numeric(78, 0)\", (col) =>\n          col.notNull(),\n        )\n        .addColumn(\"from\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"gasUsed\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"logs\", \"text\", (col) => col.notNull())\n        .addColumn(\"logsBloom\", \"varchar(514)\", (col) => col.notNull())\n        .addColumn(\"status\", \"text\", (col) => col.notNull())\n        .addColumn(\"to\", \"varchar(42)\")\n        .addColumn(\"transactionHash\", \"varchar(66)\", (col) =>\n          col.notNull().primaryKey(),\n        )\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"type\", \"text\", (col) => col.notNull())\n        .execute();\n    },\n  },\n  \"2024_04_23_0_block_filters\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createTable(\"blockFilters\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${interval}_${offset}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"interval\", \"integer\", (col) => col.notNull())\n        .addColumn(\"offset\", \"integer\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createTable(\"blockFilterIntervals\")\n        .addColumn(\"id\", \"serial\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"blockFilterId\", \"text\", (col) =>\n          col.notNull().references(\"blockFilters.id\"),\n        )\n        .addColumn(\"startBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"blockFilterIntervalsBlockFilterId\")\n        .on(\"blockFilterIntervals\")\n        .column(\"blockFilterId\")\n        .execute();\n\n      await db.schema\n        .alterTable(\"blocks\")\n        .addColumn(\"checkpoint\", \"varchar(75)\")\n        .execute();\n\n      await db.executeQuery(\n        sql`\n          CREATE TEMP TABLE bcp_vals AS \n          SELECT\n            blocks.hash,\n            (lpad(blocks.timestamp::text, 10, '0') ||\n            lpad(blocks.\"chainId\"::text, 16, '0') ||\n            lpad(blocks.number::text, 16, '0') ||\n            '9999999999999999' ||\n            '5' ||\n            '0000000000000000') AS checkpoint\n          FROM ponder_sync.blocks\n          `.compile(db),\n      );\n\n      await db.executeQuery(\n        sql`\n          UPDATE ponder_sync.blocks\n          SET checkpoint=bcp_vals.checkpoint\n          FROM bcp_vals\n          WHERE ponder_sync.blocks.hash = bcp_vals.hash\n        `.compile(db),\n      );\n\n      await db.schema\n        .alterTable(\"blocks\")\n        .alterColumn(\"checkpoint\", (col) => col.setNotNull())\n        .execute();\n\n      // The blocks.number index supports getEvents and deleteRealtimeData\n      await db.schema\n        .createIndex(\"blockNumberIndex\")\n        .on(\"blocks\")\n        .column(\"number\")\n        .execute();\n      // The blocks.chainId index supports getEvents and deleteRealtimeData\n      await db.schema\n        .createIndex(\"blockChainIdIndex\")\n        .on(\"blocks\")\n        .column(\"chainId\")\n        .execute();\n      // The blocks.checkpoint index supports getEvents\n      await db.schema\n        .createIndex(\"blockCheckpointIndex\")\n        .on(\"blocks\")\n        .column(\"checkpoint\")\n        .execute();\n    },\n  },\n  \"2024_05_07_0_trace_filters\": {\n    async up(db: Kysely<any>) {\n      // TODO(kyle) drop foreign key constraint on \"blockFilterIntervals.blockFilterId\".\n\n      await db.schema\n        .createTable(\"traceFilters\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${fromAddress}_${toAddress}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"fromAddress\", \"varchar(42)\")\n        .addColumn(\"toAddress\", \"varchar(42)\")\n        .execute();\n      await db.schema\n        .createTable(\"traceFilterIntervals\")\n        .addColumn(\"id\", \"serial\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"traceFilterId\", \"text\", (col) => col.notNull())\n        .addColumn(\"startBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"traceFilterIntervalsTraceFilterId\")\n        .on(\"traceFilterIntervals\")\n        .column(\"traceFilterId\")\n        .execute();\n\n      await db.schema\n        .createTable(\"callTraces\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"callType\", \"text\", (col) => col.notNull())\n        .addColumn(\"from\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"gas\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"input\", \"text\", (col) => col.notNull())\n        .addColumn(\"to\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"value\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"blockHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"error\", \"text\")\n        .addColumn(\"gasUsed\", \"numeric(78, 0)\")\n        .addColumn(\"output\", \"text\")\n        .addColumn(\"subtraces\", \"integer\", (col) => col.notNull())\n        .addColumn(\"traceAddress\", \"text\", (col) => col.notNull())\n        .addColumn(\"transactionHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"transactionPosition\", \"integer\", (col) => col.notNull())\n        .addColumn(\"functionSelector\", \"varchar(10)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"checkpoint\", \"varchar(75)\", (col) => col.notNull())\n        .execute();\n\n      // The callTraces.blockNumber index supports getEvents and deleteRealtimeData\n      await db.schema\n        .createIndex(\"callTracesBlockNumberIndex\")\n        .on(\"callTraces\")\n        .column(\"blockNumber\")\n        .execute();\n\n      // The callTraces.functionSelector index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesFunctionSelectorIndex\")\n        .on(\"callTraces\")\n        .column(\"functionSelector\")\n        .execute();\n\n      // The callTraces.error index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesErrorIndex\")\n        .on(\"callTraces\")\n        .column(\"error\")\n        .execute();\n\n      // The callTraces.blockHash index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesBlockHashIndex\")\n        .on(\"callTraces\")\n        .column(\"blockHash\")\n        .execute();\n\n      // The callTraces.transactionHash index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesTransactionHashIndex\")\n        .on(\"callTraces\")\n        .column(\"transactionHash\")\n        .execute();\n\n      // The callTraces.checkpoint index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesCheckpointIndex\")\n        .on(\"callTraces\")\n        .column(\"checkpoint\")\n        .execute();\n\n      // The callTraces.chainId index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesChainIdIndex\")\n        .on(\"callTraces\")\n        .column(\"chainId\")\n        .execute();\n\n      // The callTraces.from index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesFromIndex\")\n        .on(\"callTraces\")\n        .column(\"from\")\n        .execute();\n\n      // The callTraces.to index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesToIndex\")\n        .on(\"callTraces\")\n        .column(\"to\")\n        .execute();\n\n      await db.schema\n        .alterTable(\"factories\")\n        .renameTo(\"factoryLogFilters\")\n        .execute();\n\n      await db.schema\n        .createTable(\"factoryTraceFilters\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${address}_${eventSelector}_${childAddressLocation}_${fromAddress}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"address\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"eventSelector\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"childAddressLocation\", \"text\", (col) => col.notNull()) // `topic${number}` or `offset${number}`\n        .addColumn(\"fromAddress\", \"varchar(42)\")\n        .execute();\n      await db.schema\n        .createTable(\"factoryTraceFilterIntervals\")\n        .addColumn(\"id\", \"serial\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"factoryId\", \"text\")\n        .addColumn(\"startBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"factoryTraceFilterIntervalsFactoryId\")\n        .on(\"factoryTraceFilterIntervals\")\n        .column(\"factoryId\")\n        .execute();\n    },\n  },\n};\n\nclass StaticMigrationProvider implements MigrationProvider {\n  async getMigrations() {\n    return migrations;\n  }\n}\n\nexport const migrationProvider = new StaticMigrationProvider();\n\nexport async function moveLegacyTables({\n  common,\n  db,\n  newSchemaName,\n}: {\n  common: Common;\n  db: Kysely<any>;\n  newSchemaName: string;\n}) {\n  // If the database has ponder migration tables present in the public schema,\n  // move them to the new schema.\n  let hasLegacyMigrations = false;\n  try {\n    const { rows } = await db.executeQuery<{ name: string }>(\n      sql`SELECT * FROM public.kysely_migration LIMIT 1`.compile(db),\n    );\n    if (rows[0]?.name === \"2023_05_15_0_initial\") hasLegacyMigrations = true;\n  } catch (e) {\n    const error = e as Error;\n    if (!error.message.includes(\"does not exist\")) throw error;\n  }\n\n  if (!hasLegacyMigrations) return;\n\n  common.logger.warn({\n    service: \"database\",\n    msg: \"Detected legacy sync migrations. Moving tables from 'public' schema to 'ponder_sync'.\",\n  });\n\n  async function moveOrDeleteTable(tableName: string) {\n    try {\n      await db.schema\n        .alterTable(`public.${tableName}`)\n        .setSchema(newSchemaName)\n        .execute();\n    } catch (e) {\n      const error = e as Error;\n      switch (error.message) {\n        case `relation \"${tableName}\" already exists in schema \"${newSchemaName}\"`: {\n          await db.schema\n            .dropTable(`public.${tableName}`)\n            .execute()\n            // Ignore errors if this fails.\n            .catch(() => {});\n          break;\n        }\n        case `relation \"public.${tableName}\" does not exist`: {\n          break;\n        }\n        default: {\n          common.logger.warn({\n            service: \"database\",\n            msg: `Failed to migrate table \"${tableName}\" to \"ponder_sync\" schema: ${error.message}`,\n          });\n        }\n      }\n    }\n\n    common.logger.warn({\n      service: \"database\",\n      msg: `Successfully moved 'public.${tableName}' table to 'ponder_sync' schema.`,\n    });\n  }\n\n  const tableNames = [\n    \"kysely_migration\",\n    \"kysely_migration_lock\",\n    \"blocks\",\n    \"logs\",\n    \"transactions\",\n    \"rpcRequestResults\",\n    // Note that logFilterIntervals has a constraint that uses logFilters,\n    // so the order here matters. Same story with factoryLogFilterIntervals.\n    \"logFilterIntervals\",\n    \"logFilters\",\n    \"factoryLogFilterIntervals\",\n    \"factories\",\n    // Old ones that are no longer being used, but should still be moved\n    // so that older migrations work as expected.\n    \"contractReadResults\",\n    \"logFilterCachedRanges\",\n  ];\n\n  for (const tableName of tableNames) {\n    await moveOrDeleteTable(tableName);\n  }\n}\n","export type Checkpoint = {\n  blockTimestamp: number;\n  chainId: bigint;\n  blockNumber: bigint;\n  transactionIndex: bigint;\n  eventType: number;\n  eventIndex: bigint;\n};\n\n// 10 digits for unix timestamp gets us to the year 2277.\nconst BLOCK_TIMESTAMP_DIGITS = 10;\n// Chain IDs are uint256. As of writing the largest Chain ID on https://chainlist.org\n// is 13 digits. 16 digits should be enough (JavaScript's max safe integer).\nconst CHAIN_ID_DIGITS = 16;\n// Same logic as chain ID.\nconst BLOCK_NUMBER_DIGITS = 16;\n// Same logic as chain ID.\nconst TRANSACTION_INDEX_DIGITS = 16;\n// At time of writing, we only have 2 event types planned, so one digit (10 types) is enough.\nconst EVENT_TYPE_DIGITS = 1;\n// This could contain log index, trace index, etc. 16 digits should be enough.\nconst EVENT_INDEX_DIGITS = 16;\n\nconst CHECKPOINT_LENGTH =\n  BLOCK_TIMESTAMP_DIGITS +\n  CHAIN_ID_DIGITS +\n  BLOCK_NUMBER_DIGITS +\n  TRANSACTION_INDEX_DIGITS +\n  EVENT_TYPE_DIGITS +\n  EVENT_INDEX_DIGITS;\n\nexport const EVENT_TYPES = {\n  blocks: 5,\n  logs: 5,\n  callTraces: 7,\n} as const;\n\nexport const encodeCheckpoint = (checkpoint: Checkpoint) => {\n  const {\n    blockTimestamp,\n    chainId,\n    blockNumber,\n    transactionIndex,\n    eventType,\n    eventIndex,\n  } = checkpoint;\n\n  if (eventType < 0 || eventType > 9)\n    throw new Error(\n      `Got invalid event type ${eventType}, expected a number from 0 to 9`,\n    );\n\n  const result =\n    blockTimestamp.toString().padStart(BLOCK_TIMESTAMP_DIGITS, \"0\") +\n    chainId.toString().padStart(CHAIN_ID_DIGITS, \"0\") +\n    blockNumber.toString().padStart(BLOCK_NUMBER_DIGITS, \"0\") +\n    transactionIndex.toString().padStart(TRANSACTION_INDEX_DIGITS, \"0\") +\n    eventType.toString() +\n    eventIndex.toString().padStart(EVENT_INDEX_DIGITS, \"0\");\n\n  if (result.length !== CHECKPOINT_LENGTH)\n    throw new Error(`Invalid stringified checkpoint: ${result}`);\n\n  return result;\n};\n\nexport const decodeCheckpoint = (checkpoint: string): Checkpoint => {\n  let offset = 0;\n\n  const blockTimestamp = +checkpoint.slice(\n    offset,\n    offset + BLOCK_TIMESTAMP_DIGITS,\n  );\n  offset += BLOCK_TIMESTAMP_DIGITS;\n\n  const chainId = BigInt(checkpoint.slice(offset, offset + CHAIN_ID_DIGITS));\n  offset += CHAIN_ID_DIGITS;\n\n  const blockNumber = BigInt(\n    checkpoint.slice(offset, offset + BLOCK_NUMBER_DIGITS),\n  );\n  offset += BLOCK_NUMBER_DIGITS;\n\n  const transactionIndex = BigInt(\n    checkpoint.slice(offset, offset + TRANSACTION_INDEX_DIGITS),\n  );\n  offset += TRANSACTION_INDEX_DIGITS;\n\n  const eventType = +checkpoint.slice(offset, offset + EVENT_TYPE_DIGITS);\n  offset += EVENT_TYPE_DIGITS;\n\n  const eventIndex = BigInt(\n    checkpoint.slice(offset, offset + EVENT_INDEX_DIGITS),\n  );\n  offset += EVENT_INDEX_DIGITS;\n\n  return {\n    blockTimestamp,\n    chainId,\n    blockNumber,\n    transactionIndex,\n    eventType,\n    eventIndex,\n  };\n};\n\nexport const zeroCheckpoint: Checkpoint = {\n  blockTimestamp: 0,\n  chainId: 0n,\n  blockNumber: 0n,\n  transactionIndex: 0n,\n  eventType: 0,\n  eventIndex: 0n,\n};\n\nexport const maxCheckpoint: Checkpoint = {\n  blockTimestamp: 99999_99999,\n  chainId: 9999_9999_9999_9999n,\n  blockNumber: 9999_9999_9999_9999n,\n  transactionIndex: 9999_9999_9999_9999n,\n  eventType: 9,\n  eventIndex: 9999_9999_9999_9999n,\n};\n\n/**\n * Returns true if two checkpoints are equal.\n */\nexport const isCheckpointEqual = (a: Checkpoint, b: Checkpoint) =>\n  encodeCheckpoint(a) === encodeCheckpoint(b);\n\n/**\n * Returns true if checkpoint a is greater than checkpoint b.\n * Returns false if the checkpoints are equal.\n */\nexport const isCheckpointGreaterThan = (a: Checkpoint, b: Checkpoint) =>\n  encodeCheckpoint(a) > encodeCheckpoint(b);\n\n/**\n * Returns true if checkpoint a is greater than or equal to checkpoint b.\n */\nexport const isCheckpointGreaterThanOrEqualTo = (\n  a: Checkpoint,\n  b: Checkpoint,\n) => encodeCheckpoint(a) >= encodeCheckpoint(b);\n\nexport const checkpointMax = (...checkpoints: Checkpoint[]) =>\n  checkpoints.reduce((max, checkpoint) => {\n    return isCheckpointGreaterThan(checkpoint, max) ? checkpoint : max;\n  });\n\nexport const checkpointMin = (...checkpoints: Checkpoint[]) =>\n  checkpoints.reduce((min, checkpoint) => {\n    return isCheckpointGreaterThan(min, checkpoint) ? checkpoint : min;\n  });\n\nexport const LATEST = encodeCheckpoint(maxCheckpoint);\n","import { createHash } from \"node:crypto\";\n\n// Adapted from https://stackoverflow.com/questions/77336994/stronger-type-for-value-in-json-stringifyvalue-any\ntype JSONSerializable =\n  | string\n  | number\n  | boolean\n  | null\n  | JSONObject\n  | JSONArray;\ntype JSONObject = { [key: string]: JSONSerializable };\ntype JSONArray = Array<JSONSerializable>;\n\n/**\n * Generates a 10-character hexadecimal hash of a JSON-serializable value.\n */\nexport function hash(value: JSONSerializable): string {\n  return createHash(\"sha256\")\n    .update(JSON.stringify(value))\n    .digest(\"hex\")\n    .slice(0, 10);\n}\n","import pg, { type PoolConfig } from \"pg\";\nimport { prettyPrint } from \"./print.js\";\n\n// See https://github.com/brianc/node-pg-types for details.\n// Use BigInt for `numeric` types.\npg.types.setTypeParser(pg.types.builtins.NUMERIC, BigInt);\n// Use Number for `bigint`/`int8` types. We use these for chain IDs.\npg.types.setTypeParser(pg.types.builtins.INT8, Number);\n\n// Monkeypatch Pool.query to get more informative stack traces. I have no idea why this works.\n// https://stackoverflow.com/a/70601114\nconst originalClientQuery = pg.Client.prototype.query;\n// @ts-ignore\npg.Client.prototype.query = function query(\n  ...args: [queryText: string, values: any[], callback: () => void]\n) {\n  try {\n    return originalClientQuery.apply(this, args);\n  } catch (error_) {\n    const error = error_ as Error & { detail?: string; meta?: string[] };\n    const [statement, parameters_] = args ?? [\"empty\", []];\n\n    error.name = \"PostgresError\";\n\n    let parameters = parameters_ ?? [];\n    parameters =\n      parameters.length <= 25\n        ? parameters\n        : parameters.slice(0, 26).concat([\"...\"]);\n    const params = parameters.reduce<Record<number, any>>(\n      (acc, parameter, idx) => {\n        acc[idx + 1] = parameter;\n        return acc;\n      },\n      {},\n    );\n\n    error.meta = Array.isArray(error.meta) ? error.meta : [];\n    if (error.detail) error.meta.push(`Detail:\\n  ${error.detail}`);\n    error.meta.push(`Statement:\\n  ${statement}`);\n    error.meta.push(`Parameters:\\n${prettyPrint(params)}`);\n\n    throw error;\n  }\n};\n\nclass ReadonlyClient extends pg.Client {\n  // @ts-expect-error\n  override connect(\n    callback: (err: Error) => void | undefined,\n  ): void | Promise<void> {\n    if (callback) {\n      super.connect(() => {\n        this.query(\n          \"SET SESSION CHARACTERISTICS AS TRANSACTION READ ONLY\",\n          callback,\n        );\n      });\n    } else {\n      return super.connect().then(async () => {\n        await this.query(\n          \"SET SESSION CHARACTERISTICS AS TRANSACTION READ ONLY\",\n        );\n      });\n    }\n  }\n}\n\nexport function createPool(config: PoolConfig) {\n  return new pg.Pool({\n    // https://stackoverflow.com/questions/59155572/how-to-set-query-timeout-in-relation-to-statement-timeout\n    statement_timeout: 2 * 60 * 1000, // 2 minutes\n    ...config,\n  });\n}\n\nexport function createReadonlyPool(config: PoolConfig) {\n  return new pg.Pool({\n    // https://stackoverflow.com/questions/59155572/how-to-set-query-timeout-in-relation-to-statement-timeout\n    statement_timeout: 2 * 60 * 1000, // 2 minutes\n    // @ts-expect-error: The custom Client is an undocumented option.\n    Client: ReadonlyClient,\n    ...config,\n  });\n}\n","// Adapted from viem.\n// https://github.com/wagmi-dev/viem/blob/021ce8e5a3fb02db6139564345a91fc77cba08a6/src/errors/transaction.ts#L6-L19\nexport function prettyPrint(\n  args: Record<string, bigint | number | string | undefined | false | unknown>,\n) {\n  const entries = Object.entries(args)\n    .map(([key, value]) => {\n      if (value === undefined) return null;\n\n      const trimmedValue =\n        typeof value === \"string\" && value.length > 80\n          ? value.slice(0, 80).concat(\"...\")\n          : value;\n\n      return [key, trimmedValue];\n    })\n    .filter(Boolean) as [string, string][];\n  const maxLength = entries.reduce(\n    (acc, [key]) => Math.max(acc, key.length),\n    0,\n  );\n  return entries\n    .map(([key, value]) => `  ${`${key}`.padEnd(maxLength + 1)}  ${value}`)\n    .join(\"\\n\");\n}\n","import type { Common } from \"@/common/common.js\";\nimport { NonRetryableError } from \"@/common/errors.js\";\nimport type { PoolConfig } from \"@/config/database.js\";\nimport type { Enum, Schema, Table } from \"@/schema/common.js\";\nimport {\n  encodeSchema,\n  getEnums,\n  getTables,\n  isEnumColumn,\n  isJSONColumn,\n  isListColumn,\n  isManyColumn,\n  isOneColumn,\n  isOptionalColumn,\n} from \"@/schema/utils.js\";\nimport type { SyncStoreTables } from \"@/sync-store/postgres/encoding.js\";\nimport {\n  moveLegacyTables,\n  migrationProvider as syncMigrationProvider,\n} from \"@/sync-store/postgres/migrations.js\";\nimport {\n  type Checkpoint,\n  decodeCheckpoint,\n  encodeCheckpoint,\n  zeroCheckpoint,\n} from \"@/utils/checkpoint.js\";\nimport { formatEta } from \"@/utils/format.js\";\nimport { hash } from \"@/utils/hash.js\";\nimport { createPool, createReadonlyPool } from \"@/utils/pg.js\";\nimport { wait } from \"@/utils/wait.js\";\nimport {\n  type CreateTableBuilder,\n  type Insertable,\n  type Kysely,\n  type Transaction as KyselyTransaction,\n  Migrator,\n  PostgresDialect,\n  WithSchemaPlugin,\n  sql,\n} from \"kysely\";\nimport type { Pool } from \"pg\";\nimport prometheus from \"prom-client\";\nimport { HeadlessKysely } from \"../kysely.js\";\nimport { revertIndexingTables } from \"../revert.js\";\nimport type { BaseDatabaseService, NamespaceInfo } from \"../service.js\";\nimport { type InternalTables, migrationProvider } from \"./migrations.js\";\n\nexport class PostgresDatabaseService implements BaseDatabaseService {\n  kind = \"postgres\" as const;\n\n  private internalNamespace = \"ponder\";\n\n  private common: Common;\n  private userNamespace: string;\n  private publishSchema?: string | undefined;\n\n  db: HeadlessKysely<InternalTables>;\n  syncDb: HeadlessKysely<SyncStoreTables>;\n  indexingDb: HeadlessKysely<any>;\n  readonlyDb: HeadlessKysely<any>;\n\n  private schema: Schema = null!;\n  private buildId: string = null!;\n  private heartbeatInterval?: NodeJS.Timeout;\n\n  // Only need these for metrics.\n  private internalPool: Pool;\n  private syncPool: Pool;\n  private indexingPool: Pool;\n  readonlyPool: Pool;\n\n  constructor({\n    common,\n    poolConfig,\n    userNamespace,\n    publishSchema,\n    isReadonly = false,\n  }: {\n    common: Common;\n    poolConfig: PoolConfig;\n    userNamespace: string;\n    publishSchema?: string | undefined;\n    isReadonly?: boolean;\n  }) {\n    this.common = common;\n    this.userNamespace = userNamespace;\n    this.publishSchema = publishSchema;\n\n    const internalMax = 2;\n    const equalMax = Math.floor((poolConfig.max - internalMax) / 3);\n    const [readonlyMax, indexingMax, syncMax] = isReadonly\n      ? [poolConfig.max - internalMax, 0, 0]\n      : [equalMax, equalMax, equalMax];\n\n    this.internalPool = createPool({\n      ...poolConfig,\n      application_name: `${userNamespace}_internal`,\n      max: internalMax,\n      statement_timeout: 10 * 60 * 1000, // 10 minutes to accommodate slow sync store migrations.\n    });\n    this.syncPool = createPool({\n      ...poolConfig,\n      application_name: `${userNamespace}_sync`,\n      max: readonlyMax,\n    });\n    this.indexingPool = createPool({\n      ...poolConfig,\n      application_name: `${userNamespace}_indexing`,\n      max: indexingMax,\n    });\n    this.readonlyPool = createReadonlyPool({\n      ...poolConfig,\n      application_name: `${userNamespace}_readonly`,\n      max: syncMax,\n    });\n\n    this.db = new HeadlessKysely<InternalTables>({\n      name: \"internal\",\n      common,\n      dialect: new PostgresDialect({ pool: this.internalPool }),\n      log(event) {\n        if (event.level === \"query\") {\n          common.metrics.ponder_postgres_query_total.inc({ pool: \"internal\" });\n        }\n      },\n    });\n\n    this.syncDb = new HeadlessKysely<SyncStoreTables>({\n      name: \"sync\",\n      common,\n      dialect: new PostgresDialect({ pool: this.syncPool }),\n      log(event) {\n        if (event.level === \"query\") {\n          common.metrics.ponder_postgres_query_total.inc({ pool: \"sync\" });\n        }\n      },\n      plugins: [new WithSchemaPlugin(\"ponder_sync\")],\n    });\n\n    this.indexingDb = new HeadlessKysely<InternalTables>({\n      name: \"indexing\",\n      common,\n      dialect: new PostgresDialect({ pool: this.indexingPool }),\n      log(event) {\n        if (event.level === \"query\") {\n          common.metrics.ponder_postgres_query_total.inc({ pool: \"indexing\" });\n        }\n      },\n    });\n\n    this.readonlyDb = new HeadlessKysely<InternalTables>({\n      name: \"readonly\",\n      common,\n      dialect: new PostgresDialect({ pool: this.readonlyPool }),\n      log(event) {\n        if (event.level === \"query\") {\n          common.metrics.ponder_postgres_query_total.inc({ pool: \"readonly\" });\n        }\n      },\n    });\n\n    this.registerMetrics();\n  }\n\n  async setup({ schema, buildId }: { schema: Schema; buildId: string }) {\n    this.schema = schema;\n    this.buildId = buildId;\n\n    await this.db.schema\n      .createSchema(this.userNamespace)\n      .ifNotExists()\n      .execute();\n    await this.db.schema\n      .createSchema(this.internalNamespace)\n      .ifNotExists()\n      .execute();\n\n    const migrator = new Migrator({\n      db: this.db.withPlugin(new WithSchemaPlugin(this.internalNamespace)),\n      provider: migrationProvider,\n      migrationTableSchema: this.internalNamespace,\n    });\n    const result = await migrator.migrateToLatest();\n\n    if (result.error) throw result.error;\n\n    const namespaceInfo = {\n      userNamespace: this.userNamespace,\n      internalNamespace: this.internalNamespace,\n      internalTableIds: Object.keys(getTables(schema)).reduce(\n        (acc, tableName) => {\n          acc[tableName] = hash([this.userNamespace, this.buildId, tableName]);\n          return acc;\n        },\n        {} as { [tableName: string]: string },\n      ),\n    } satisfies NamespaceInfo;\n\n    return this.db.wrap({ method: \"setup\" }, async () => {\n      const attemptSetup = async () => {\n        return await this.db.transaction().execute(async (tx) => {\n          const previousLockRow = await tx\n            .withSchema(this.internalNamespace)\n            .selectFrom(\"namespace_lock\")\n            .selectAll()\n            .where(\"namespace\", \"=\", this.userNamespace)\n            .executeTakeFirst();\n\n          const newLockRow = {\n            namespace: this.userNamespace,\n            is_locked: 1,\n            heartbeat_at: Date.now(),\n            build_id: this.buildId,\n            finalized_checkpoint: encodeCheckpoint(zeroCheckpoint),\n            // Schema is encoded to be backwards compatible with old versions.\n            // `schema` should have to properties \"tables\" and \"enums\".\n            schema: encodeSchema(schema),\n          } satisfies Insertable<InternalTables[\"namespace_lock\"]>;\n\n          // Function to create the operation log tables and user tables.\n          const createTables = async () => {\n            for (const [tableName, table] of Object.entries(\n              getTables(schema),\n            )) {\n              const tableId = namespaceInfo.internalTableIds[tableName]!;\n\n              await tx.schema\n                .withSchema(this.internalNamespace)\n                .createTable(tableId)\n                .$call((builder) =>\n                  this.buildOperationLogColumns(builder, table.table),\n                )\n                .execute();\n\n              await tx.schema\n                .withSchema(this.internalNamespace)\n                .createIndex(`${tableId}_checkpointIndex`)\n                .on(tableId)\n                .column(\"checkpoint\")\n                .execute();\n\n              try {\n                await tx.schema\n                  .withSchema(this.userNamespace)\n                  .createTable(tableName)\n                  .$call((builder) =>\n                    this.buildColumns(builder, schema, table.table),\n                  )\n                  .execute();\n              } catch (err) {\n                const error = err as Error;\n                if (!error.message.includes(\"already exists\")) throw error;\n                throw new NonRetryableError(\n                  `Unable to create table '${this.userNamespace}'.'${tableName}' because a table with that name already exists. Is there another application using the '${this.userNamespace}' database schema?`,\n                );\n              }\n\n              this.common.logger.info({\n                service: \"database\",\n                msg: `Created table '${this.userNamespace}'.'${tableName}'`,\n              });\n            }\n          };\n\n          // Create ponder_metadata table if it doesn't exist\n          await tx.schema\n            .withSchema(this.userNamespace)\n            .createTable(\"_ponder_meta\")\n            .addColumn(\"key\", \"text\", (col) => col.primaryKey())\n            .addColumn(\"value\", \"jsonb\")\n            .ifNotExists()\n            .execute();\n\n          // Create or set status to null\n          await tx\n            .withSchema(this.userNamespace)\n            // @ts-expect-error Kysely doesn't have types for user schema\n            .insertInto(\"_ponder_meta\")\n            // @ts-expect-error Kysely doesn't have types for user schema\n            .values({ key: \"status\", value: null })\n            // @ts-expect-error Kysely doesn't have types for user schema\n            .onConflict((oc) => oc.column(\"key\").doUpdateSet({ value: null }))\n            .execute();\n\n          // If no lock row is found for this namespace, we can acquire the lock.\n          if (previousLockRow === undefined) {\n            await tx\n              .withSchema(this.internalNamespace)\n              .insertInto(\"namespace_lock\")\n              .values(newLockRow)\n              .execute();\n            this.common.logger.debug({\n              service: \"database\",\n              msg: `Acquired lock on new schema '${this.userNamespace}'`,\n            });\n\n            await createTables();\n\n            return { status: \"success\", checkpoint: zeroCheckpoint } as const;\n          }\n\n          // If the lock row is held and has not expired, we cannot proceed.\n          const expiresAt =\n            previousLockRow.heartbeat_at +\n            this.common.options.databaseHeartbeatTimeout;\n\n          if (previousLockRow.is_locked === 1 && Date.now() <= expiresAt) {\n            const expiresInMs = expiresAt - Date.now();\n            return { status: \"locked\", expiresInMs } as const;\n          }\n\n          // If the lock row has the same build ID as the current app AND\n          // has a non-zero finalized checkpoint, we can revert unfinalized\n          // rows and continue where it left off.\n          if (\n            this.common.options.command === \"start\" &&\n            previousLockRow.build_id === this.buildId &&\n            previousLockRow.finalized_checkpoint !==\n              encodeCheckpoint(zeroCheckpoint)\n          ) {\n            this.common.logger.info({\n              service: \"database\",\n              msg: `Detected cache hit for build '${this.buildId}' in schema '${\n                this.userNamespace\n              }' last active ${formatEta(Date.now() - previousLockRow.heartbeat_at)} ago`,\n            });\n\n            // Remove any indexes, will be recreated once the app\n            // becomes healthy.\n            for (const [tableName, table] of Object.entries(\n              getTables(schema),\n            )) {\n              if (table.constraints === undefined) continue;\n\n              for (const name of Object.keys(table.constraints)) {\n                await tx.schema\n                  .withSchema(this.userNamespace)\n                  .dropIndex(`${tableName}_${name}`)\n                  .ifExists()\n                  .execute();\n\n                this.common.logger.info({\n                  service: \"database\",\n                  msg: `Dropped index '${tableName}_${name}' in schema '${this.userNamespace}'`,\n                });\n              }\n            }\n\n            await tx\n              .withSchema(this.internalNamespace)\n              .updateTable(\"namespace_lock\")\n              .set({ is_locked: 1, heartbeat_at: Date.now() })\n              .execute();\n            this.common.logger.debug({\n              service: \"database\",\n              msg: `Acquired lock on schema '${this.userNamespace}'`,\n            });\n\n            const finalizedCheckpoint = decodeCheckpoint(\n              previousLockRow.finalized_checkpoint,\n            );\n\n            this.common.logger.info({\n              service: \"database\",\n              msg: `Reverting operations prior to finalized checkpoint (timestamp=${finalizedCheckpoint.blockTimestamp} chainId=${finalizedCheckpoint.chainId} block=${finalizedCheckpoint.blockNumber})`,\n            });\n\n            // Revert unfinalized data from the existing tables.\n            const tx_ = tx as KyselyTransaction<any>;\n            for (const [tableName, tableId] of Object.entries(\n              namespaceInfo.internalTableIds,\n            )) {\n              const rows = await tx_\n                .withSchema(namespaceInfo.internalNamespace)\n                .deleteFrom(tableId)\n                .returningAll()\n                .where(\"checkpoint\", \">\", previousLockRow.finalized_checkpoint)\n                .execute();\n\n              const reversed = rows.sort(\n                (a, b) => b.operation_id - a.operation_id,\n              );\n\n              for (const log of reversed) {\n                if (log.operation === 0) {\n                  // Create\n                  await tx_\n                    .withSchema(namespaceInfo.userNamespace)\n                    .deleteFrom(tableName)\n                    .where(\"id\", \"=\", log.id)\n                    .execute();\n                } else if (log.operation === 1) {\n                  // Update\n                  log.operation_id = undefined;\n                  log.checkpoint = undefined;\n                  log.operation = undefined;\n                  await tx_\n                    .withSchema(namespaceInfo.userNamespace)\n                    .updateTable(tableName)\n                    .set(log)\n                    .where(\"id\", \"=\", log.id)\n                    .execute();\n                } else {\n                  // Delete\n                  log.operation_id = undefined;\n                  log.checkpoint = undefined;\n                  log.operation = undefined;\n                  await tx_\n                    .withSchema(namespaceInfo.userNamespace)\n                    .insertInto(tableName)\n                    .values(log)\n                    .execute();\n                }\n              }\n\n              this.common.logger.info({\n                service: \"database\",\n                msg: `Reverted ${rows.length} unfinalized operations from existing '${tableName}' table`,\n              });\n            }\n\n            return {\n              status: \"success\",\n              checkpoint: finalizedCheckpoint,\n            } as const;\n          }\n\n          // Otherwise, the lock row has a different build ID or a zero finalized checkpoint,\n          // so we need to drop the previous app's tables and create new ones.\n          const previousBuildId = previousLockRow.build_id;\n          // Note: `previousSchema` should only be used to get table names or enum names because\n          // the types of `Table` and `Enum` have changed between versions.\n          const previousSchema = previousLockRow.schema as unknown as {\n            tables: { [tableName: string]: Table };\n            enums: { [enumName: string]: Enum };\n          };\n\n          await tx\n            .withSchema(this.internalNamespace)\n            .updateTable(\"namespace_lock\")\n            .where(\"namespace\", \"=\", this.userNamespace)\n            .set(newLockRow)\n            .execute();\n\n          this.common.logger.debug({\n            service: \"database\",\n            msg: `Acquired lock on schema '${this.userNamespace}' previously used by build '${previousBuildId}'`,\n          });\n\n          for (const tableName of Object.keys(previousSchema.tables)) {\n            const tableId = hash([\n              this.userNamespace,\n              previousBuildId,\n              tableName,\n            ]);\n\n            await tx.schema\n              .withSchema(this.internalNamespace)\n              .dropTable(tableId)\n              .ifExists()\n              .execute();\n\n            await tx.schema\n              .withSchema(this.userNamespace)\n              .dropTable(tableName)\n              .cascade() // Need cascade here to drop dependent published views.\n              .ifExists()\n              .execute();\n\n            this.common.logger.debug({\n              service: \"database\",\n              msg: `Dropped '${tableName}' table left by previous build`,\n            });\n          }\n\n          await createTables();\n\n          return { status: \"success\", checkpoint: zeroCheckpoint } as const;\n        });\n      };\n\n      const result = await attemptSetup();\n\n      let finalizedCheckpoint: Checkpoint;\n\n      if (result.status === \"success\") {\n        finalizedCheckpoint = result.checkpoint;\n      } else {\n        // If the namespace is locked, attempt one more time after waiting the timeout.\n        const { expiresInMs } = result;\n        this.common.logger.warn({\n          service: \"database\",\n          msg: `Schema '${this.userNamespace}' is locked by a different Ponder app`,\n        });\n        this.common.logger.warn({\n          service: \"database\",\n          msg: `Waiting ${formatEta(expiresInMs)} for lock on schema '${\n            this.userNamespace\n          }' to expire...`,\n        });\n\n        await wait(expiresInMs);\n\n        const resultTwo = await attemptSetup();\n        if (resultTwo.status === \"locked\") {\n          throw new NonRetryableError(\n            `Failed to acquire lock on schema '${this.userNamespace}'. A different Ponder app is actively using this schema.`,\n          );\n        }\n        finalizedCheckpoint = resultTwo.checkpoint;\n      }\n\n      // Start the heartbeat interval to hold the lock for as long as the process is running.\n      this.heartbeatInterval = setInterval(async () => {\n        try {\n          const lockRow = await this.db\n            .withSchema(this.internalNamespace)\n            .updateTable(\"namespace_lock\")\n            .where(\"namespace\", \"=\", this.userNamespace)\n            .set({ heartbeat_at: Date.now() })\n            .returningAll()\n            .executeTakeFirst();\n\n          this.common.logger.debug({\n            service: \"database\",\n            msg: `Updated heartbeat timestamp to ${lockRow?.heartbeat_at} for current build '${this.buildId}'`,\n          });\n        } catch (err) {\n          const error = err as Error;\n          this.common.logger.error({\n            service: \"database\",\n            msg: `Failed to update heartbeat timestamp, retrying in ${formatEta(\n              this.common.options.databaseHeartbeatInterval,\n            )}`,\n            error,\n          });\n        }\n      }, this.common.options.databaseHeartbeatInterval);\n\n      return { checkpoint: finalizedCheckpoint, namespaceInfo };\n    });\n  }\n\n  async revert({\n    checkpoint,\n    namespaceInfo,\n  }: {\n    checkpoint: Checkpoint;\n    namespaceInfo: NamespaceInfo;\n  }) {\n    await revertIndexingTables({\n      db: this.indexingDb,\n      checkpoint,\n      namespaceInfo,\n    });\n  }\n\n  async updateFinalizedCheckpoint({\n    checkpoint,\n  }: { checkpoint: Checkpoint }): Promise<void> {\n    await this.db.wrap({ method: \"updateFinalizedCheckpoint\" }, async () => {\n      await this.db\n        .withSchema(this.internalNamespace)\n        .updateTable(\"namespace_lock\")\n        .where(\"namespace\", \"=\", this.userNamespace)\n        .set({ finalized_checkpoint: encodeCheckpoint(checkpoint) })\n        .execute();\n\n      this.common.logger.debug({\n        service: \"database\",\n        msg: `Updated finalized checkpoint to (timestamp=${checkpoint.blockTimestamp} chainId=${checkpoint.chainId} block=${checkpoint.blockNumber})`,\n      });\n    });\n  }\n\n  async publish() {\n    await this.db.wrap({ method: \"publish\" }, async () => {\n      const publishSchema = this.publishSchema;\n      if (publishSchema === undefined) {\n        this.common.logger.debug({\n          service: \"database\",\n          msg: \"Not publishing views, publish schema was not defined\",\n        });\n        return;\n      }\n\n      await this.db.transaction().execute(async (tx) => {\n        // Create the publish schema if it doesn't exist.\n        await tx.schema.createSchema(publishSchema).ifNotExists().execute();\n\n        for (const tableName of Object.keys(getTables(this.schema)).concat(\n          \"_ponder_meta\",\n        )) {\n          // Check if there is an existing relation with the name we're about to publish.\n          const result = await tx.executeQuery<{\n            table_type: string;\n          }>(\n            sql`\n              SELECT table_type\n              FROM information_schema.tables\n              WHERE table_schema = '${sql.raw(publishSchema)}'\n              AND table_name = '${sql.raw(tableName)}'\n            `.compile(tx),\n          );\n\n          const isTable = result.rows[0]?.table_type === \"BASE TABLE\";\n          if (isTable) {\n            this.common.logger.warn({\n              service: \"database\",\n              msg: `Unable to publish view '${publishSchema}'.'${tableName}' because a table with that name already exists`,\n            });\n            continue;\n          }\n\n          const isView = result.rows[0]?.table_type === \"VIEW\";\n          if (isView) {\n            await tx.schema\n              .withSchema(publishSchema)\n              .dropView(tableName)\n              .ifExists()\n              .cascade()\n              .execute();\n\n            this.common.logger.debug({\n              service: \"database\",\n              msg: `Dropped existing view '${publishSchema}'.'${tableName}'`,\n            });\n          }\n\n          await tx.schema\n            .withSchema(publishSchema)\n            .createView(tableName)\n            .as(\n              (tx as Kysely<any>)\n                .withSchema(this.userNamespace)\n                .selectFrom(tableName)\n                .selectAll(),\n            )\n            .execute();\n\n          this.common.logger.info({\n            service: \"database\",\n            msg: `Created view '${publishSchema}'.'${tableName}' serving data from '${this.userNamespace}'.'${tableName}'`,\n          });\n        }\n      });\n    });\n  }\n\n  async createIndexes({ schema }: { schema: Schema }) {\n    await Promise.all(\n      Object.entries(getTables(schema)).flatMap(([tableName, table]) => {\n        if (table.constraints === undefined) return [];\n\n        return Object.entries(table.constraints).map(async ([name, index]) => {\n          await this.db.wrap({ method: \"createIndexes\" }, async () => {\n            const indexName = `${tableName}_${name}`;\n\n            const indexColumn = index[\" column\"];\n            const order = index[\" order\"];\n            const nulls = index[\" nulls\"];\n\n            const columns = Array.isArray(indexColumn)\n              ? indexColumn.map((ic) => `\"${ic}\"`).join(\", \")\n              : `\"${indexColumn}\" ${order === \"asc\" ? \"ASC\" : order === \"desc\" ? \"DESC\" : \"\"} ${\n                  nulls === \"first\"\n                    ? \"NULLS FIRST\"\n                    : nulls === \"last\"\n                      ? \"NULLS LAST\"\n                      : \"\"\n                }`;\n\n            await this.db.executeQuery(\n              sql`CREATE INDEX ${sql.ref(indexName)} ON ${sql.table(\n                `${this.userNamespace}.${tableName}`,\n              )} (${sql.raw(columns)})`.compile(this.db),\n            );\n          });\n\n          this.common.logger.info({\n            service: \"database\",\n            msg: `Created index '${tableName}_${name}' on columns (${\n              Array.isArray(index[\" column\"])\n                ? index[\" column\"].join(\", \")\n                : index[\" column\"]\n            }) in schema '${this.userNamespace}'`,\n          });\n        });\n      }),\n    );\n  }\n\n  async kill() {\n    await this.db.wrap({ method: \"kill\" }, async () => {\n      clearInterval(this.heartbeatInterval);\n\n      await this.db\n        .withSchema(this.internalNamespace)\n        .updateTable(\"namespace_lock\")\n        .where(\"namespace\", \"=\", this.userNamespace)\n        .set({ is_locked: 0 })\n        .returningAll()\n        .executeTakeFirst();\n\n      this.common.logger.debug({\n        service: \"database\",\n        msg: `Released lock on namespace '${this.userNamespace}'`,\n      });\n\n      await this.readonlyDb.destroy();\n      await this.indexingDb.destroy();\n      await this.syncDb.destroy();\n      await this.db.destroy();\n\n      await this.readonlyPool.end();\n      await this.indexingPool.end();\n      await this.syncPool.end();\n      await this.internalPool.end();\n\n      this.common.logger.debug({\n        service: \"database\",\n        msg: \"Closed database connection pools\",\n      });\n    });\n  }\n\n  async migrateSyncStore() {\n    await this.db.wrap({ method: \"migrateSyncStore\" }, async () => {\n      // TODO: Probably remove this at 1.0 to speed up startup time.\n      await moveLegacyTables({\n        common: this.common,\n        db: this.db as Kysely<any>,\n        newSchemaName: \"ponder_sync\",\n      });\n\n      const migrator = new Migrator({\n        db: this.db.withPlugin(new WithSchemaPlugin(\"ponder_sync\")),\n        provider: syncMigrationProvider,\n        migrationTableSchema: \"ponder_sync\",\n      });\n\n      const { error } = await migrator.migrateToLatest();\n      if (error) throw error;\n    });\n  }\n\n  private buildColumns<T extends string, C extends string = never>(\n    builder: CreateTableBuilder<T, C>,\n    schema: Schema,\n    table: Table,\n  ) {\n    Object.entries(table).forEach(([columnName, column]) => {\n      if (isOneColumn(column)) return;\n      if (isManyColumn(column)) return;\n      if (isEnumColumn(column)) {\n        // Handle enum types\n        builder = builder.addColumn(columnName, \"text\", (col) => {\n          if (isOptionalColumn(column) === false) col = col.notNull();\n          if (isListColumn(column) === false) {\n            col = col.check(\n              sql`${sql.ref(columnName)} in (${sql.join(\n                getEnums(schema)[column[\" enum\"]]!.map((v) => sql.lit(v)),\n              )})`,\n            );\n          }\n          return col;\n        });\n      } else if (isListColumn(column)) {\n        // Handle scalar list table\n        builder = builder.addColumn(columnName, \"text\", (col) => {\n          if (isOptionalColumn(column) === false) col = col.notNull();\n          return col;\n        });\n      } else if (isJSONColumn(column)) {\n        // Handle json columns\n        builder = builder.addColumn(columnName, \"jsonb\", (col) => {\n          if (isOptionalColumn(column) === false) col = col.notNull();\n          return col;\n        });\n      } else {\n        // Non-list base columns\n        builder = builder.addColumn(\n          columnName,\n          scalarToSqlType[column[\" scalar\"]],\n          (col) => {\n            if (isOptionalColumn(column) === false) col = col.notNull();\n            if (columnName === \"id\") col = col.primaryKey();\n            return col;\n          },\n        );\n      }\n    });\n\n    return builder;\n  }\n\n  private buildOperationLogColumns<T extends string, C extends string = never>(\n    builder: CreateTableBuilder<T, C>,\n    table: Table,\n  ) {\n    Object.entries(table).forEach(([columnName, column]) => {\n      if (isOneColumn(column)) return;\n      if (isManyColumn(column)) return;\n      if (isEnumColumn(column)) {\n        // Handle enum types\n        // Omit the CHECK constraint because its included in the user table\n        builder = builder.addColumn(columnName, \"text\");\n      } else if (isListColumn(column)) {\n        // Handle scalar list columns\n        builder = builder.addColumn(columnName, \"text\");\n      } else if (isJSONColumn(column)) {\n        // Handle json columns\n        builder = builder.addColumn(columnName, \"jsonb\");\n      } else {\n        // Non-list base columns\n        builder = builder.addColumn(\n          columnName,\n          scalarToSqlType[column[\" scalar\"]],\n          (col) => {\n            if (columnName === \"id\") col = col.notNull();\n            return col;\n          },\n        );\n      }\n    });\n\n    builder = builder\n      .addColumn(\"operation_id\", \"serial\", (col) => col.notNull().primaryKey())\n      .addColumn(\"checkpoint\", \"varchar(75)\", (col) => col.notNull())\n      .addColumn(\"operation\", \"integer\", (col) => col.notNull());\n\n    return builder;\n  }\n\n  private registerMetrics() {\n    const service = this;\n\n    this.common.metrics.registry.removeSingleMetric(\n      \"ponder_postgres_query_total\",\n    );\n    this.common.metrics.ponder_postgres_query_total = new prometheus.Counter({\n      name: \"ponder_postgres_query_total\",\n      help: \"Total number of queries submitted to the database\",\n      labelNames: [\"pool\"] as const,\n      registers: [this.common.metrics.registry],\n    });\n\n    this.common.metrics.registry.removeSingleMetric(\n      \"ponder_postgres_pool_connections\",\n    );\n    this.common.metrics.ponder_postgres_pool_connections = new prometheus.Gauge(\n      {\n        name: \"ponder_postgres_pool_connections\",\n        help: \"Number of connections in the pool\",\n        labelNames: [\"pool\", \"kind\"] as const,\n        registers: [this.common.metrics.registry],\n        collect() {\n          this.set(\n            { pool: \"internal\", kind: \"idle\" },\n            service.internalPool.idleCount,\n          );\n          this.set(\n            { pool: \"internal\", kind: \"total\" },\n            service.internalPool.totalCount,\n          );\n\n          this.set({ pool: \"sync\", kind: \"idle\" }, service.syncPool.idleCount);\n          this.set(\n            { pool: \"sync\", kind: \"total\" },\n            service.syncPool.totalCount,\n          );\n\n          this.set(\n            { pool: \"indexing\", kind: \"idle\" },\n            service.indexingPool.idleCount,\n          );\n          this.set(\n            { pool: \"indexing\", kind: \"total\" },\n            service.indexingPool.totalCount,\n          );\n\n          this.set(\n            { pool: \"readonly\", kind: \"idle\" },\n            service.readonlyPool.idleCount,\n          );\n          this.set(\n            { pool: \"readonly\", kind: \"total\" },\n            service.readonlyPool.totalCount,\n          );\n        },\n      },\n    );\n\n    this.common.metrics.registry.removeSingleMetric(\n      \"ponder_postgres_query_queue_size\",\n    );\n    this.common.metrics.ponder_postgres_query_queue_size = new prometheus.Gauge(\n      {\n        name: \"ponder_postgres_query_queue_size\",\n        help: \"Number of query requests waiting for an available connection\",\n        labelNames: [\"pool\"] as const,\n        registers: [this.common.metrics.registry],\n        collect() {\n          this.set({ pool: \"internal\" }, service.internalPool.waitingCount);\n          this.set({ pool: \"sync\" }, service.syncPool.waitingCount);\n          this.set({ pool: \"indexing\" }, service.indexingPool.waitingCount);\n          this.set({ pool: \"readonly\" }, service.readonlyPool.waitingCount);\n        },\n      },\n    );\n  }\n}\n\nconst scalarToSqlType = {\n  boolean: \"integer\",\n  int: \"integer\",\n  float: \"float8\",\n  string: \"text\",\n  bigint: \"numeric(78, 0)\",\n  hex: \"bytea\",\n} as const;\n","import type { Common } from \"@/common/common.js\";\nimport { IgnorableError, NonRetryableError } from \"@/common/errors.js\";\nimport { startClock } from \"@/utils/timer.js\";\nimport { wait } from \"@/utils/wait.js\";\nimport { Kysely, type KyselyConfig, type KyselyProps } from \"kysely\";\n\nconst RETRY_COUNT = 9;\nconst BASE_DURATION = 125;\n\nexport class HeadlessKysely<DB> extends Kysely<DB> {\n  private common: Common;\n  private name: string;\n  private isKilled = false;\n\n  constructor({\n    common,\n    name,\n    ...args\n  }: (KyselyConfig | KyselyProps) & { name: string; common: Common }) {\n    super(args);\n    this.common = common;\n    this.name = name;\n  }\n\n  override async destroy() {\n    this.isKilled = true;\n  }\n\n  wrap = async <T>(\n    options: { method: string },\n    fn: () => Promise<T>,\n    // TypeScript can't infer that we always return or throw.\n    // @ts-ignore\n  ): Promise<T> => {\n    // First error thrown is often the most useful\n    let firstError: any;\n    let hasError = false;\n\n    for (let i = 0; i <= RETRY_COUNT; i++) {\n      const endClock = startClock();\n      try {\n        const result = await fn();\n        this.common.metrics.ponder_database_method_duration.observe(\n          { service: this.name, method: options.method },\n          endClock(),\n        );\n        return result;\n      } catch (_error) {\n        const error = _error as Error;\n\n        this.common.metrics.ponder_database_method_duration.observe(\n          { service: this.name, method: options.method },\n          endClock(),\n        );\n        this.common.metrics.ponder_database_method_error_total.inc({\n          service: this.name,\n          method: options.method,\n        });\n\n        if (this.isKilled) {\n          this.common.logger.trace({\n            service: this.name,\n            msg: `Ignored error during '${options.method}' database method (service is killed)`,\n          });\n          throw new IgnorableError();\n        }\n\n        if (!hasError) {\n          hasError = true;\n          firstError = error;\n        }\n\n        if (error instanceof NonRetryableError) {\n          this.common.logger.warn({\n            service: this.name,\n            msg: `Failed '${options.method}' database method `,\n          });\n          throw error;\n        }\n\n        if (i === RETRY_COUNT) {\n          this.common.logger.warn({\n            service: this.name,\n            msg: `Failed '${options.method}' database method after '${i + 1}' attempts`,\n            error,\n          });\n          throw firstError;\n        }\n\n        const duration = BASE_DURATION * 2 ** i;\n        this.common.logger.debug({\n          service: this.name,\n          msg: `Failed '${options.method}' database method, retrying after ${duration} milliseconds`,\n          error,\n        });\n        await wait(duration);\n      }\n    }\n  };\n}\n","import { type Checkpoint, encodeCheckpoint } from \"@/utils/checkpoint.js\";\nimport type { HeadlessKysely } from \"./kysely.js\";\nimport type { NamespaceInfo } from \"./service.js\";\n\nexport const revertIndexingTables = async ({\n  checkpoint,\n  namespaceInfo,\n  db,\n}: {\n  namespaceInfo: NamespaceInfo;\n  db: HeadlessKysely<any>;\n  checkpoint: Checkpoint;\n}) => {\n  await db.wrap({ method: \"revert\" }, async () => {\n    const encodedCheckpoint = encodeCheckpoint(checkpoint);\n\n    await Promise.all(\n      Object.entries(namespaceInfo.internalTableIds).map(\n        async ([tableName, tableId]) => {\n          await db.transaction().execute(async (tx) => {\n            const rows = await tx\n              .withSchema(namespaceInfo.internalNamespace)\n              .deleteFrom(tableId)\n              .returningAll()\n              .where(\"checkpoint\", \">\", encodedCheckpoint)\n              .execute();\n\n            const reversed = rows.sort(\n              (a, b) => b.operation_id - a.operation_id,\n            );\n\n            // undo operation\n            for (const log of reversed) {\n              if (log.operation === 0) {\n                // create\n                await tx\n                  .withSchema(namespaceInfo.userNamespace)\n                  .deleteFrom(tableName)\n                  .where(\"id\", \"=\", log.id)\n                  .execute();\n              } else if (log.operation === 1) {\n                // update\n                log.operation_id = undefined;\n                log.checkpoint = undefined;\n                log.operation = undefined;\n\n                await tx\n                  .withSchema(namespaceInfo.userNamespace)\n                  .updateTable(tableName)\n                  .set(log)\n                  .where(\"id\", \"=\", log.id)\n                  .execute();\n              } else {\n                // delete\n                log.operation_id = undefined;\n                log.checkpoint = undefined;\n                log.operation = undefined;\n\n                await tx\n                  .withSchema(namespaceInfo.userNamespace)\n                  .insertInto(tableName)\n                  .values(log)\n                  .execute();\n              }\n            }\n          });\n        },\n      ),\n    );\n  });\n};\n","import type { Kysely } from \"kysely\";\nimport type { Migration, MigrationProvider } from \"kysely\";\n\nconst migrations: Record<string, Migration> = {\n  \"2024_03_28_0_initial\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createTable(\"namespace_lock\")\n        .ifNotExists()\n        .addColumn(\"namespace\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"is_locked\", \"integer\", (col) => col.notNull())\n        .addColumn(\"heartbeat_at\", \"bigint\", (col) => col.notNull())\n        .addColumn(\"build_id\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized_checkpoint\", \"varchar(75)\", (col) =>\n          col.notNull(),\n        )\n        .addColumn(\"schema\", \"jsonb\", (col) => col.notNull())\n        .execute();\n    },\n  },\n};\n\nclass StaticMigrationProvider implements MigrationProvider {\n  async getMigrations() {\n    return migrations;\n  }\n}\n\nexport const migrationProvider = new StaticMigrationProvider();\n\nexport type InternalTables = {\n  namespace_lock: {\n    namespace: string;\n    is_locked: number;\n    heartbeat_at: number;\n    build_id: string;\n    finalized_checkpoint: string;\n    schema: string;\n  };\n};\n","import { existsSync, rmSync } from \"node:fs\";\nimport path from \"node:path\";\nimport type { Common } from \"@/common/common.js\";\nimport { NonRetryableError } from \"@/common/errors.js\";\nimport type { Enum, Schema, Table } from \"@/schema/common.js\";\nimport {\n  encodeSchema,\n  getEnums,\n  getTables,\n  isEnumColumn,\n  isJSONColumn,\n  isListColumn,\n  isManyColumn,\n  isOneColumn,\n  isOptionalColumn,\n} from \"@/schema/utils.js\";\nimport type { SyncStoreTables } from \"@/sync-store/sqlite/encoding.js\";\nimport { migrationProvider as syncMigrationProvider } from \"@/sync-store/sqlite/migrations.js\";\nimport {\n  type Checkpoint,\n  decodeCheckpoint,\n  encodeCheckpoint,\n  zeroCheckpoint,\n} from \"@/utils/checkpoint.js\";\nimport { formatEta } from \"@/utils/format.js\";\nimport { hash } from \"@/utils/hash.js\";\nimport {\n  type SqliteDatabase,\n  createReadonlySqliteDatabase,\n  createSqliteDatabase,\n} from \"@/utils/sqlite.js\";\nimport { wait } from \"@/utils/wait.js\";\nimport {\n  type CreateTableBuilder,\n  type Insertable,\n  type Kysely,\n  type Transaction as KyselyTransaction,\n  Migrator,\n  SqliteDialect,\n  WithSchemaPlugin,\n  sql,\n} from \"kysely\";\nimport prometheus from \"prom-client\";\nimport { HeadlessKysely } from \"../kysely.js\";\nimport { revertIndexingTables } from \"../revert.js\";\nimport type { BaseDatabaseService, NamespaceInfo } from \"../service.js\";\nimport { type InternalTables, migrationProvider } from \"./migrations.js\";\n\nexport class SqliteDatabaseService implements BaseDatabaseService {\n  kind = \"sqlite\" as const;\n\n  private common: Common;\n  private directory: string;\n\n  private userNamespace: string;\n  private internalNamespace: string;\n\n  private internalDatabase: SqliteDatabase;\n  private syncDatabase: SqliteDatabase;\n  readonlyDatabase: SqliteDatabase;\n\n  db: HeadlessKysely<InternalTables>;\n  readonlyDb: HeadlessKysely<any>;\n  indexingDb: HeadlessKysely<any>;\n  syncDb: HeadlessKysely<SyncStoreTables>;\n\n  private buildId: string = null!;\n  private heartbeatInterval?: NodeJS.Timeout;\n\n  constructor({\n    common,\n    directory,\n    userNamespace = \"public\",\n  }: {\n    common: Common;\n    directory: string;\n    userNamespace?: string;\n  }) {\n    this.common = common;\n    this.directory = directory;\n\n    this.deleteV3DatabaseFiles();\n\n    this.userNamespace = userNamespace;\n    const userDatabaseFile = path.join(directory, `${userNamespace}.db`);\n\n    // Note that SQLite supports using \"main\" as the schema name for tables\n    // in the primary database (as opposed to attached databases). We include\n    // it here to more closely match Postgres, where it's required.\n    // https://www.sqlite.org/lang_attach.html\n    this.internalNamespace = \"main\";\n    const internalDatabaseFile = path.join(directory, \"ponder.db\");\n\n    this.internalDatabase = createSqliteDatabase(internalDatabaseFile);\n    this.internalDatabase.exec(\n      `ATTACH DATABASE '${userDatabaseFile}' AS ${this.userNamespace}`,\n    );\n\n    this.readonlyDatabase = createReadonlySqliteDatabase(internalDatabaseFile);\n    this.readonlyDatabase.exec(\n      `ATTACH DATABASE '${userDatabaseFile}' AS ${this.userNamespace}`,\n    );\n\n    this.db = new HeadlessKysely<InternalTables>({\n      name: \"internal\",\n      common,\n      dialect: new SqliteDialect({ database: this.internalDatabase }),\n      log(event) {\n        if (event.level === \"query\") {\n          common.metrics.ponder_sqlite_query_total.inc({\n            database: \"internal\",\n          });\n        }\n      },\n    });\n\n    const syncDatabaseFile = path.join(directory, \"ponder_sync.db\");\n    this.syncDatabase = createSqliteDatabase(syncDatabaseFile);\n    this.syncDb = new HeadlessKysely<SyncStoreTables>({\n      name: \"sync\",\n      common,\n      dialect: new SqliteDialect({ database: this.syncDatabase }),\n      log(event) {\n        if (event.level === \"query\") {\n          common.metrics.ponder_sqlite_query_total.inc({ database: \"sync\" });\n        }\n      },\n    });\n\n    this.indexingDb = new HeadlessKysely<InternalTables>({\n      name: \"indexing\",\n      common,\n      dialect: new SqliteDialect({ database: this.internalDatabase }),\n      log(event) {\n        if (event.level === \"query\") {\n          common.metrics.ponder_sqlite_query_total.inc({\n            database: \"indexing\",\n          });\n        }\n      },\n    });\n\n    this.readonlyDb = new HeadlessKysely<InternalTables>({\n      name: \"readonly\",\n      common,\n      dialect: new SqliteDialect({ database: this.readonlyDatabase }),\n      log(event) {\n        if (event.level === \"query\") {\n          common.metrics.ponder_sqlite_query_total.inc({\n            database: \"readonly\",\n          });\n        }\n      },\n    });\n\n    this.registerMetrics();\n  }\n\n  async setup({ schema, buildId }: { schema: Schema; buildId: string }) {\n    this.buildId = buildId;\n\n    const migrator = new Migrator({\n      db: this.db.withPlugin(new WithSchemaPlugin(this.internalNamespace)),\n      provider: migrationProvider,\n    });\n    const result = await migrator.migrateToLatest();\n    if (result.error) throw result.error;\n\n    const namespaceInfo = {\n      userNamespace: this.userNamespace,\n      internalNamespace: this.internalNamespace,\n      internalTableIds: Object.keys(getTables(schema)).reduce(\n        (acc, tableName) => {\n          acc[tableName] = hash([this.userNamespace, this.buildId, tableName]);\n          return acc;\n        },\n        {} as { [tableName: string]: string },\n      ),\n    } satisfies NamespaceInfo;\n\n    return this.db.wrap({ method: \"setup\" }, async () => {\n      const attemptSetup = async () => {\n        return await this.db.transaction().execute(async (tx) => {\n          const previousLockRow = await tx\n            .withSchema(this.internalNamespace)\n            .selectFrom(\"namespace_lock\")\n            .selectAll()\n            .where(\"namespace\", \"=\", this.userNamespace)\n            .executeTakeFirst();\n\n          const newLockRow = {\n            namespace: this.userNamespace,\n            is_locked: 1,\n            heartbeat_at: Date.now(),\n            build_id: this.buildId,\n            finalized_checkpoint: encodeCheckpoint(zeroCheckpoint),\n            // Schema is encoded to be backwards compatible with old versions.\n            // `schema` should have to properties \"tables\" and \"enums\".\n            schema: encodeSchema(schema),\n          } satisfies Insertable<InternalTables[\"namespace_lock\"]>;\n\n          // Function to create the operation log tables and user tables.\n          const createTables = async () => {\n            for (const [tableName, table] of Object.entries(\n              getTables(schema),\n            )) {\n              const tableId = namespaceInfo.internalTableIds[tableName]!;\n\n              await tx.schema\n                .withSchema(this.internalNamespace)\n                .createTable(tableId)\n                .$call((builder) =>\n                  this.buildOperationLogColumns(builder, table.table),\n                )\n                .execute();\n\n              await tx.schema\n                .createIndex(`${tableId}_checkpointIndex`)\n                .on(tableId)\n                .column(\"checkpoint\")\n                .execute();\n\n              try {\n                await tx.schema\n                  .withSchema(this.userNamespace)\n                  .createTable(tableName)\n                  .$call((builder) =>\n                    this.buildColumns(builder, schema, table.table),\n                  )\n                  .execute();\n              } catch (err) {\n                const error = err as Error;\n                if (!error.message.includes(\"already exists\")) throw error;\n                throw new NonRetryableError(\n                  `Unable to create table '${tableName}' in '${this.userNamespace}.db' because a table with that name already exists. Is there another application using the '${this.userNamespace}.db' database file?`,\n                );\n              }\n\n              this.common.logger.info({\n                service: \"database\",\n                msg: `Created table '${tableName}' in '${this.userNamespace}.db'`,\n              });\n            }\n          };\n\n          // Create ponder_metadata table if it doesn't exist\n          await tx.schema\n            .withSchema(this.userNamespace)\n            .createTable(\"_ponder_meta\")\n            .addColumn(\"key\", \"text\", (col) => col.primaryKey())\n            .addColumn(\"value\", \"jsonb\")\n            .ifNotExists()\n            .execute();\n\n          // Create or set status to null\n          await tx\n            .withSchema(this.userNamespace)\n            // @ts-expect-error Kysely doesn't have types for user schema\n            .insertInto(\"_ponder_meta\")\n            // @ts-expect-error Kysely doesn't have types for user schema\n            .values({ key: \"status\", value: null })\n            // @ts-expect-error Kysely doesn't have types for user schema\n            .onConflict((oc) => oc.column(\"key\").doUpdateSet({ value: null }))\n            .execute();\n\n          // If no lock row is found for this namespace, we can acquire the lock.\n          if (previousLockRow === undefined) {\n            await tx\n              .withSchema(this.internalNamespace)\n              .insertInto(\"namespace_lock\")\n              .values(newLockRow)\n              .execute();\n            this.common.logger.debug({\n              service: \"database\",\n              msg: `Acquired lock on database file '${this.userNamespace}.db'`,\n            });\n\n            await createTables();\n\n            return { status: \"success\", checkpoint: zeroCheckpoint } as const;\n          }\n\n          // If the lock row is held and has not expired, we cannot proceed.\n          const expiresAt =\n            previousLockRow.heartbeat_at +\n            this.common.options.databaseHeartbeatTimeout;\n\n          if (previousLockRow.is_locked === 1 && Date.now() <= expiresAt) {\n            const expiresInMs = expiresAt - Date.now();\n            return { status: \"locked\", expiresInMs } as const;\n          }\n\n          // If the lock row has the same build ID as the current app AND\n          // has a non-zero finalized checkpoint, we can revert unfinalized\n          // rows and continue where it left off.\n          if (\n            this.common.options.command === \"start\" &&\n            previousLockRow.build_id === this.buildId &&\n            previousLockRow.finalized_checkpoint !==\n              encodeCheckpoint(zeroCheckpoint)\n          ) {\n            this.common.logger.info({\n              service: \"database\",\n              msg: `Detected cache hit for build '${this.buildId}' in database file '${\n                this.userNamespace\n              }.db' last active ${formatEta(Date.now() - previousLockRow.heartbeat_at)} ago`,\n            });\n\n            // Remove any indexes, will be recreated once the app\n            // becomes healthy.\n            for (const [tableName, table] of Object.entries(\n              getTables(schema),\n            )) {\n              if (table.constraints === undefined) continue;\n\n              for (const name of Object.keys(table.constraints)) {\n                await tx.schema\n                  .withSchema(this.userNamespace)\n                  .dropIndex(`${tableName}_${name}`)\n                  .ifExists()\n                  .execute();\n\n                this.common.logger.info({\n                  service: \"database\",\n                  msg: `Dropped index '${tableName}_${name}' in schema '${this.userNamespace}'`,\n                });\n              }\n            }\n\n            await tx\n              .withSchema(this.internalNamespace)\n              .updateTable(\"namespace_lock\")\n              .set({ is_locked: 1, heartbeat_at: Date.now() })\n              .execute();\n            this.common.logger.debug({\n              service: \"database\",\n              msg: `Acquired lock on schema '${this.userNamespace}'`,\n            });\n\n            const finalizedCheckpoint = decodeCheckpoint(\n              previousLockRow.finalized_checkpoint,\n            );\n\n            this.common.logger.info({\n              service: \"database\",\n              msg: `Reverting operations prior to finalized checkpoint (timestamp=${finalizedCheckpoint.blockTimestamp} chainId=${finalizedCheckpoint.chainId} block=${finalizedCheckpoint.blockNumber})`,\n            });\n\n            // Revert unfinalized data from the existing tables.\n            const tx_ = tx as KyselyTransaction<any>;\n            for (const [tableName, tableId] of Object.entries(\n              namespaceInfo.internalTableIds,\n            )) {\n              const rows = await tx_\n                .withSchema(namespaceInfo.internalNamespace)\n                .deleteFrom(tableId)\n                .returningAll()\n                .where(\"checkpoint\", \">\", previousLockRow.finalized_checkpoint)\n                .execute();\n\n              const reversed = rows.sort(\n                (a, b) => b.operation_id - a.operation_id,\n              );\n\n              for (const log of reversed) {\n                if (log.operation === 0) {\n                  // Create\n                  await tx_\n                    .withSchema(namespaceInfo.userNamespace)\n                    .deleteFrom(tableName)\n                    .where(\"id\", \"=\", log.id)\n                    .execute();\n                } else if (log.operation === 1) {\n                  // Update\n                  log.operation_id = undefined;\n                  log.checkpoint = undefined;\n                  log.operation = undefined;\n                  await tx_\n                    .withSchema(namespaceInfo.userNamespace)\n                    .updateTable(tableName)\n                    .set(log)\n                    .where(\"id\", \"=\", log.id)\n                    .execute();\n                } else {\n                  // Delete\n                  log.operation_id = undefined;\n                  log.checkpoint = undefined;\n                  log.operation = undefined;\n                  await tx_\n                    .withSchema(namespaceInfo.userNamespace)\n                    .insertInto(tableName)\n                    .values(log)\n                    .execute();\n                }\n              }\n\n              this.common.logger.info({\n                service: \"database\",\n                msg: `Reverted ${rows.length} unfinalized operations from existing '${tableName}' table`,\n              });\n            }\n\n            return {\n              status: \"success\",\n              checkpoint: finalizedCheckpoint,\n            } as const;\n          }\n\n          // Otherwise, the lock row has a different build ID or a zero finalized checkpoint,\n          // so we need to drop the previous app's tables and create new ones.\n          const previousBuildId = previousLockRow.build_id;\n          // Note: `previousSchema` should only be used to get table names or enum names because\n          // the types of `Table` and `Enum` have changed between versions.\n          const previousSchema = JSON.parse(previousLockRow.schema) as {\n            tables: { [tableName: string]: Table };\n            enums: { [enumName: string]: Enum };\n          };\n\n          await tx\n            .withSchema(this.internalNamespace)\n            .updateTable(\"namespace_lock\")\n            .where(\"namespace\", \"=\", this.userNamespace)\n            .set(newLockRow)\n            .execute();\n\n          this.common.logger.debug({\n            service: \"database\",\n            msg: `Acquired lock on schema '${this.userNamespace}' previously used by build '${previousBuildId}'`,\n          });\n\n          for (const tableName of Object.keys(previousSchema.tables)) {\n            const tableId = hash([\n              this.userNamespace,\n              previousBuildId,\n              tableName,\n            ]);\n\n            await tx.schema\n              .withSchema(this.internalNamespace)\n              .dropTable(tableId)\n              .ifExists()\n              .execute();\n\n            await tx.schema\n              .withSchema(this.userNamespace)\n              .dropTable(tableName)\n              .ifExists()\n              .execute();\n\n            this.common.logger.debug({\n              service: \"database\",\n              msg: `Dropped '${tableName}' table left by previous build`,\n            });\n          }\n\n          await createTables();\n\n          return { status: \"success\", checkpoint: zeroCheckpoint } as const;\n        });\n      };\n\n      const result = await attemptSetup();\n\n      let finalizedCheckpoint: Checkpoint;\n\n      if (result.status === \"success\") {\n        finalizedCheckpoint = result.checkpoint;\n      } else {\n        // If the namespace is locked, attempt one more time after waiting the timeout.\n        const { expiresInMs } = result;\n        this.common.logger.warn({\n          service: \"database\",\n          msg: `Database file '${this.userNamespace}.db' is locked by a different Ponder app`,\n        });\n        this.common.logger.warn({\n          service: \"database\",\n          msg: `Waiting ${formatEta(expiresInMs)} for lock on database file '${\n            this.userNamespace\n          }.db' to expire...`,\n        });\n\n        await wait(expiresInMs);\n\n        const resultTwo = await attemptSetup();\n        if (resultTwo.status === \"locked\") {\n          throw new NonRetryableError(\n            `Failed to acquire lock on database file '${this.userNamespace}.db'. A different Ponder app is actively using this database.`,\n          );\n        }\n        finalizedCheckpoint = resultTwo.checkpoint;\n      }\n\n      // Start the heartbeat interval to hold the lock for as long as the process is running.\n      this.heartbeatInterval = setInterval(async () => {\n        try {\n          const lockRow = await this.db\n            .withSchema(this.internalNamespace)\n            .updateTable(\"namespace_lock\")\n            .where(\"namespace\", \"=\", this.userNamespace)\n            .set({ heartbeat_at: Date.now() })\n            .returningAll()\n            .executeTakeFirst();\n\n          this.common.logger.debug({\n            service: \"database\",\n            msg: `Updated heartbeat timestamp to ${lockRow?.heartbeat_at} (build_id=${this.buildId})`,\n          });\n        } catch (err) {\n          const error = err as Error;\n          this.common.logger.error({\n            service: \"database\",\n            msg: `Failed to update heartbeat timestamp, retrying in ${formatEta(\n              this.common.options.databaseHeartbeatInterval,\n            )}`,\n            error,\n          });\n        }\n      }, this.common.options.databaseHeartbeatInterval);\n\n      return { checkpoint: finalizedCheckpoint, namespaceInfo };\n    });\n  }\n\n  async revert({\n    checkpoint,\n    namespaceInfo,\n  }: {\n    checkpoint: Checkpoint;\n    namespaceInfo: NamespaceInfo;\n  }) {\n    await revertIndexingTables({\n      db: this.indexingDb,\n      checkpoint,\n      namespaceInfo,\n    });\n  }\n\n  async updateFinalizedCheckpoint({\n    checkpoint,\n  }: { checkpoint: Checkpoint }): Promise<void> {\n    await this.db.wrap({ method: \"updateFinalizedCheckpoint\" }, async () => {\n      await this.db\n        .withSchema(this.internalNamespace)\n        .updateTable(\"namespace_lock\")\n        .where(\"namespace\", \"=\", this.userNamespace)\n        .set({ finalized_checkpoint: encodeCheckpoint(checkpoint) })\n        .execute();\n\n      this.common.logger.debug({\n        service: \"database\",\n        msg: `Updated finalized checkpoint to (timestamp=${checkpoint.blockTimestamp} chainId=${checkpoint.chainId} block=${checkpoint.blockNumber})`,\n      });\n    });\n  }\n\n  async createIndexes({ schema }: { schema: Schema }) {\n    await Promise.all(\n      Object.entries(getTables(schema)).flatMap(([tableName, table]) => {\n        if (table.constraints === undefined) return [];\n\n        return Object.entries(table.constraints).map(async ([name, index]) => {\n          await this.db.wrap({ method: \"createIndexes\" }, async () => {\n            const indexName = `${tableName}_${name}`;\n\n            const indexColumn = index[\" column\"];\n            const order = index[\" order\"];\n\n            const columns = Array.isArray(indexColumn)\n              ? indexColumn.map((ic) => `\"${ic}\"`).join(\", \")\n              : `\"${indexColumn}\" ${order === \"asc\" ? \"ASC\" : order === \"desc\" ? \"DESC\" : \"\"}`;\n\n            await this.db.executeQuery(\n              sql`CREATE INDEX ${sql.ref(this.userNamespace)}.${sql.ref(indexName)} ON ${sql.table(\n                tableName,\n              )} (${sql.raw(columns)})`.compile(this.db),\n            );\n          });\n\n          this.common.logger.info({\n            service: \"database\",\n            msg: `Created index '${tableName}_${name}' on columns (${\n              Array.isArray(index[\" column\"])\n                ? index[\" column\"].join(\", \")\n                : index[\" column\"]\n            }) in '${this.userNamespace}.db'`,\n          });\n        });\n      }),\n    );\n  }\n\n  async kill() {\n    await this.db.wrap({ method: \"kill\" }, async () => {\n      clearInterval(this.heartbeatInterval);\n\n      await this.db\n        .withSchema(this.internalNamespace)\n        .updateTable(\"namespace_lock\")\n        .where(\"namespace\", \"=\", this.userNamespace)\n        .set({ is_locked: 0 })\n        .returningAll()\n        .executeTakeFirst();\n\n      this.common.logger.debug({\n        service: \"database\",\n        msg: `Released lock on namespace '${this.userNamespace}'`,\n      });\n\n      await this.readonlyDb.destroy();\n      await this.indexingDb.destroy();\n      await this.syncDb.destroy();\n      await this.db.destroy();\n\n      this.syncDatabase.close();\n      this.readonlyDatabase.close();\n      this.internalDatabase.close();\n\n      this.common.logger.debug({\n        service: \"database\",\n        msg: \"Closed connection to database\",\n      });\n    });\n  }\n\n  async migrateSyncStore() {\n    await this.db.wrap({ method: \"migrateSyncStore\" }, async () => {\n      const migrator = new Migrator({\n        db: this.syncDb as Kysely<any>,\n        provider: syncMigrationProvider,\n      });\n\n      const { error } = await migrator.migrateToLatest();\n      if (error) throw error;\n    });\n  }\n\n  private buildColumns<T extends string, C extends string = never>(\n    builder: CreateTableBuilder<T, C>,\n    schema: Schema,\n    table: Table,\n  ) {\n    Object.entries(table).forEach(([columnName, column]) => {\n      if (isOneColumn(column)) return;\n      if (isManyColumn(column)) return;\n      if (isEnumColumn(column)) {\n        // Handle enum types\n        builder = builder.addColumn(columnName, \"text\", (col) => {\n          if (isOptionalColumn(column) === false) col = col.notNull();\n          if (isListColumn(column) === false) {\n            col = col.check(\n              sql`${sql.ref(columnName)} in (${sql.join(\n                getEnums(schema)[column[\" enum\"]]!.map((v) => sql.lit(v)),\n              )})`,\n            );\n          }\n          return col;\n        });\n      } else if (isListColumn(column)) {\n        // Handle scalar list columns\n        builder = builder.addColumn(columnName, \"text\", (col) => {\n          if (isOptionalColumn(column) === false) col = col.notNull();\n          return col;\n        });\n      } else if (isJSONColumn(column)) {\n        // Handle json columns\n        builder = builder.addColumn(columnName, \"jsonb\", (col) => {\n          if (isOptionalColumn(column) === false) col = col.notNull();\n          return col;\n        });\n      } else {\n        // Non-list base columns\n        builder = builder.addColumn(\n          columnName,\n          scalarToSqlType[column[\" scalar\"]],\n          (col) => {\n            if (isOptionalColumn(column) === false) col = col.notNull();\n            if (columnName === \"id\") col = col.primaryKey();\n            return col;\n          },\n        );\n      }\n    });\n\n    return builder;\n  }\n\n  private buildOperationLogColumns<T extends string, C extends string = never>(\n    builder: CreateTableBuilder<T, C>,\n    table: Table,\n  ) {\n    Object.entries(table).forEach(([columnName, column]) => {\n      if (isOneColumn(column)) return;\n      if (isManyColumn(column)) return;\n      if (isEnumColumn(column)) {\n        // Handle enum types\n        // Omit the CHECK constraint because its included in the user table\n        builder = builder.addColumn(columnName, \"text\");\n      } else if (isListColumn(column)) {\n        // Handle scalar list columns\n        builder = builder.addColumn(columnName, \"text\");\n      } else if (isJSONColumn(column)) {\n        // Handle json columns\n        builder = builder.addColumn(columnName, \"jsonb\");\n      } else {\n        // Non-list base columns\n        builder = builder.addColumn(\n          columnName,\n          scalarToSqlType[column[\" scalar\"]],\n          (col) => {\n            if (columnName === \"id\") col = col.notNull();\n            return col;\n          },\n        );\n      }\n    });\n\n    builder = builder\n      .addColumn(\"operation_id\", \"integer\", (col) => col.notNull().primaryKey())\n      .addColumn(\"checkpoint\", \"varchar(75)\", (col) => col.notNull())\n      .addColumn(\"operation\", \"integer\", (col) => col.notNull());\n\n    return builder;\n  }\n\n  private registerMetrics() {\n    this.common.metrics.registry.removeSingleMetric(\n      \"ponder_sqlite_query_total\",\n    );\n    this.common.metrics.ponder_sqlite_query_total = new prometheus.Counter({\n      name: \"ponder_sqlite_query_total\",\n      help: \"Number of queries submitted to the database\",\n      labelNames: [\"database\"] as const,\n      registers: [this.common.metrics.registry],\n    });\n  }\n\n  private async deleteV3DatabaseFiles() {\n    // Detect if the `.ponder/sqlite` directly contains 0.3 database files.\n    const hasV3Files = existsSync(path.join(this.directory, \"ponder_cache.db\"));\n\n    if (!hasV3Files) return;\n\n    this.common.logger.debug({\n      service: \"database\",\n      msg: \"Migrating '.ponder/sqlite' database from 0.3.x to 0.4.x\",\n    });\n\n    // Drop 'ponder_cache' database files.\n    rmSync(path.join(this.directory, \"ponder_cache.db\"), { force: true });\n    rmSync(path.join(this.directory, \"ponder_cache.db-shm\"), { force: true });\n    rmSync(path.join(this.directory, \"ponder_cache.db-wal\"), { force: true });\n    this.common.logger.debug({\n      service: \"database\",\n      msg: `Removed '.ponder/sqlite/ponder_cache.db' file`,\n    });\n\n    // Drop 'ponder' database files (they will be created again).\n    rmSync(path.join(this.directory, \"ponder.db\"), { force: true });\n    rmSync(path.join(this.directory, \"ponder.db-shm\"), { force: true });\n    rmSync(path.join(this.directory, \"ponder.db-wal\"), { force: true });\n    this.common.logger.debug({\n      service: \"database\",\n      msg: `Removed '.ponder/sqlite/ponder.db' file`,\n    });\n  }\n}\n\nconst scalarToSqlType = {\n  boolean: \"integer\",\n  int: \"integer\",\n  float: \"real\",\n  string: \"text\",\n  bigint: \"varchar(79)\",\n  hex: \"blob\",\n} as const;\n","import type { Kysely, Migration, MigrationProvider } from \"kysely\";\nimport { sql } from \"kysely\";\n\nconst migrations: Record<string, Migration> = {\n  \"2023_05_15_0_initial\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createTable(\"blocks\")\n        .addColumn(\"baseFeePerGas\", \"blob\") // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"difficulty\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"extraData\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"gasLimit\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"gasUsed\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"hash\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logsBloom\", \"text\", (col) => col.notNull())\n        .addColumn(\"miner\", \"text\", (col) => col.notNull())\n        .addColumn(\"mixHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"nonce\", \"text\", (col) => col.notNull())\n        .addColumn(\"number\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"parentHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"receiptsRoot\", \"text\", (col) => col.notNull())\n        .addColumn(\"sha3Uncles\", \"text\", (col) => col.notNull())\n        .addColumn(\"size\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"stateRoot\", \"text\", (col) => col.notNull())\n        .addColumn(\"timestamp\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"totalDifficulty\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"transactionsRoot\", \"text\", (col) => col.notNull())\n        .execute();\n\n      await db.schema\n        .createTable(\"transactions\")\n        .addColumn(\"accessList\", \"text\")\n        .addColumn(\"blockHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"from\", \"text\", (col) => col.notNull())\n        .addColumn(\"gas\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"gasPrice\", \"blob\") // BigInt\n        .addColumn(\"hash\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"input\", \"text\", (col) => col.notNull())\n        .addColumn(\"maxFeePerGas\", \"blob\") // BigInt\n        .addColumn(\"maxPriorityFeePerGas\", \"blob\") // BigInt\n        .addColumn(\"nonce\", \"integer\", (col) => col.notNull())\n        .addColumn(\"r\", \"text\", (col) => col.notNull())\n        .addColumn(\"s\", \"text\", (col) => col.notNull())\n        .addColumn(\"to\", \"text\")\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"type\", \"text\", (col) => col.notNull())\n        .addColumn(\"value\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"v\", \"blob\", (col) => col.notNull()) // BigInt\n        .execute();\n\n      await db.schema\n        .createTable(\"logs\")\n        .addColumn(\"address\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"topic0\", \"text\")\n        .addColumn(\"topic1\", \"text\")\n        .addColumn(\"topic2\", \"text\")\n        .addColumn(\"topic3\", \"text\")\n        .addColumn(\"transactionHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .execute();\n\n      await db.schema\n        .createTable(\"contractReadResults\")\n        .addColumn(\"address\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"result\", \"text\", (col) => col.notNull())\n        .addPrimaryKeyConstraint(\"contractReadResultPrimaryKey\", [\n          \"chainId\",\n          \"blockNumber\",\n          \"address\",\n          \"data\",\n        ])\n        .execute();\n\n      await db.schema\n        .createTable(\"logFilterCachedRanges\")\n        .addColumn(\"endBlock\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"endBlockTimestamp\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"filterKey\", \"text\", (col) => col.notNull())\n        // The `id` column should not be included in INSERT statements.\n        // This column uses SQLite's ROWID() function (simple autoincrement).\n        .addColumn(\"id\", \"integer\", (col) => col.notNull().primaryKey())\n        .addColumn(\"startBlock\", \"blob\", (col) => col.notNull()) // BigInt\n        .execute();\n    },\n  },\n  \"2023_06_20_0_indices\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createIndex(\"log_events_index\")\n        .on(\"logs\")\n        .columns([\"address\", \"chainId\", \"blockHash\"])\n        .execute();\n\n      await db.schema\n        .createIndex(\"blocks_index\")\n        .on(\"blocks\")\n        .columns([\"timestamp\", \"number\"])\n        .execute();\n\n      await db.schema\n        .createIndex(\"logFilterCachedRanges_index\")\n        .on(\"logFilterCachedRanges\")\n        .columns([\"filterKey\"])\n        .execute();\n    },\n  },\n  \"2023_07_18_0_better_indices\": {\n    async up(db: Kysely<any>) {\n      // Drop old indices.\n      await db.schema.dropIndex(\"log_events_index\").execute();\n      await db.schema.dropIndex(\"blocks_index\").execute();\n\n      // Block hash is a join key.\n      await db.schema\n        .createIndex(\"log_block_hash_index\")\n        .on(\"logs\")\n        .column(\"blockHash\")\n        .execute();\n\n      // Chain ID, address and topic0 are all used in WHERE clauses.\n      await db.schema\n        .createIndex(\"log_chain_id_index\")\n        .on(\"logs\")\n        .column(\"chainId\")\n        .execute();\n      await db.schema\n        .createIndex(\"log_address_index\")\n        .on(\"logs\")\n        .column(\"address\")\n        .execute();\n      await db.schema\n        .createIndex(\"log_topic0_index\")\n        .on(\"logs\")\n        .column(\"topic0\")\n        .execute();\n\n      // Block timestamp and number are both used in WHERE and SORT clauses.\n      await db.schema\n        .createIndex(\"block_timestamp_index\")\n        .on(\"blocks\")\n        .column(\"timestamp\")\n        .execute();\n      await db.schema\n        .createIndex(\"block_number_index\")\n        .on(\"blocks\")\n        .column(\"number\")\n        .execute();\n    },\n  },\n  \"2023_07_24_0_drop_finalized\": {\n    async up(db: Kysely<any>) {\n      await db.schema.alterTable(\"blocks\").dropColumn(\"finalized\").execute();\n      await db.schema\n        .alterTable(\"transactions\")\n        .dropColumn(\"finalized\")\n        .execute();\n      await db.schema.alterTable(\"logs\").dropColumn(\"finalized\").execute();\n      await db.schema\n        .alterTable(\"contractReadResults\")\n        .dropColumn(\"finalized\")\n        .execute();\n    },\n  },\n  \"2023_09_19_0_new_sync_design\": {\n    async up(db: Kysely<any>) {\n      /** This table is no longer being used. */\n      await db.schema.dropTable(\"logFilterCachedRanges\").execute();\n\n      /** Drop and re-create all tables to fix bigint encoding. */\n      await db.schema.dropTable(\"blocks\").execute();\n      await db.schema\n        .createTable(\"blocks\")\n        .addColumn(\"baseFeePerGas\", \"varchar(79)\")\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"difficulty\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"extraData\", \"text\", (col) => col.notNull())\n        .addColumn(\"gasLimit\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"gasUsed\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"hash\", \"varchar(66)\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logsBloom\", \"varchar(514)\", (col) => col.notNull())\n        .addColumn(\"miner\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"mixHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"nonce\", \"varchar(18)\", (col) => col.notNull())\n        .addColumn(\"number\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"parentHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"receiptsRoot\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"sha3Uncles\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"size\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"stateRoot\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"timestamp\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"totalDifficulty\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"transactionsRoot\", \"varchar(66)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"blockTimestampIndex\")\n        .on(\"blocks\")\n        .column(\"timestamp\")\n        .execute();\n      await db.schema\n        .createIndex(\"blockNumberIndex\")\n        .on(\"blocks\")\n        .column(\"number\")\n        .execute();\n\n      await db.schema.dropTable(\"transactions\").execute();\n      await db.schema\n        .createTable(\"transactions\")\n        .addColumn(\"accessList\", \"text\")\n        .addColumn(\"blockHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"from\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"gas\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"gasPrice\", \"varchar(79)\")\n        .addColumn(\"hash\", \"varchar(66)\", (col) => col.notNull().primaryKey())\n        .addColumn(\"input\", \"text\", (col) => col.notNull())\n        .addColumn(\"maxFeePerGas\", \"varchar(79)\")\n        .addColumn(\"maxPriorityFeePerGas\", \"varchar(79)\")\n        .addColumn(\"nonce\", \"integer\", (col) => col.notNull())\n        .addColumn(\"r\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"s\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"to\", \"varchar(42)\")\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"type\", \"text\", (col) => col.notNull())\n        .addColumn(\"value\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"v\", \"varchar(79)\", (col) => col.notNull())\n        .execute();\n\n      await db.schema.dropTable(\"logs\").execute();\n      await db.schema\n        .createTable(\"logs\")\n        .addColumn(\"address\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"blockHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"topic0\", \"varchar(66)\")\n        .addColumn(\"topic1\", \"varchar(66)\")\n        .addColumn(\"topic2\", \"varchar(66)\")\n        .addColumn(\"topic3\", \"varchar(66)\")\n        .addColumn(\"transactionHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"logBlockHashIndex\")\n        .on(\"logs\")\n        .column(\"blockHash\")\n        .execute();\n      await db.schema\n        .createIndex(\"logChainIdIndex\")\n        .on(\"logs\")\n        .column(\"chainId\")\n        .execute();\n      await db.schema\n        .createIndex(\"logAddressIndex\")\n        .on(\"logs\")\n        .column(\"address\")\n        .execute();\n      await db.schema\n        .createIndex(\"logTopic0Index\")\n        .on(\"logs\")\n        .column(\"topic0\")\n        .execute();\n\n      await db.schema.dropTable(\"contractReadResults\").execute();\n      await db.schema\n        .createTable(\"contractReadResults\")\n        .addColumn(\"address\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"result\", \"text\", (col) => col.notNull())\n        .addPrimaryKeyConstraint(\"contractReadResultPrimaryKey\", [\n          \"chainId\",\n          \"blockNumber\",\n          \"address\",\n          \"data\",\n        ])\n        .execute();\n\n      /** Add new log filter and factory contract interval tables. */\n      await db.schema\n        .createTable(\"logFilters\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${address}_${topic0}_${topic1}_${topic2}_${topic3}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"address\", \"varchar(66)\")\n        .addColumn(\"topic0\", \"varchar(66)\")\n        .addColumn(\"topic1\", \"varchar(66)\")\n        .addColumn(\"topic2\", \"varchar(66)\")\n        .addColumn(\"topic3\", \"varchar(66)\")\n        .execute();\n      await db.schema\n        .createTable(\"logFilterIntervals\")\n        .addColumn(\"id\", \"integer\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"logFilterId\", \"text\", (col) =>\n          col.notNull().references(\"logFilters.id\"),\n        )\n        .addColumn(\"startBlock\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"varchar(79)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"logFilterIntervalsLogFilterId\")\n        .on(\"logFilterIntervals\")\n        .column(\"logFilterId\")\n        .execute();\n\n      await db.schema\n        .createTable(\"factories\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${address}_${eventSelector}_${childAddressLocation}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"address\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"eventSelector\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"childAddressLocation\", \"text\", (col) => col.notNull()) // `topic${number}` or `offset${number}`\n        .addColumn(\"topic0\", \"varchar(66)\")\n        .addColumn(\"topic1\", \"varchar(66)\")\n        .addColumn(\"topic2\", \"varchar(66)\")\n        .addColumn(\"topic3\", \"varchar(66)\")\n        .execute();\n      await db.schema\n        .createTable(\"factoryLogFilterIntervals\")\n        .addColumn(\"id\", \"integer\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"factoryId\", \"text\", (col) =>\n          col.notNull().references(\"factories.id\"),\n        )\n        .addColumn(\"startBlock\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"varchar(79)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"factoryLogFilterIntervalsFactoryId\")\n        .on(\"factoryLogFilterIntervals\")\n        .column(\"factoryId\")\n        .execute();\n    },\n  },\n  \"2023_11_06_0_new_rpc_cache_design\": {\n    async up(db: Kysely<any>) {\n      await db.schema.dropTable(\"contractReadResults\").execute();\n\n      /**\n       * Formatting for \"request\" field values:\n       *\n       * eth_call: eth_call_{to}_{data}\n       * eth_getBalance: eth_getBalance_{address}\n       * eth_getCode: eth_getCode_{address}\n       * eth_getStorageAt: eth_getStorageAt_{address}_{slot}\n       */\n      await db.schema\n        .createTable(\"rpcRequestResults\")\n        .addColumn(\"request\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"result\", \"text\", (col) => col.notNull())\n        .addPrimaryKeyConstraint(\"rpcRequestResultPrimaryKey\", [\n          \"request\",\n          \"chainId\",\n          \"blockNumber\",\n        ])\n        .execute();\n    },\n  },\n  \"2024_02_1_0_nullable_block_columns\": {\n    async up(db: Kysely<any>) {\n      // SQLite doesn't support dropping NOT NULL constraints. As a workaround:\n      // 1) Create a new column of the same type without NOT NULL.\n      // 2) Copy data from the old column to the new column.\n      // 3) Drop the old column.\n      // 4) Rename the new column to the old column's name.\n\n      // Drop NOT NULL constraint from \"blocks.mixHash\".\n      await db.schema\n        .alterTable(\"blocks\")\n        .addColumn(\"mixHash_temp_null\", \"varchar(66)\")\n        .execute();\n      await db\n        .updateTable(\"blocks\")\n        .set((eb: any) => ({\n          mixHash_temp_null: eb.selectFrom(\"blocks\").select(\"mixHash\"),\n        }))\n        .execute();\n      await db.schema.alterTable(\"blocks\").dropColumn(\"mixHash\").execute();\n      await db.schema\n        .alterTable(\"blocks\")\n        .renameColumn(\"mixHash_temp_null\", \"mixHash\")\n        .execute();\n\n      // Drop NOT NULL constraint from \"blocks.nonce\".\n      await db.schema\n        .alterTable(\"blocks\")\n        .addColumn(\"nonce_temp_null\", \"varchar(18)\")\n        .execute();\n      await db\n        .updateTable(\"blocks\")\n        .set((eb: any) => ({\n          nonce_temp_null: eb.selectFrom(\"blocks\").select(\"nonce\"),\n        }))\n        .execute();\n      await db.schema.alterTable(\"blocks\").dropColumn(\"nonce\").execute();\n      await db.schema\n        .alterTable(\"blocks\")\n        .renameColumn(\"nonce_temp_null\", \"nonce\")\n        .execute();\n    },\n  },\n  \"2024_03_00_0_log_transaction_hash_index\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createIndex(\"log_transaction_hash_index\")\n        .on(\"logs\")\n        .column(\"transactionHash\")\n        .execute();\n    },\n  },\n  \"2024_03_13_0_nullable_block_columns_sha3uncles\": {\n    async up(db: Kysely<any>) {\n      await columnDropNotNull({\n        db,\n        table: \"blocks\",\n        column: \"sha3Uncles\",\n        columnType: \"varchar(66)\",\n      });\n    },\n  },\n  \"2024_03_14_0_nullable_transaction_rsv\": {\n    async up(db: Kysely<any>) {\n      await columnDropNotNull({\n        db,\n        table: \"transactions\",\n        column: \"r\",\n        columnType: \"varchar(66)\",\n      });\n      await columnDropNotNull({\n        db,\n        table: \"transactions\",\n        column: \"s\",\n        columnType: \"varchar(66)\",\n      });\n      await columnDropNotNull({\n        db,\n        table: \"transactions\",\n        column: \"v\",\n        columnType: \"varchar(79)\",\n      });\n    },\n  },\n  \"2024_03_20_0_checkpoint_in_logs_table\": {\n    async up(_db: Kysely<any>) {\n      // no-op migration to avoid crashing databases that successfully ran this migration\n      return;\n    },\n  },\n  \"2024_04_04_0_log_events_indexes\": {\n    async up(db: Kysely<any>) {\n      await db.schema.dropIndex(\"blockNumberIndex\").ifExists().execute();\n      await db.schema.dropIndex(\"blockTimestampIndex\").ifExists().execute();\n\n      await db.schema\n        .createIndex(\"logBlockNumberIndex\")\n        .on(\"logs\")\n        .column(\"blockNumber\")\n        .execute();\n    },\n  },\n  \"2024_04_14_0_nullable_block_total_difficulty\": {\n    async up(db: Kysely<any>) {\n      await columnDropNotNull({\n        db,\n        table: \"blocks\",\n        column: \"totalDifficulty\",\n        columnType: \"varchar(79)\",\n      });\n    },\n  },\n  \"2024_04_14_1_add_checkpoint_column_to_logs_table\": {\n    async up(db: Kysely<any>) {\n      if (await hasCheckpointCol(db)) {\n        return;\n      }\n      await db.schema\n        .alterTable(\"logs\")\n        .addColumn(\"checkpoint\", \"varchar(75)\")\n        .execute();\n    },\n  },\n  \"2024_04_14_2_set_checkpoint_in_logs_table\": {\n    async up(db: Kysely<any>) {\n      await db.executeQuery(\n        sql`\n        CREATE TEMPORARY TABLE cp_vals AS\n        SELECT \n          logs.id,\n          substr(blocks.timestamp, -10, 10) ||\n            substr('0000000000000000' || blocks.chainId, -16, 16) ||\n            substr(blocks.number, -16, 16) ||\n            substr('0000000000000000' || logs.transactionIndex, -16, 16) ||\n            '5' ||\n            substr('0000000000000000' || logs.logIndex, -16, 16) as checkpoint\n          FROM logs\n          JOIN blocks ON logs.\"blockHash\" = blocks.hash\n      `.compile(db),\n      );\n\n      await db.executeQuery(\n        sql`\n        UPDATE logs \n        SET checkpoint=cp_vals.checkpoint\n        FROM cp_vals\n        WHERE logs.id = cp_vals.id\n      `.compile(db),\n      );\n    },\n  },\n  \"2024_04_14_3_index_on_logs_checkpoint\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createIndex(\"logs_checkpoint_index\")\n        .ifNotExists()\n        .on(\"logs\")\n        .column(\"checkpoint\")\n        .execute();\n    },\n  },\n  \"2024_04_22_0_transaction_receipts\": {\n    async up(db: Kysely<any>) {\n      // Disable foriegn keys for the duration of this transaction.\n      await db.executeQuery(sql`PRAGMA foreign_keys = 0`.compile(db));\n\n      // Rename and update the existing tables to include the data we want. Note that\n      // these tables have constraints that we do NOT want. They won't get copied over.\n      await db.schema\n        .alterTable(\"logFilters\")\n        .renameTo(\"logFilters_temp\")\n        .execute();\n      await db\n        .updateTable(\"logFilters_temp\")\n        .set({ id: sql`\"id\" || '_0'` })\n        .execute();\n      await db.schema\n        .alterTable(\"logFilters_temp\")\n        .addColumn(\"includeTransactionReceipts\", \"integer\", (col) =>\n          col.notNull().defaultTo(0),\n        )\n        .execute();\n      await db.schema\n        .alterTable(\"logFilterIntervals\")\n        .renameTo(\"logFilterIntervals_temp\")\n        .execute();\n      await db\n        .updateTable(\"logFilterIntervals_temp\")\n        .set({ logFilterId: sql`\"logFilterId\" || '_0'` })\n        .execute();\n\n      await db.schema\n        .createTable(\"logFilters\")\n        // `${chainId}_${address}_${topic0}_${topic1}_${topic2}_${topic3}_${includeTransactionReceipts}`\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"address\", \"varchar(66)\")\n        .addColumn(\"topic0\", \"varchar(66)\")\n        .addColumn(\"topic1\", \"varchar(66)\")\n        .addColumn(\"topic2\", \"varchar(66)\")\n        .addColumn(\"topic3\", \"varchar(66)\")\n        .addColumn(\"includeTransactionReceipts\", \"integer\", (col) =>\n          col.notNull(),\n        )\n        .execute();\n      await db.schema\n        .createTable(\"logFilterIntervals\")\n        .addColumn(\"id\", \"integer\", (col) => col.notNull().primaryKey()) // Auto-increment\n        // Note that we removed the foreign key constraint here.\n        .addColumn(\"logFilterId\", \"text\", (col) => col.notNull())\n        .addColumn(\"startBlock\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"varchar(79)\", (col) => col.notNull())\n        .execute();\n      // Copy data from temp tables to new tables.\n      await db.executeQuery(\n        sql`INSERT INTO \"logFilters\" SELECT * FROM \"logFilters_temp\"`.compile(\n          db,\n        ),\n      );\n      await db.executeQuery(\n        sql`INSERT INTO \"logFilterIntervals\" SELECT * FROM \"logFilterIntervals_temp\"`.compile(\n          db,\n        ),\n      );\n      // Drop the temp tables.\n      await db.schema.dropTable(\"logFilters_temp\").execute();\n      await db.schema.dropTable(\"logFilterIntervals_temp\").execute();\n      // Add back the index.\n      await db.schema\n        .createIndex(\"logFilterIntervalsLogFilterId\")\n        .on(\"logFilterIntervals\")\n        .column(\"logFilterId\")\n        .execute();\n\n      // Repeat the same process for factories.\n      await db.schema\n        .alterTable(\"factories\")\n        .renameTo(\"factories_temp\")\n        .execute();\n      await db\n        .updateTable(\"factories_temp\")\n        .set({ id: sql`\"id\" || '_0'` })\n        .execute();\n      await db.schema\n        .alterTable(\"factories_temp\")\n        .addColumn(\"includeTransactionReceipts\", \"integer\", (col) =>\n          col.notNull().defaultTo(0),\n        )\n        .execute();\n      await db.schema\n        .alterTable(\"factoryLogFilterIntervals\")\n        .renameTo(\"factoryLogFilterIntervals_temp\")\n        .execute();\n      await db\n        .updateTable(\"factoryLogFilterIntervals_temp\")\n        .set({ factoryId: sql`\"factoryId\" || '_0'` })\n        .execute();\n      await db.schema\n        .createTable(\"factories\")\n        // `${chainId}_${address}_${eventSelector}_${childAddressLocation}_${topic0}_${topic1}_${topic2}_${topic3}_${includeTransactionReceipts}`\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"address\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"eventSelector\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"childAddressLocation\", \"text\", (col) => col.notNull()) // `topic${number}` or `offset${number}`\n        .addColumn(\"topic0\", \"varchar(66)\")\n        .addColumn(\"topic1\", \"varchar(66)\")\n        .addColumn(\"topic2\", \"varchar(66)\")\n        .addColumn(\"topic3\", \"varchar(66)\")\n        .addColumn(\"includeTransactionReceipts\", \"integer\", (col) =>\n          col.notNull(),\n        )\n        .execute();\n      await db.schema\n        .createTable(\"factoryLogFilterIntervals\")\n        .addColumn(\"id\", \"integer\", (col) => col.notNull().primaryKey()) // Auto-increment\n        // Note that we removed the foreign key constraint here.\n        .addColumn(\"factoryId\", \"text\", (col) => col.notNull())\n        .addColumn(\"startBlock\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"varchar(79)\", (col) => col.notNull())\n        .execute();\n      await db.executeQuery(\n        sql`INSERT INTO \"factories\" SELECT * FROM \"factories_temp\"`.compile(db),\n      );\n      await db.executeQuery(\n        sql`INSERT INTO \"factoryLogFilterIntervals\" SELECT * FROM \"factoryLogFilterIntervals_temp\"`.compile(\n          db,\n        ),\n      );\n      await db.schema.dropTable(\"factories_temp\").execute();\n      await db.schema.dropTable(\"factoryLogFilterIntervals_temp\").execute();\n      await db.schema\n        .createIndex(\"factoryLogFilterIntervalsFactoryId\")\n        .on(\"factoryLogFilterIntervals\")\n        .column(\"factoryId\")\n        .execute();\n\n      await db.schema\n        .createTable(\"transactionReceipts\")\n        .addColumn(\"blockHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"contractAddress\", \"varchar(66)\")\n        .addColumn(\"cumulativeGasUsed\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"effectiveGasPrice\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"from\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"gasUsed\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"logs\", \"text\", (col) => col.notNull())\n        .addColumn(\"logsBloom\", \"varchar(514)\", (col) => col.notNull())\n        .addColumn(\"status\", \"text\", (col) => col.notNull())\n        .addColumn(\"to\", \"varchar(42)\")\n        .addColumn(\"transactionHash\", \"varchar(66)\", (col) =>\n          col.notNull().primaryKey(),\n        )\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"type\", \"text\", (col) => col.notNull())\n        .execute();\n\n      await db.executeQuery(sql`PRAGMA foreign_keys = 1`.compile(db));\n    },\n  },\n  \"2024_04_23_0_block_filters\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createTable(\"blockFilters\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${interval}_${offset}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"interval\", \"integer\", (col) => col.notNull())\n        .addColumn(\"offset\", \"integer\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createTable(\"blockFilterIntervals\")\n        .addColumn(\"id\", \"integer\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"blockFilterId\", \"text\", (col) =>\n          col.notNull().references(\"blockFilters.id\"),\n        )\n        .addColumn(\"startBlock\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"varchar(79)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"blockFilterIntervalsBlockFilterId\")\n        .on(\"blockFilterIntervals\")\n        .column(\"blockFilterId\")\n        .execute();\n\n      await db.schema\n        .alterTable(\"blocks\")\n        .addColumn(\"checkpoint\", \"varchar(75)\")\n        .execute();\n      await db.executeQuery(\n        sql`\n          CREATE TEMPORARY TABLE bcp_vals AS\n          SELECT \n            blocks.hash,\n            substr(blocks.timestamp, -10, 10) ||\n              substr('0000000000000000' || blocks.chainId, -16, 16) ||\n              substr(blocks.number, -16, 16) ||\n              '9999999999999999' ||\n              '5' ||\n              '0000000000000000' as checkpoint\n            FROM blocks\n        `.compile(db),\n      );\n      await db.executeQuery(\n        sql`\n          UPDATE blocks \n          SET checkpoint=bcp_vals.checkpoint\n          FROM bcp_vals\n          WHERE blocks.hash = bcp_vals.hash\n        `.compile(db),\n      );\n\n      await db.schema.alterTable(\"blocks\").renameTo(\"blocks_temp\").execute();\n\n      await db.schema\n        .createTable(\"blocks\")\n        .addColumn(\"baseFeePerGas\", \"varchar(79)\")\n        .addColumn(\"difficulty\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"extraData\", \"text\", (col) => col.notNull())\n        .addColumn(\"gasLimit\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"gasUsed\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"hash\", \"varchar(66)\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logsBloom\", \"varchar(514)\", (col) => col.notNull())\n        .addColumn(\"miner\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"mixHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"nonce\", \"varchar(18)\", (col) => col.notNull())\n        .addColumn(\"number\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"parentHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"receiptsRoot\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"sha3Uncles\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"size\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"stateRoot\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"timestamp\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"totalDifficulty\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"transactionsRoot\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"checkpoint\", \"varchar(75)\", (col) => col.notNull())\n        .execute();\n\n      await db.executeQuery(\n        sql`INSERT INTO \"blocks\" SELECT * FROM \"blocks_temp\"`.compile(db),\n      );\n\n      await db.schema.dropTable(\"blocks_temp\").execute();\n\n      // The blocks.number index supports getEvents and deleteRealtimeData\n      await db.schema\n        .createIndex(\"blockNumberIndex\")\n        .on(\"blocks\")\n        .column(\"number\")\n        .execute();\n      // The blocks.chainId index supports getEvents and deleteRealtimeData\n      await db.schema\n        .createIndex(\"blockChainIdIndex\")\n        .on(\"blocks\")\n        .column(\"chainId\")\n        .execute();\n      // The blocks.number index supports getEvents\n      await db.schema\n        .createIndex(\"blockCheckpointIndex\")\n        .on(\"blocks\")\n        .column(\"checkpoint\")\n        .execute();\n    },\n  },\n  \"2024_05_06_0_drop_not_null_block_columns\": {\n    async up(db: Kysely<any>) {\n      await columnDropNotNull({\n        db,\n        table: \"blocks\",\n        column: \"baseFeePerGas\",\n        columnType: \"varchar(79)\",\n      });\n      await columnDropNotNull({\n        db,\n        table: \"blocks\",\n        column: \"mixHash\",\n        columnType: \"varchar(66)\",\n      });\n      await columnDropNotNull({\n        db,\n        table: \"blocks\",\n        column: \"nonce\",\n        columnType: \"varchar(18)\",\n      });\n      await columnDropNotNull({\n        db,\n        table: \"blocks\",\n        column: \"sha3Uncles\",\n        columnType: \"varchar(66)\",\n      });\n      await columnDropNotNull({\n        db,\n        table: \"blocks\",\n        column: \"totalDifficulty\",\n        columnType: \"varchar(79)\",\n      });\n    },\n  },\n  \"2024_05_07_0_trace_filters\": {\n    async up(db: Kysely<any>) {\n      // TODO(kyle) drop foreign key constraint on \"blockFilterIntervals.blockFilterId\".\n\n      await db.schema\n        .createTable(\"traceFilters\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${fromAddress}_${toAddress}_${includeTransactionReceipts}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"fromAddress\", \"varchar(42)\")\n        .addColumn(\"toAddress\", \"varchar(42)\")\n        .execute();\n      await db.schema\n        .createTable(\"traceFilterIntervals\")\n        .addColumn(\"id\", \"integer\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"traceFilterId\", \"text\", (col) => col.notNull())\n        .addColumn(\"startBlock\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"varchar(79)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"traceFilterIntervalsTraceFilterId\")\n        .on(\"traceFilterIntervals\")\n        .column(\"traceFilterId\")\n        .execute();\n\n      await db.schema\n        .createTable(\"callTraces\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"callType\", \"text\", (col) => col.notNull())\n        .addColumn(\"from\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"gas\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"input\", \"text\", (col) => col.notNull())\n        .addColumn(\"to\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"value\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"blockHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"error\", \"text\")\n        .addColumn(\"gasUsed\", \"varchar(79)\")\n        .addColumn(\"output\", \"text\")\n        .addColumn(\"subtraces\", \"integer\", (col) => col.notNull())\n        .addColumn(\"traceAddress\", \"text\", (col) => col.notNull())\n        .addColumn(\"transactionHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"transactionPosition\", \"integer\", (col) => col.notNull())\n        .addColumn(\"functionSelector\", \"varchar(10)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"checkpoint\", \"varchar(75)\", (col) => col.notNull())\n        .execute();\n\n      // The callTraces.blockNumber index supports getEvents and deleteRealtimeData\n      await db.schema\n        .createIndex(\"callTracesBlockNumberIndex\")\n        .on(\"callTraces\")\n        .column(\"blockNumber\")\n        .execute();\n\n      // The callTraces.functionSelector index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesFunctionSelectorIndex\")\n        .on(\"callTraces\")\n        .column(\"functionSelector\")\n        .execute();\n\n      // The callTraces.error index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesErrorIndex\")\n        .on(\"callTraces\")\n        .column(\"error\")\n        .execute();\n\n      // The callTraces.blockHash index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesBlockHashIndex\")\n        .on(\"callTraces\")\n        .column(\"blockHash\")\n        .execute();\n\n      // The callTraces.transactionHash index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesTransactionHashIndex\")\n        .on(\"callTraces\")\n        .column(\"transactionHash\")\n        .execute();\n\n      // The callTraces.checkpoint index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesCheckpointIndex\")\n        .on(\"callTraces\")\n        .column(\"checkpoint\")\n        .execute();\n\n      // The callTraces.chainId index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesChainIdIndex\")\n        .on(\"callTraces\")\n        .column(\"chainId\")\n        .execute();\n\n      // The callTraces.from index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesFromIndex\")\n        .on(\"callTraces\")\n        .column(\"from\")\n        .execute();\n\n      // The callTraces.to index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesToIndex\")\n        .on(\"callTraces\")\n        .column(\"to\")\n        .execute();\n\n      await db.schema\n        .alterTable(\"factories\")\n        .renameTo(\"factoryLogFilters\")\n        .execute();\n\n      await db.schema\n        .createTable(\"factoryTraceFilters\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${address}_${eventSelector}_${childAddressLocation}_${fromAddress}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"address\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"eventSelector\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"childAddressLocation\", \"text\", (col) => col.notNull()) // `topic${number}` or `offset${number}`\n        .addColumn(\"fromAddress\", \"varchar(42)\")\n        .execute();\n      await db.schema\n        .createTable(\"factoryTraceFilterIntervals\")\n        .addColumn(\"id\", \"integer\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"factoryId\", \"text\")\n        .addColumn(\"startBlock\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"varchar(79)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"factoryTraceFilterIntervalsFactoryId\")\n        .on(\"factoryTraceFilterIntervals\")\n        .column(\"factoryId\")\n        .execute();\n    },\n  },\n};\n\nasync function hasCheckpointCol(db: Kysely<any>) {\n  const res = await db.executeQuery(sql`PRAGMA table_info(\"logs\")`.compile(db));\n  return res.rows.some((x: any) => x.name === \"checkpoint\");\n}\n\nconst columnDropNotNull = async ({\n  db,\n  table,\n  column,\n  columnType,\n}: {\n  db: Kysely<any>;\n  table: string;\n  column: string;\n  columnType: Parameters<\n    ReturnType<Kysely<any>[\"schema\"][\"alterTable\"]>[\"addColumn\"]\n  >[1];\n}) => {\n  const tempName = `${column}_temp_null`;\n\n  await db.schema.alterTable(table).addColumn(tempName, columnType).execute();\n  await db\n    .updateTable(table)\n    .set((eb: any) => ({ [tempName]: eb.selectFrom(table).select(column) }))\n    .execute();\n  await db.schema.alterTable(table).dropColumn(column).execute();\n  await db.schema.alterTable(table).renameColumn(tempName, column).execute();\n};\n\nclass StaticMigrationProvider implements MigrationProvider {\n  async getMigrations() {\n    return migrations;\n  }\n}\n\nexport const migrationProvider = new StaticMigrationProvider();\n","import BetterSqlite3 from \"better-sqlite3\";\n\nimport { ensureDirExists } from \"./exists.js\";\nimport { prettyPrint } from \"./print.js\";\n\nfunction improveSqliteErrors(database: BetterSqlite3.Database) {\n  const originalPrepare = database.prepare;\n  // @ts-ignore\n  database.prepare = (source: string) => {\n    let statement: any;\n    try {\n      statement = originalPrepare.apply(database, [source]);\n    } catch (error_) {\n      // This block is reachable if the database is closed, and possibly in other cases.\n      const error = error_ as Error & { detail?: string; meta?: string[] };\n      error.name = \"SqliteError\";\n      Error.captureStackTrace(error);\n\n      error.meta = Array.isArray(error.meta) ? error.meta : [];\n      if (error.detail) error.meta.push(`Detail:\\n  ${error.detail}`);\n      error.meta.push(`Statement:\\n  ${statement}`);\n\n      throw error;\n    }\n\n    const wrapper =\n      (fn: (...args: any) => void) =>\n      (...args: any) => {\n        try {\n          return fn.apply(statement, args);\n        } catch (error_) {\n          const error = error_ as Error & { detail?: string; meta?: string[] };\n          error.name = \"SqliteError\";\n\n          let parameters = (args[0] ?? []) as string[];\n          parameters =\n            parameters.length <= 25\n              ? parameters\n              : parameters.slice(0, 26).concat([\"...\"]);\n          const params = parameters.reduce<Record<number, any>>(\n            (acc, parameter, idx) => {\n              acc[idx + 1] = parameter;\n              return acc;\n            },\n            {},\n          );\n\n          error.meta = Array.isArray(error.meta) ? error.meta : [];\n          if (error.detail) error.meta.push(`Detail:\\n  ${error.detail}`);\n          error.meta.push(`Statement:\\n  ${source}`);\n          error.meta.push(`Parameters:\\n${prettyPrint(params)}`);\n\n          throw error;\n        }\n      };\n\n    for (const method of [\"run\", \"get\", \"all\"]) {\n      // @ts-ignore\n      statement[method] = wrapper(statement[method]);\n    }\n\n    return statement;\n  };\n}\n\nexport type SqliteDatabase = BetterSqlite3.Database;\n\nexport function createSqliteDatabase(\n  file: string,\n  options?: BetterSqlite3.Options,\n): SqliteDatabase {\n  ensureDirExists(file);\n  const database = new BetterSqlite3(file, options);\n  improveSqliteErrors(database);\n  database.pragma(\"journal_mode = WAL\");\n  return database;\n}\n\nexport function createReadonlySqliteDatabase(\n  file: string,\n  options?: BetterSqlite3.Options,\n): SqliteDatabase {\n  ensureDirExists(file);\n  const database = new BetterSqlite3(file, { readonly: true, ...options });\n  improveSqliteErrors(database);\n  database.pragma(\"journal_mode = WAL\");\n  return database;\n}\n","import { existsSync, mkdirSync } from \"node:fs\";\nimport path from \"node:path\";\n\nexport const ensureDirExists = (filePath: string) => {\n  const dirname = path.dirname(filePath);\n  if (existsSync(dirname)) {\n    return;\n  }\n  mkdirSync(dirname, { recursive: true });\n};\n","import type { Kysely } from \"kysely\";\nimport type { Migration, MigrationProvider } from \"kysely\";\n\nconst migrations: Record<string, Migration> = {\n  \"2024_03_28_0_initial\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createTable(\"namespace_lock\")\n        .ifNotExists()\n        .addColumn(\"namespace\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"is_locked\", \"integer\", (col) => col.notNull())\n        .addColumn(\"heartbeat_at\", \"integer\", (col) => col.notNull())\n        .addColumn(\"build_id\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized_checkpoint\", \"varchar(75)\", (col) =>\n          col.notNull(),\n        )\n        .addColumn(\"schema\", \"jsonb\", (col) => col.notNull())\n        .execute();\n    },\n  },\n};\n\nclass StaticMigrationProvider implements MigrationProvider {\n  async getMigrations() {\n    return migrations;\n  }\n}\n\nexport const migrationProvider = new StaticMigrationProvider();\n\nexport type InternalTables = {\n  namespace_lock: {\n    namespace: string;\n    is_locked: number;\n    heartbeat_at: number;\n    build_id: string;\n    finalized_checkpoint: string;\n    schema: string;\n  };\n};\n","import type { Common } from \"@/common/common.js\";\nimport {\n  FlushError,\n  RecordNotFoundError,\n  UniqueConstraintError,\n} from \"@/common/errors.js\";\nimport type { HeadlessKysely } from \"@/database/kysely.js\";\nimport type { NamespaceInfo } from \"@/database/service.js\";\nimport type { Schema, Table } from \"@/schema/common.js\";\nimport {\n  getTables,\n  isMaterialColumn,\n  isReferenceColumn,\n  isScalarColumn,\n} from \"@/schema/utils.js\";\nimport type {\n  DatabaseRecord,\n  DatabaseValue,\n  UserId,\n  UserRecord,\n  UserValue,\n} from \"@/types/schema.js\";\nimport { createQueue } from \"@ponder/common\";\nimport { sql } from \"kysely\";\nimport { type Hex, padHex } from \"viem\";\nimport type {\n  HistoricalStore,\n  OrderByInput,\n  ReadonlyStore,\n  WhereInput,\n} from \"./store.js\";\nimport {\n  decodeRecord,\n  encodeRecord,\n  encodeValue,\n  validateRecord,\n} from \"./utils/encoding.js\";\nimport { parseStoreError } from \"./utils/errors.js\";\nimport { buildWhereConditions } from \"./utils/filter.js\";\n\n/** Cache entries that need to be created in the database. */\ntype InsertEntry = {\n  type: \"insert\";\n  opIndex: number;\n  bytes: number;\n  record: UserRecord;\n};\n\n/** Cache entries that need to be updated in the database. */\ntype UpdateEntry = {\n  type: \"update\";\n  opIndex: number;\n  bytes: number;\n  record: UserRecord;\n};\n\n/**\n * Cache entries that mirror the database. Can be `null`,\n * meaning the entry doesn't exist in the cache.\n */\ntype FindEntry = {\n  type: \"find\";\n  opIndex: number;\n  bytes: number;\n  record: UserRecord | null;\n};\n\ntype Entry = InsertEntry | UpdateEntry | FindEntry;\n\ntype Key = string | number;\n\n/**\n * An in-memory representation of the indexing store. Every entry is\n * normalized, validated, and guaranteed to not share any references\n * with user-land.\n */\ntype StoreCache = {\n  [tableName: string]: { [key: Key]: Entry };\n};\n\nexport const getHistoricalStore = ({\n  encoding,\n  schema,\n  readonlyStore,\n  namespaceInfo,\n  db,\n  common,\n  isCacheExhaustive: _isCacheExhaustive,\n}: {\n  encoding: \"sqlite\" | \"postgres\";\n  schema: Schema;\n  readonlyStore: ReadonlyStore;\n  namespaceInfo: NamespaceInfo;\n  db: HeadlessKysely<any>;\n  common: Common;\n  isCacheExhaustive: boolean;\n}): HistoricalStore => {\n  const maxSizeBytes = common.options.indexingCacheMaxBytes;\n  const storeCache: StoreCache = {};\n  const tables = getTables(schema);\n\n  common.logger.debug({\n    service: \"indexing\",\n    msg: `Using a ${Math.round(maxSizeBytes / (1024 * 1024))} MB indexing cache`,\n  });\n\n  /** True if the cache contains the complete state of the store. */\n  let isCacheExhaustive = _isCacheExhaustive;\n\n  /** Number of rows in cache. */\n  let cacheSize = 0;\n  /** Estimated number of bytes used by cache. */\n  let cacheSizeBytes = 0;\n  /** LRU counter. */\n  let totalCacheOps = 0;\n\n  for (const tableName of Object.keys(tables)) {\n    storeCache[tableName] = {};\n  }\n\n  /**\n   * Hex values must be normalized to mirror the `UInt8Array`\n   * encoding. i.e. \"0xa\", \"0xA\", \"0x0a\", \"0x0A\" are all equivalent.\n   */\n  const normalizeHex = (hex: Hex) =>\n    padHex(hex, {\n      size: Math.ceil((hex.length - 2) / 2),\n      dir: \"left\",\n    }).toLowerCase();\n\n  const getCacheKey = (id: UserId, tableName: string): Key => {\n    if (tables[tableName]!.table.id[\" scalar\"] === \"hex\")\n      return normalizeHex(id as Hex);\n    if (typeof id === \"bigint\") return `#Bigint.${id}`;\n    return id;\n  };\n\n  /**\n   * Updates a record as if it had been encoded, stored in the database,\n   * and then decoded. This is required to normalize p.hex() column values\n   * and nullable column values.\n   */\n  const normalizeRecord = (record: UserRecord, tableName: string) => {\n    for (const [columnName, column] of Object.entries(\n      tables[tableName]!.table,\n    )) {\n      // optional columns are null\n      if (isMaterialColumn(column) && record[columnName] === undefined) {\n        record[columnName] = null;\n      }\n      // hex is lowercase byte encoded\n      if (\n        (isScalarColumn(column) || isReferenceColumn(column)) &&\n        column[\" scalar\"] === \"hex\" &&\n        typeof record[columnName] === \"string\"\n      ) {\n        record[columnName] = normalizeHex(record[columnName] as Hex);\n      }\n    }\n  };\n\n  const shouldFlush = () => cacheSizeBytes > maxSizeBytes;\n\n  const flush = createQueue<void, { isFullFlush: boolean }>({\n    concurrency: 1,\n    initialStart: true,\n    browser: false,\n    worker: async ({ isFullFlush }: { isFullFlush: boolean }) => {\n      const flushIndex =\n        totalCacheOps -\n        cacheSize * (1 - common.options.indexingCacheFlushRatio);\n\n      await Promise.all(\n        Object.entries(storeCache).map(async ([tableName, tableStoreCache]) => {\n          const table = (schema[tableName] as { table: Table }).table;\n          const cacheEntries = Object.values(tableStoreCache);\n          const batchSize = Math.round(\n            common.options.databaseMaxQueryParameters /\n              Object.keys(table).length,\n          );\n\n          let insertRecords: UserRecord[];\n\n          if (isFullFlush) {\n            insertRecords = cacheEntries\n              .filter(({ type }) => type === \"insert\")\n              .map(({ record }) => record!);\n          } else {\n            insertRecords = cacheEntries\n              .filter(\n                ({ type, opIndex }) =>\n                  type === \"insert\" && opIndex < flushIndex,\n              )\n              .map(({ record }) => record!);\n          }\n\n          if (insertRecords.length !== 0) {\n            common.logger.debug({\n              service: \"indexing\",\n              msg: `Inserting ${insertRecords.length} cached '${tableName}' records into the database`,\n            });\n\n            for (\n              let i = 0, len = insertRecords.length;\n              i < len;\n              i += batchSize\n            ) {\n              await db.wrap({ method: `${tableName}.flush` }, async () => {\n                const _insertRecords = insertRecords\n                  .slice(i, i + batchSize)\n                  // skip validation because its already occurred in the store method\n                  .map((record) =>\n                    encodeRecord({\n                      record,\n                      table,\n                      schema,\n                      encoding,\n                      skipValidation: true,\n                    }),\n                  );\n\n                await db\n                  .withSchema(namespaceInfo.userNamespace)\n                  .insertInto(tableName)\n                  .values(_insertRecords)\n                  .execute()\n                  .catch((_error) => {\n                    const error = _error as Error;\n                    common.logger.error({\n                      service: \"indexing\",\n                      msg: \"Internal error occurred while flushing cache. Please report this error here: https://github.com/ponder-sh/ponder/issues\",\n                    });\n                    throw new FlushError(error.message);\n                  });\n              });\n            }\n          }\n\n          // Exit early if the table only has an \"id\" column.\n          if (Object.values(table).filter(isMaterialColumn).length === 1) {\n            return;\n          }\n\n          let updateRecords: UserRecord[];\n\n          if (isFullFlush) {\n            updateRecords = cacheEntries\n              .filter(({ type }) => type === \"update\")\n              .map(({ record }) => record!);\n          } else {\n            updateRecords = cacheEntries\n              .filter(\n                ({ type, opIndex }) =>\n                  type === \"update\" && opIndex < flushIndex,\n              )\n              .map(({ record }) => record!);\n          }\n\n          if (updateRecords.length !== 0) {\n            common.logger.debug({\n              service: \"indexing\",\n              msg: `Updating ${updateRecords.length} cached '${tableName}' records in the database`,\n            });\n\n            for (\n              let i = 0, len = updateRecords.length;\n              i < len;\n              i += batchSize\n            ) {\n              await db.wrap({ method: `${tableName}.flush` }, async () => {\n                const _updateRecords = updateRecords\n                  .slice(i, i + batchSize)\n                  // skip validation because its already occurred in the store method\n                  .map((record) =>\n                    encodeRecord({\n                      record,\n                      table,\n                      schema,\n                      encoding,\n                      skipValidation: true,\n                    }),\n                  );\n\n                await db\n                  .withSchema(namespaceInfo.userNamespace)\n                  .insertInto(tableName)\n                  .values(_updateRecords)\n                  .onConflict((oc) =>\n                    oc.column(\"id\").doUpdateSet((eb) =>\n                      Object.entries(table).reduce<any>(\n                        (acc, [colName, column]) => {\n                          if (colName !== \"id\") {\n                            if (isMaterialColumn(column)) {\n                              acc[colName] = eb.ref(`excluded.${colName}`);\n                            }\n                          }\n                          return acc;\n                        },\n                        {},\n                      ),\n                    ),\n                  )\n                  .execute()\n                  .catch((_error) => {\n                    const error = _error as Error;\n                    common.logger.error({\n                      service: \"indexing\",\n                      msg: \"Internal error occurred while flushing cache. Please report this error here: https://github.com/ponder-sh/ponder/issues\",\n                    });\n                    throw new FlushError(error.message);\n                  });\n              });\n            }\n          }\n        }),\n      );\n\n      if (isFullFlush) {\n        for (const tableName of Object.keys(tables)) {\n          storeCache[tableName] = {};\n        }\n        cacheSize = 0;\n        cacheSizeBytes = 0;\n      } else {\n        for (const [tableName, tableStoreCache] of Object.entries(storeCache)) {\n          for (const [key, { opIndex }] of Object.entries(tableStoreCache)) {\n            if (opIndex < flushIndex) {\n              const bytes = storeCache[tableName]![key]!.bytes;\n              delete storeCache[tableName]![key];\n\n              cacheSize--;\n              cacheSizeBytes -= bytes;\n            }\n          }\n        }\n      }\n\n      isCacheExhaustive = false;\n    },\n  }).add;\n\n  const _findUnique = async ({\n    tableName,\n    id,\n  }: {\n    tableName: string;\n    id: UserId;\n  }) => {\n    const table = tables[tableName]!.table;\n\n    const encodedId = encodeValue({\n      value: id,\n      column: table.id,\n      encoding,\n    });\n\n    const record = await db\n      .withSchema(namespaceInfo.userNamespace)\n      .selectFrom(tableName)\n      .selectAll()\n      .where(\"id\", \"=\", encodedId)\n      .executeTakeFirst();\n\n    if (record === undefined) return null;\n\n    return decodeRecord({ record, table, encoding });\n  };\n\n  return {\n    findUnique: async ({\n      tableName,\n      id: _id,\n    }: {\n      tableName: string;\n      id: UserId;\n    }) => {\n      if (shouldFlush()) await flush({ isFullFlush: false });\n\n      return db.wrap({ method: `${tableName}.findUnique` }, async () => {\n        const id = structuredClone(_id);\n        const cacheKey = getCacheKey(id, tableName);\n\n        const cacheEntry = storeCache[tableName]![cacheKey];\n        if (cacheEntry !== undefined) {\n          cacheEntry.opIndex = totalCacheOps++;\n          return structuredClone(cacheEntry.record);\n        }\n\n        // At this point if cache is exhaustive, findUnique will always return null\n        const record = isCacheExhaustive\n          ? null\n          : await _findUnique({ tableName, id });\n\n        const bytes = getBytesSize(record);\n\n        // add \"find\" entry to cache\n        storeCache[tableName]![cacheKey] = {\n          type: \"find\",\n          opIndex: totalCacheOps++,\n          bytes,\n          record,\n        };\n\n        cacheSizeBytes += bytes;\n        cacheSize++;\n\n        return structuredClone(record);\n      });\n    },\n    findMany: async (arg: {\n      tableName: string;\n      where?: WhereInput<any>;\n      orderBy?: OrderByInput<any>;\n      before?: string | null;\n      after?: string | null;\n      limit?: number;\n    }) => {\n      await flush({ isFullFlush: true });\n      return readonlyStore.findMany(arg);\n    },\n    create: async ({\n      tableName,\n      id: _id,\n      data = {},\n    }: {\n      tableName: string;\n      id: UserId;\n      data?: Omit<UserRecord, \"id\">;\n    }) => {\n      if (shouldFlush()) await flush({ isFullFlush: false });\n\n      return db.wrap({ method: `${tableName}.create` }, async () => {\n        const id = structuredClone(_id);\n        const cacheKey = getCacheKey(id, tableName);\n\n        // Check cache truthiness, will be false if record is null.\n        if (storeCache[tableName]![cacheKey]?.record) {\n          throw new UniqueConstraintError(\n            `Unique constraint failed for '${tableName}.id'.`,\n          );\n        }\n\n        // copy user-land record\n        const record = structuredClone(data) as UserRecord;\n        record.id = id;\n\n        normalizeRecord(record, tableName);\n\n        validateRecord({ record, table: tables[tableName]!.table, schema });\n\n        const bytes = getBytesSize(record);\n\n        storeCache[tableName]![cacheKey] = {\n          type: \"insert\",\n          opIndex: totalCacheOps++,\n          bytes,\n          record,\n        };\n\n        cacheSizeBytes += bytes;\n        cacheSize++;\n\n        return structuredClone(record);\n      });\n    },\n    createMany: async ({\n      tableName,\n      data,\n    }: {\n      tableName: string;\n      data: UserRecord[];\n    }) => {\n      if (shouldFlush()) await flush({ isFullFlush: false });\n\n      return db.wrap({ method: `${tableName}.createMany` }, async () => {\n        for (const _record of data) {\n          const cacheKey = getCacheKey(_record.id, tableName);\n\n          // Check cache truthiness, will be false if record is null.\n          if (storeCache[tableName]![cacheKey]?.record) {\n            throw new UniqueConstraintError(\n              `Unique constraint failed for '${tableName}.id'.`,\n            );\n          }\n\n          // copy user-land record\n          const record = structuredClone(_record);\n\n          normalizeRecord(record, tableName);\n\n          validateRecord({ record, table: tables[tableName]!.table, schema });\n\n          const bytes = getBytesSize(record);\n\n          storeCache[tableName]![cacheKey] = {\n            type: \"insert\",\n            opIndex: totalCacheOps++,\n            bytes,\n            record,\n          };\n\n          cacheSizeBytes += bytes;\n        }\n\n        cacheSize += data.length;\n\n        const returnData = structuredClone(data);\n        for (const record of data) {\n          normalizeRecord(record, tableName);\n        }\n        return returnData;\n      });\n    },\n    update: async ({\n      tableName,\n      id: _id,\n      data = {},\n    }: {\n      tableName: string;\n      id: UserId;\n      data?:\n        | Partial<Omit<UserRecord, \"id\">>\n        | ((args: { current: UserRecord }) => Partial<Omit<UserRecord, \"id\">>);\n    }) => {\n      if (shouldFlush()) await flush({ isFullFlush: false });\n\n      return db.wrap({ method: `${tableName}.findUnique` }, async () => {\n        const id = structuredClone(_id);\n        const cacheKey = getCacheKey(id, tableName);\n\n        let cacheEntry = storeCache[tableName]![cacheKey];\n\n        if (cacheEntry === undefined) {\n          const record = isCacheExhaustive\n            ? null\n            : await _findUnique({ tableName, id });\n\n          if (record === null) {\n            throw new RecordNotFoundError(\n              \"No existing record was found with the specified ID\",\n            );\n          }\n\n          // Note: a \"spoof\" cache entry is created\n          cacheEntry = { type: \"update\", opIndex: 0, bytes: 0, record };\n\n          storeCache[tableName]![cacheKey] = cacheEntry;\n        } else {\n          if (cacheEntry.record === null) {\n            throw new RecordNotFoundError(\n              \"No existing record was found with the specified ID\",\n            );\n          }\n\n          if (cacheEntry.type === \"find\") {\n            // move cache entry to \"update\"\n            (cacheEntry.type as Entry[\"type\"]) = \"update\";\n          }\n        }\n\n        const update =\n          typeof data === \"function\"\n            ? data({ current: structuredClone(cacheEntry.record!) })\n            : data;\n\n        // copy user-land record\n        const record = cacheEntry.record!;\n        for (const [key, value] of Object.entries(structuredClone(update))) {\n          record[key] = value;\n        }\n\n        normalizeRecord(record, tableName);\n\n        validateRecord({ record, table: tables[tableName]!.table, schema });\n\n        const bytes = getBytesSize(record);\n\n        cacheEntry.record = record;\n        cacheEntry.opIndex = totalCacheOps++;\n        cacheEntry.bytes = bytes;\n\n        return structuredClone(record);\n      });\n    },\n    updateMany: async ({\n      tableName,\n      where,\n      data = {},\n    }: {\n      tableName: string;\n      where: WhereInput<any>;\n      data?:\n        | Partial<Omit<UserRecord, \"id\">>\n        | ((args: { current: UserRecord }) => Partial<Omit<UserRecord, \"id\">>);\n    }) => {\n      await flush({ isFullFlush: true });\n\n      const table = (schema[tableName] as { table: Table }).table;\n\n      if (typeof data === \"function\") {\n        const query = db\n          .withSchema(namespaceInfo.userNamespace)\n          .selectFrom(tableName)\n          .selectAll()\n          .where((eb) => buildWhereConditions({ eb, where, table, encoding }))\n          .orderBy(\"id\", \"asc\");\n\n        const records: UserRecord[] = [];\n        let cursor: DatabaseValue = null;\n\n        while (true) {\n          const _records = await db.wrap(\n            { method: `${tableName}.updateMany` },\n            async () => {\n              const latestRecords: DatabaseRecord[] = await query\n                .limit(common.options.databaseMaxRowLimit)\n                .$if(cursor !== null, (qb) => qb.where(\"id\", \">\", cursor))\n                .execute();\n\n              const records: DatabaseRecord[] = [];\n\n              for (const latestRecord of latestRecords) {\n                const current = decodeRecord({\n                  record: latestRecord,\n                  table,\n                  encoding,\n                });\n                const updateObject = data({ current });\n                // Here, `latestRecord` is already encoded, so we need to exclude it from `encodeRecord`.\n                const updateRecord = {\n                  id: latestRecord.id,\n                  ...encodeRecord({\n                    record: updateObject,\n                    table,\n                    schema,\n                    encoding,\n                    skipValidation: false,\n                  }),\n                };\n\n                const record = await db\n                  .withSchema(namespaceInfo.userNamespace)\n                  .updateTable(tableName)\n                  .set(updateRecord)\n                  .where(\"id\", \"=\", latestRecord.id)\n                  .returningAll()\n                  .executeTakeFirstOrThrow()\n                  .catch((err) => {\n                    throw parseStoreError(err, updateObject);\n                  });\n                records.push(record);\n              }\n\n              return records.map((record) =>\n                decodeRecord({ record, table, encoding }),\n              );\n            },\n          );\n\n          records.push(..._records);\n\n          if (_records.length === 0) {\n            break;\n          } else {\n            cursor = encodeValue({\n              value: _records[_records.length - 1]!.id,\n              column: table.id,\n              encoding,\n            });\n          }\n        }\n\n        return records;\n      } else {\n        return db.wrap({ method: `${tableName}.updateMany` }, async () => {\n          const updateRecord = encodeRecord({\n            record: data,\n            table,\n            schema,\n            encoding,\n            skipValidation: false,\n          });\n\n          const records = await db\n            .with(\"latestRows(id)\", (db) =>\n              db\n                .withSchema(namespaceInfo.userNamespace)\n                .selectFrom(tableName)\n                .select(\"id\")\n                .where((eb) =>\n                  buildWhereConditions({ eb, where, table, encoding }),\n                ),\n            )\n            .withSchema(namespaceInfo.userNamespace)\n            .updateTable(tableName)\n            .set(updateRecord)\n            .from(\"latestRows\")\n            .where(`${tableName}.id`, \"=\", sql.ref(\"latestRows.id\"))\n            .returningAll()\n            .execute()\n            .catch((err) => {\n              throw parseStoreError(err, data);\n            });\n\n          return records.map((record) =>\n            decodeRecord({ record, table, encoding }),\n          );\n        });\n      }\n    },\n    upsert: async ({\n      tableName,\n      id: _id,\n      create = {},\n      update = {},\n    }: {\n      tableName: string;\n      id: UserId;\n      create?: Omit<UserRecord, \"id\">;\n      update?:\n        | Partial<Omit<UserRecord, \"id\">>\n        | ((args: { current: UserRecord }) => Partial<Omit<UserRecord, \"id\">>);\n    }) => {\n      if (shouldFlush()) await flush({ isFullFlush: false });\n\n      return db.wrap({ method: `${tableName}.upsert` }, async () => {\n        const id = structuredClone(_id);\n        const cacheKey = getCacheKey(id, tableName);\n\n        let cacheEntry = storeCache[tableName]![cacheKey];\n\n        if (cacheEntry === undefined) {\n          if (isCacheExhaustive === false) {\n            const record = await _findUnique({ tableName, id });\n\n            if (record !== null) {\n              // Note: a \"spoof\" cache entry is created\n              cacheEntry = { type: \"update\", opIndex: 0, bytes: 0, record };\n              storeCache[tableName]![cacheKey] = cacheEntry;\n            }\n\n            // Note: an \"insert\" cache entry will be created if the record is null,\n            // so don't need to create it here.\n          }\n        } else {\n          if (cacheEntry.type === \"find\") {\n            if (cacheEntry.record === null) {\n              // cache entry will be moved to \"insert\"\n              (cacheEntry.type as Entry[\"type\"]) = \"insert\";\n            } else {\n              // move cache entry to \"update\"\n              (cacheEntry.type as Entry[\"type\"]) = \"update\";\n            }\n          }\n        }\n\n        // Check cache truthiness, will be false if record is null.\n        if (cacheEntry?.record) {\n          // update branch\n          const _update =\n            typeof update === \"function\"\n              ? update({ current: structuredClone(cacheEntry.record) })\n              : update;\n\n          // copy user-land record\n          const record = cacheEntry.record;\n          for (const [key, value] of Object.entries(structuredClone(_update))) {\n            record[key] = value;\n          }\n\n          normalizeRecord(record, tableName);\n\n          validateRecord({ record, table: tables[tableName]!.table, schema });\n\n          const bytes = getBytesSize(record);\n\n          cacheEntry.record = record;\n          cacheEntry.opIndex = totalCacheOps++;\n          cacheEntry.bytes = bytes;\n\n          return structuredClone(record);\n        } else {\n          // insert/create branch\n\n          // copy user-land record\n          const record = structuredClone(create) as UserRecord;\n          record.id = id;\n\n          normalizeRecord(record, tableName);\n\n          validateRecord({ record, table: tables[tableName]!.table, schema });\n\n          const bytes = getBytesSize(record);\n\n          storeCache[tableName]![cacheKey] = {\n            type: \"insert\",\n            opIndex: totalCacheOps++,\n            bytes,\n            record,\n          };\n\n          cacheSize++;\n          cacheSizeBytes += bytes;\n\n          return structuredClone(record);\n        }\n      });\n    },\n    delete: async ({\n      tableName,\n      id: _id,\n    }: {\n      tableName: string;\n      id: UserId;\n    }) => {\n      if (shouldFlush()) await flush({ isFullFlush: false });\n\n      return db.wrap({ method: `${tableName}.delete` }, async () => {\n        const id = structuredClone(_id);\n        const cacheKey = getCacheKey(id, tableName);\n\n        const cacheEntry = storeCache[tableName]![cacheKey];\n\n        if (cacheEntry !== undefined) {\n          // delete from cache\n          const bytes = cacheEntry.bytes;\n          delete storeCache[tableName]![cacheKey];\n          cacheSize--;\n          cacheSizeBytes -= bytes;\n        }\n\n        if (isCacheExhaustive || cacheEntry?.record === null) {\n          return false;\n        } else {\n          const table = (schema[tableName] as { table: Table }).table;\n\n          const deletedRecord = await db\n            .withSchema(namespaceInfo.userNamespace)\n            .deleteFrom(tableName)\n            .where(\n              \"id\",\n              \"=\",\n              encodeValue({ value: id, column: table.id, encoding }),\n            )\n            .returning([\"id\"])\n            .executeTakeFirst()\n            .catch((err) => {\n              throw parseStoreError(err, { id });\n            });\n\n          return !!deletedRecord;\n        }\n      });\n    },\n    flush,\n  };\n};\n\nconst getBytesSize = (value: UserRecord | UserValue) => {\n  // size of metadata\n  let size = 16;\n\n  if (typeof value === \"number\") {\n    // p.float, p.int\n    size += 8;\n  } else if (typeof value === \"string\") {\n    // p.hex, p.string, p.enum\n    size += 2 * value.length;\n  } else if (typeof value === \"boolean\") {\n    // p.boolean\n    size += 4;\n  } else if (typeof value === \"bigint\") {\n    // p.bigint\n    size += 48;\n  } else if (value === null || value === undefined) {\n    size += 8;\n  } else if (Array.isArray(value)) {\n    for (const e of value) {\n      size += getBytesSize(e);\n    }\n  } else {\n    for (const col of Object.values(value)) {\n      size += getBytesSize(col);\n    }\n  }\n\n  return size;\n};\n","import type { Hex } from \"viem\";\n\nexport const EVM_MAX_UINT =\n  115792089237316195423570985008687907853269984665640564039457584007913129639935n;\n\nexport const EVM_MIN_INT =\n  -57896044618658097711785492504343953926634992332820282019728792003956564819968n;\n\n/**\n * Converts a integer into a 33-byte Buffer (sign byte followed by 32-byte value).\n * Used as the storage encoding for EVM uint256 and int256 types to enable ordering\n * using SQLite's default BLOB collation (memcmp).\n *\n * @param value Integer to be encoded.\n * @returns 33-byte Buffer representing the encoded integer.\n */\nexport function encodeAsText(value: bigint | number | Hex) {\n  if (typeof value === \"string\" || typeof value === \"number\")\n    value = BigInt(value);\n\n  if (value > EVM_MAX_UINT)\n    throw new Error(`Value cannot be greater than EVM_MAX_UINT (${value})`);\n  if (value < EVM_MIN_INT)\n    throw new Error(`Value cannot be less than EVM_MIN_INT (${value})`);\n\n  const signChar = value >= 0n ? \"0\" : \"-\";\n\n  // If the value is negative, add the minimum integer to it.\n  if (value < 0n) value = value - EVM_MIN_INT;\n\n  const chars = value.toString(10);\n\n  // Pad the hex string with leading zeros and add the sign byte.\n  return signChar + chars.padStart(78, \"0\");\n}\n\n/**\n * Converts an encoded 33-byte Buffer (sign byte followed by 32-byte value) into a BigInt.\n * Used as the storage encoding for EVM uint256 and int256 types to enable ordering\n * using SQLite's default BLOB collation (memcmp).\n *\n * @param value Integer to be encoded.\n * @returns 33-byte Buffer representing the encoded integer.\n */\nexport function decodeToBigInt(text: string) {\n  if (typeof text === \"bigint\") return text;\n\n  const signChar = text.at(0);\n  let valueChars = text.substring(1).replace(/^0+/, \"\");\n  // If the value is 0, valueChars will be an empty string.\n  if (valueChars.length === 0) valueChars = \"0\";\n  let value = BigInt(valueChars);\n\n  // If the sign byte is negative, invert the value\n\n  if (signChar === \"-\") value = value + EVM_MIN_INT;\n\n  return value;\n}\n","export const never = (_x: never) => {\n  throw \"unreachable\";\n};\n","import {\n  BigIntSerializationError,\n  CheckConstraintError,\n  NotNullConstraintError,\n  StoreError,\n} from \"@/common/errors.js\";\nimport type {\n  Column,\n  EnumColumn,\n  JSONColumn,\n  MaterialColumn,\n  ReferenceColumn,\n  Scalar,\n  ScalarColumn,\n  Schema,\n  Table,\n} from \"@/schema/common.js\";\nimport {\n  getEnums,\n  isEnumColumn,\n  isJSONColumn,\n  isListColumn,\n  isManyColumn,\n  isMaterialColumn,\n  isOptionalColumn,\n  isReferenceColumn,\n  isScalarColumn,\n} from \"@/schema/utils.js\";\nimport type {\n  DatabaseRecord,\n  DatabaseValue,\n  UserRecord,\n  UserValue,\n} from \"@/types/schema.js\";\nimport { decodeToBigInt, encodeAsText } from \"@/utils/encoding.js\";\nimport { never } from \"@/utils/never.js\";\nimport { type Hex, bytesToHex, hexToBytes, isHex } from \"viem\";\n\nconst scalarToTsType = {\n  int: \"number\",\n  float: \"number\",\n  bigint: \"bigint\",\n  boolean: \"boolean\",\n  string: \"string\",\n  hex: \"`0x${string}`\",\n} as const satisfies { [key in Scalar]: string };\n\n/**\n * Convert a user-land record into a database-ready object.\n */\nexport function encodeRecord({\n  record,\n  table,\n  schema,\n  encoding,\n  skipValidation,\n}: {\n  record: Partial<UserRecord>;\n  table: Table;\n  schema: Schema;\n  encoding: \"sqlite\" | \"postgres\";\n  skipValidation: boolean;\n}): DatabaseRecord {\n  const instance: DatabaseRecord = {};\n\n  if (skipValidation === false) validateRecord({ record, table, schema });\n\n  // user data is considered to be valid at this point\n  for (const [columnName, value] of Object.entries(record)) {\n    const column = table[columnName] as MaterialColumn;\n\n    instance[columnName] = encodeValue({\n      value,\n      column,\n      encoding,\n    });\n  }\n\n  return instance;\n}\n\n/**\n * Convert a user-land value into a database-ready value.\n */\nexport function encodeValue(\n  {\n    value,\n    column,\n    encoding,\n  }: {\n    value: UserValue;\n    column: MaterialColumn;\n    encoding: \"sqlite\" | \"postgres\";\n  },\n  // @ts-ignore\n): DatabaseValue {\n  switch (column[\" type\"]) {\n    case \"enum\": {\n      if (isOptionalColumn(column) && (value === undefined || value === null)) {\n        return null;\n      }\n\n      if (isListColumn(column)) {\n        return JSON.stringify(value);\n      }\n\n      return value as string;\n    }\n\n    case \"json\": {\n      if (encoding === \"postgres\") return value as Object;\n      return JSON.stringify(value);\n    }\n\n    case \"reference\":\n    case \"scalar\": {\n      if (isOptionalColumn(column) && (value === undefined || value === null)) {\n        return null;\n      }\n\n      if (isListColumn(column)) {\n        if (column[\" scalar\"] === \"bigint\") {\n          return JSON.stringify((value as bigint[]).map(String));\n        } else if (column[\" scalar\"] === \"hex\") {\n          return JSON.stringify(\n            (value as string[]).map((v) => (v as string).toLowerCase()),\n          );\n        } else {\n          return JSON.stringify(value);\n        }\n      }\n\n      switch (column[\" scalar\"]) {\n        case \"string\":\n        case \"int\":\n        case \"float\":\n          return value as DatabaseValue;\n        case \"hex\":\n          return Buffer.from(hexToBytes(value as Hex));\n        case \"bigint\":\n          return encoding === \"sqlite\"\n            ? encodeAsText(value as bigint)\n            : (value as bigint);\n        case \"boolean\":\n          return value ? 1 : 0;\n\n        default:\n          never(column[\" scalar\"]);\n      }\n\n      break;\n    }\n\n    default:\n      never(column);\n  }\n}\n\nexport function validateRecord({\n  record,\n  table,\n  schema,\n}: {\n  record: Partial<UserRecord>;\n  table: Table;\n  schema: Schema;\n}): void {\n  for (const [columnName, value] of Object.entries(record)) {\n    const column = table[columnName];\n    if (!column) {\n      throw new StoreError(\n        `Invalid record: Column does not exist. Got ${columnName}, expected one of [${Object.keys(\n          table,\n        )\n          .filter(\n            (column) =>\n              isScalarColumn(table[column]!) ||\n              isReferenceColumn(table[column]!) ||\n              isEnumColumn(table[column]!) ||\n              isJSONColumn(table[column]!),\n          )\n          .join(\", \")}]`,\n      );\n    }\n\n    validateValue({ value, column, schema });\n  }\n}\n\nfunction validateValue({\n  value,\n  column,\n  schema,\n}: {\n  value: UserValue;\n  column: Column;\n  schema: Schema;\n}): void {\n  switch (column[\" type\"]) {\n    case \"enum\": {\n      if (isOptionalColumn(column) && (value === undefined || value === null)) {\n        break;\n      }\n\n      if (isListColumn(column)) {\n        if (!Array.isArray(value)) {\n          throw new StoreError(\n            `Unable to encode ${value} as a list. Got type '${typeof value}' but expected type 'string[]'.`,\n          );\n        }\n      } else if (typeof value !== \"string\") {\n        throw new StoreError(\n          `Unable to encode ${value} as an enum. Got type '${typeof value}' but expected type 'string'.`,\n        );\n      } else {\n        if (getEnums(schema)[column[\" enum\"]]!.includes(value) === false) {\n          throw new CheckConstraintError(\n            `Unable to encode ${value} as a '${\n              column[\" enum\"]\n            }' enum. Got '${value}' but expected one of [${getEnums(schema)[\n              column[\" enum\"]\n            ]!.join(\", \")}].`,\n          );\n        }\n      }\n\n      break;\n    }\n\n    case \"json\": {\n      try {\n        JSON.stringify(value);\n      } catch (_error) {\n        const error = new BigIntSerializationError(\n          (_error as TypeError).message,\n        );\n        error.meta.push(\n          \"Hint:\\n  The JSON column type does not support BigInt values. Use the replaceBigInts() helper function before inserting into the database. Docs: https://ponder.sh/docs/utilities/replace-bigints\",\n        );\n        throw error;\n      }\n\n      break;\n    }\n\n    case \"reference\":\n    case \"scalar\": {\n      if (value === undefined || value === null) {\n        if (isOptionalColumn(column)) break;\n        const error = new NotNullConstraintError(\n          `Unable to encode ${value} as a ${\n            column[\" scalar\"]\n          }. Got '${typeof value}' but expected type '${scalarToTsType[column[\" scalar\"]]}'.`,\n        );\n        error.meta.push(\n          \"Hint:\\n  Use the .optional() modifier to allow for null or undefined values.\",\n        );\n        throw error;\n      }\n\n      if (isListColumn(column)) {\n        // Note: We are not checking the types of the list elements.\n        if (!Array.isArray(value)) {\n          throw new StoreError(\n            `Unable to encode ${value} as a list. Got type '${typeof value}' but expected type '${\n              scalarToTsType[column[\" scalar\"]]\n            }[]'.`,\n          );\n        }\n\n        break;\n      }\n\n      switch (column[\" scalar\"]) {\n        case \"string\": {\n          if (typeof value !== \"string\") {\n            throw new StoreError(\n              `Unable to encode ${value} as a string. Got type '${typeof value}' but expected type 'string'.`,\n            );\n          }\n          break;\n        }\n        case \"hex\": {\n          if (typeof value !== \"string\" || !isHex(value)) {\n            throw new StoreError(\n              `Unable to encode ${value} as a hex. Got type '${typeof value}' but expected type '\\`0x\\${string}\\`'.`,\n            );\n          }\n          break;\n        }\n\n        case \"int\":\n        case \"float\": {\n          if (typeof value !== \"number\") {\n            throw new StoreError(\n              `Unable to encode ${value} as an ${\n                column[\" scalar\"]\n              }. Got type '${typeof value}' but expected type 'number'.`,\n            );\n          }\n          break;\n        }\n\n        case \"bigint\": {\n          if (typeof value !== \"bigint\") {\n            throw new StoreError(\n              `Unable to encode ${value} as a bigint. Got type '${typeof value}' but expected type 'bigint'.`,\n            );\n          }\n          break;\n        }\n\n        case \"boolean\": {\n          if (typeof value !== \"boolean\") {\n            throw new StoreError(\n              `Unable to encode ${value} as a boolean. Got type '${typeof value}' but expected type 'boolean'.`,\n            );\n          }\n          break;\n        }\n\n        default:\n          never(column[\" scalar\"]);\n      }\n\n      break;\n    }\n\n    case \"one\":\n    case \"many\": {\n      throw new StoreError(\n        `Unable to encode ${value} into a \"${isManyColumn(column) ? \"many\" : \"one\"}\" column. \"${\n          isManyColumn(column) ? \"many\" : \"one\"\n        }\" columns are virtual and therefore should not be given a value.`,\n      );\n    }\n\n    default:\n      never(column);\n  }\n}\n\nexport function decodeRecord({\n  record,\n  table,\n  encoding,\n}: {\n  record: DatabaseRecord;\n  table: Table;\n  encoding: \"sqlite\" | \"postgres\";\n}): UserRecord {\n  const instance = {} as UserRecord;\n\n  for (const [columnName, column] of Object.entries(table)) {\n    if (isMaterialColumn(column)) {\n      instance[columnName] = decodeValue({\n        value: record[columnName]!,\n        column,\n        encoding,\n      });\n    }\n  }\n\n  return instance;\n}\n\nfunction decodeValue({\n  value,\n  column,\n  encoding,\n}: {\n  value: DatabaseValue;\n  column: ScalarColumn | ReferenceColumn | EnumColumn | JSONColumn;\n  encoding: \"sqlite\" | \"postgres\";\n}): UserValue {\n  if (value === null) return null;\n  else if (isEnumColumn(column)) {\n    if (isListColumn(column)) {\n      return JSON.parse(value as string);\n    }\n    return value as UserValue;\n  } else if (isJSONColumn(column)) {\n    return encoding === \"postgres\" ? value : JSON.parse(value as string);\n  } else if (isListColumn(column)) {\n    return column[\" scalar\"] === \"bigint\"\n      ? JSON.parse(value as string).map(BigInt)\n      : JSON.parse(value as string);\n  } else if (column[\" scalar\"] === \"boolean\") {\n    return value === 1;\n  } else if (column[\" scalar\"] === \"hex\") {\n    return bytesToHex(value as Buffer);\n  } else if (column[\" scalar\"] === \"bigint\" && encoding === \"sqlite\") {\n    return decodeToBigInt(value as string);\n  } else {\n    return value as UserValue;\n  }\n}\n","import {\n  BigIntSerializationError,\n  CheckConstraintError,\n  NotNullConstraintError,\n  RecordNotFoundError,\n  UniqueConstraintError,\n  getBaseError,\n} from \"@/common/errors.js\";\nimport { prettyPrint } from \"@/utils/print.js\";\n\nexport function parseStoreError(err: unknown, args: Record<string, unknown>) {\n  let error = getBaseError(err);\n\n  if (error.message?.includes(\"no result\")) {\n    error = new RecordNotFoundError(\n      \"No existing record was found with the specified ID\",\n    );\n  } else if (\n    error.message?.includes(\"UNIQUE constraint failed\") ||\n    error.message?.includes(\"violates unique constraint\")\n  ) {\n    error = new UniqueConstraintError(error.message);\n    error.meta.push(\n      \"Hints:\\n  Did you forget to await the promise returned by a store method?\\n  Did you mean to do an upsert?\",\n    );\n  } else if (\n    error.message?.includes(\"NOT NULL constraint failed\") ||\n    error.message?.includes(\"violates not-null constraint\")\n  ) {\n    error = new NotNullConstraintError(error.message);\n  } else if (\n    error.message?.includes(\"CHECK constraint failed\") ||\n    error.message?.includes(\"violates check constraint\")\n  ) {\n    error = new CheckConstraintError(error.message);\n  } else if (error.message?.includes(\"Do not know how to serialize a BigInt\")) {\n    error = new BigIntSerializationError(error.message);\n    error.meta.push(\n      \"Hint:\\n  The JSON column type does not support BigInt values. Use the replaceBigInts() helper function before inserting into the database. Docs: https://ponder.sh/docs/utilities/replace-bigints\",\n    );\n  }\n\n  error.meta.push(`Store method arguments:\\n${prettyPrint(args)}`);\n\n  return error;\n}\n","import { StoreError } from \"@/common/errors.js\";\nimport type { ScalarColumn, Table } from \"@/schema/common.js\";\nimport {\n  isEnumColumn,\n  isJSONColumn,\n  isListColumn,\n  isManyColumn,\n  isOneColumn,\n  isReferenceColumn,\n  isScalarColumn,\n} from \"@/schema/utils.js\";\nimport type {\n  ComparisonOperatorExpression,\n  ExpressionBuilder,\n  ExpressionWrapper,\n} from \"kysely\";\nimport { encodeValue } from \"./encoding.js\";\n\nconst filterValidityMap = {\n  boolean: {\n    singular: [\"equals\", \"not\", \"in\", \"notIn\"],\n    list: [\"equals\", \"not\", \"has\", \"notHas\"],\n  },\n  string: {\n    singular: [\n      \"equals\",\n      \"not\",\n      \"in\",\n      \"notIn\",\n      \"contains\",\n      \"notContains\",\n      \"startsWith\",\n      \"notStartsWith\",\n      \"endsWith\",\n      \"notEndsWith\",\n    ],\n    list: [\"equals\", \"not\", \"has\", \"notHas\"],\n  },\n  hex: {\n    singular: [\"equals\", \"not\", \"in\", \"notIn\", \"gt\", \"lt\", \"gte\", \"lte\"],\n    list: [\"equals\", \"not\", \"has\", \"notHas\"],\n  },\n  int: {\n    singular: [\"equals\", \"not\", \"in\", \"notIn\", \"gt\", \"lt\", \"gte\", \"lte\"],\n    list: [\"equals\", \"not\", \"has\", \"notHas\"],\n  },\n  bigint: {\n    singular: [\"equals\", \"not\", \"in\", \"notIn\", \"gt\", \"lt\", \"gte\", \"lte\"],\n    list: [\"equals\", \"not\", \"has\", \"notHas\"],\n  },\n  float: {\n    singular: [\"equals\", \"not\", \"in\", \"notIn\", \"gt\", \"lt\", \"gte\", \"lte\"],\n    list: [\"equals\", \"not\", \"has\", \"notHas\"],\n  },\n};\n\nconst filterEncodingMap: {\n  [condition: string]: (\n    value: any,\n    encode: (v: any) => any,\n  ) => [comparator: ComparisonOperatorExpression, value: any];\n} = {\n  // Universal\n  equals: (value, encode) =>\n    value === null ? [\"is\", null] : [\"=\", encode(value)],\n  not: (value, encode) =>\n    value === null ? [\"is not\", null] : [\"!=\", encode(value)],\n  // Singular\n  in: (value, encode) => [\"in\", value.map(encode)],\n  notIn: (value, encode) => [\"not in\", value.map(encode)],\n  // Plural/list\n  has: (value, encode) => [\"like\", `%${encode(value)}%`],\n  notHas: (value, encode) => [\"not like\", `%${encode(value)}%`],\n  // Numeric\n  gt: (value, encode) => [\">\", encode(value)],\n  lt: (value, encode) => [\"<\", encode(value)],\n  gte: (value, encode) => [\">=\", encode(value)],\n  lte: (value, encode) => [\"<=\", encode(value)],\n  // String\n  contains: (value, encode) => [\"like\", `%${encode(value)}%`],\n  notContains: (value, encode) => [\"not like\", `%${encode(value)}%`],\n  startsWith: (value, encode) => [\"like\", `${encode(value)}%`],\n  notStartsWith: (value, encode) => [\"not like\", `${encode(value)}%`],\n  endsWith: (value, encode) => [\"like\", `%${encode(value)}`],\n  notEndsWith: (value, encode) => [\"not like\", `%${encode(value)}`],\n} as const;\n\nexport function buildWhereConditions({\n  eb,\n  where,\n  table,\n  encoding,\n}: {\n  eb: ExpressionBuilder<any, string>;\n  where: Record<string, any>;\n  table: Table;\n  encoding: \"sqlite\" | \"postgres\";\n}) {\n  const exprs: ExpressionWrapper<any, string, any>[] = [];\n\n  for (const [columnName, rhs] of Object.entries(where)) {\n    if (columnName === \"AND\" || columnName === \"OR\") {\n      if (!Array.isArray(rhs)) {\n        throw new StoreError(\n          `Invalid filter. Expected an array for logical operator '${columnName}', got '${rhs}'.`,\n        );\n      }\n\n      const nestedExprs = rhs.map((nestedWhere) =>\n        buildWhereConditions({ eb, where: nestedWhere, table, encoding }),\n      );\n\n      exprs.push(eb[columnName === \"AND\" ? \"and\" : \"or\"](nestedExprs));\n      continue;\n    }\n\n    const column = table[columnName];\n\n    if (!column) {\n      throw new StoreError(\n        `Invalid filter. Column does not exist. Got '${columnName}', expected one of [${Object.keys(\n          table,\n        )\n          .filter(\n            (columnName) =>\n              isScalarColumn(table[columnName]!) ||\n              isReferenceColumn(table[columnName]!) ||\n              isEnumColumn(table[columnName]!) ||\n              isJSONColumn(table[columnName]!),\n          )\n          .map((c) => `'${c}'`)\n          .join(\", \")}]`,\n      );\n    }\n\n    if (isOneColumn(column) || isManyColumn(column)) {\n      throw new StoreError(\n        `Invalid filter. Cannot filter on virtual column '${columnName}'.`,\n      );\n    }\n\n    if (isJSONColumn(column)) {\n      throw new StoreError(\n        `Invalid filter. Cannot filter on json column '${columnName}'.`,\n      );\n    }\n\n    // Handle the shortcut case for `equals`, e.g. { user: \"abc\" }.\n    const conditionsForColumn =\n      Array.isArray(rhs) || typeof rhs !== \"object\" ? { equals: rhs } : rhs;\n\n    for (const [condition, value] of Object.entries(conditionsForColumn)) {\n      const filterType = isEnumColumn(column) ? \"string\" : column[\" scalar\"];\n\n      const allowedConditions =\n        filterValidityMap[filterType]?.[\n          isListColumn(column) ? \"list\" : \"singular\"\n        ];\n      if (!allowedConditions.includes(condition)) {\n        throw new StoreError(\n          `Invalid filter condition for column '${columnName}'. Got '${condition}', expected one of [${allowedConditions\n            .map((c) => `'${c}'`)\n            .join(\", \")}]`,\n        );\n      }\n\n      const filterEncodingFn = filterEncodingMap[condition];\n\n      // Handle special case for list column types `has` and `notHas`.\n      // We need to use the singular encoding function for the arguments.\n      const encode = (v: any) => {\n        const isListCondition =\n          isListColumn(column) &&\n          (condition === \"has\" || condition === \"notHas\");\n\n        if (isListCondition) {\n          // Must encode the value the same way that it is encoded as a list in\n          // `encodeValue`.\n          if ((column as ScalarColumn)[\" scalar\"] === \"bigint\") {\n            return String(v as bigint);\n          } else if ((column as ScalarColumn)[\" scalar\"] === \"hex\") {\n            return (v as string).toLowerCase();\n          }\n          return v;\n        }\n        return encodeValue({ value: v, column, encoding });\n      };\n\n      const [comparator, encodedValue] = filterEncodingFn!(value, encode);\n      exprs.push(eb.eb(columnName, comparator, encodedValue));\n    }\n  }\n\n  return eb.and(exprs);\n}\n","import type { HeadlessKysely } from \"@/database/kysely.js\";\nimport type { NamespaceInfo } from \"@/database/service.js\";\nimport type { MetadataStore, Status } from \"./store.js\";\n\nexport const getMetadataStore = ({\n  encoding,\n  namespaceInfo,\n  db,\n}: {\n  encoding: \"sqlite\" | \"postgres\";\n  namespaceInfo: Pick<NamespaceInfo, \"userNamespace\">;\n  db: HeadlessKysely<any>;\n}): MetadataStore => ({\n  getStatus: async () => {\n    return db.wrap({ method: \"_ponder_meta.getStatus()\" }, async () => {\n      const metadata = await db\n        .withSchema(namespaceInfo.userNamespace)\n        .selectFrom(\"_ponder_meta\")\n        .select(\"value\")\n        .where(\"key\", \"=\", \"status\")\n        .executeTakeFirst();\n\n      if (metadata!.value === null) return null;\n\n      return encoding === \"sqlite\"\n        ? (JSON.parse(metadata!.value) as Status)\n        : (metadata!.value as Status);\n    });\n  },\n  setStatus: (status: Status) => {\n    return db.wrap({ method: \"_ponder_meta.setStatus()\" }, async () => {\n      await db\n        .withSchema(namespaceInfo.userNamespace)\n        .insertInto(\"_ponder_meta\")\n        .values({\n          key: \"status\",\n          value: encoding === \"sqlite\" ? JSON.stringify(status) : status,\n        })\n        .onConflict((oc) =>\n          oc.column(\"key\").doUpdateSet({\n            value: encoding === \"sqlite\" ? JSON.stringify(status) : status,\n          }),\n        )\n        .execute();\n    });\n  },\n});\n","import type { Common } from \"@/common/common.js\";\nimport { StoreError } from \"@/common/errors.js\";\nimport type { HeadlessKysely } from \"@/database/kysely.js\";\nimport type { NamespaceInfo } from \"@/database/service.js\";\nimport type { MaterialColumn, Schema, Table } from \"@/schema/common.js\";\nimport type { UserId } from \"@/types/schema.js\";\nimport { sql } from \"kysely\";\nimport type { OrderByInput, ReadonlyStore, WhereInput } from \"./store.js\";\nimport {\n  buildCursorConditions,\n  decodeCursor,\n  encodeCursor,\n} from \"./utils/cursor.js\";\nimport { decodeRecord, encodeValue } from \"./utils/encoding.js\";\nimport { buildWhereConditions } from \"./utils/filter.js\";\nimport {\n  buildOrderByConditions,\n  reverseOrderByConditions,\n} from \"./utils/sort.js\";\n\nconst DEFAULT_LIMIT = 50 as const;\n\nexport const getReadonlyStore = ({\n  encoding,\n  schema,\n  namespaceInfo,\n  db,\n  common,\n}: {\n  encoding: \"sqlite\" | \"postgres\";\n  schema: Schema;\n  namespaceInfo: Pick<NamespaceInfo, \"userNamespace\">;\n  db: HeadlessKysely<any>;\n  common: Common;\n}): ReadonlyStore => ({\n  findUnique: async ({\n    tableName,\n    id,\n  }: {\n    tableName: string;\n    id: UserId;\n  }) => {\n    const table = (schema[tableName] as { table: Table }).table;\n\n    return db.wrap({ method: `${tableName}.findUnique` }, async () => {\n      const encodedId = encodeValue({\n        value: id,\n        column: table.id,\n        encoding,\n      });\n\n      const record = await db\n        .withSchema(namespaceInfo.userNamespace)\n        .selectFrom(tableName)\n        .selectAll()\n        .where(\"id\", \"=\", encodedId)\n        .executeTakeFirst();\n\n      if (record === undefined) return null;\n\n      return decodeRecord({ record, table, encoding });\n    });\n  },\n  findMany: async ({\n    tableName,\n    where,\n    orderBy,\n    before = null,\n    after = null,\n    limit = DEFAULT_LIMIT,\n  }: {\n    tableName: string;\n    where?: WhereInput<any>;\n    orderBy?: OrderByInput<any>;\n    before?: string | null;\n    after?: string | null;\n    limit?: number;\n  }) => {\n    const table = (schema[tableName] as { table: Table }).table;\n\n    return db.wrap({ method: `${tableName}.findMany` }, async () => {\n      let query = db\n        .withSchema(namespaceInfo.userNamespace)\n        .selectFrom(tableName)\n        .selectAll();\n\n      if (where) {\n        query = query.where((eb) =>\n          buildWhereConditions({ eb, where, table, encoding }),\n        );\n      }\n\n      const orderByConditions = buildOrderByConditions({ orderBy, table });\n      for (const [column, direction] of orderByConditions) {\n        query = query.orderBy(\n          column,\n          encoding === \"sqlite\"\n            ? direction\n            : direction === \"asc\"\n              ? sql`asc nulls first`\n              : sql`desc nulls last`,\n        );\n      }\n      const orderDirection = orderByConditions[0]![1];\n\n      if (limit > common.options.databaseMaxRowLimit) {\n        throw new StoreError(\n          `Invalid limit. Got ${limit}, expected <=${common.options.databaseMaxRowLimit}.`,\n        );\n      }\n\n      if (after !== null && before !== null) {\n        throw new StoreError(\"Cannot specify both before and after cursors.\");\n      }\n\n      let startCursor = null;\n      let endCursor = null;\n      let hasPreviousPage = false;\n      let hasNextPage = false;\n\n      // Neither cursors are specified, apply the order conditions and execute.\n      if (after === null && before === null) {\n        query = query.limit(limit + 1);\n        const records = await query\n          .execute()\n          .then((records) =>\n            records.map((record) => decodeRecord({ record, table, encoding })),\n          );\n\n        if (records.length === limit + 1) {\n          records.pop();\n          hasNextPage = true;\n        }\n\n        startCursor =\n          records.length > 0\n            ? encodeCursor(records[0]!, orderByConditions)\n            : null;\n        endCursor =\n          records.length > 0\n            ? encodeCursor(records[records.length - 1]!, orderByConditions)\n            : null;\n\n        return {\n          items: records,\n          pageInfo: { hasNextPage, hasPreviousPage, startCursor, endCursor },\n        };\n      }\n\n      if (after !== null) {\n        // User specified an 'after' cursor.\n        const rawCursorValues = decodeCursor(after, orderByConditions);\n        const cursorValues = rawCursorValues.map(([columnName, value]) => [\n          columnName,\n          encodeValue({\n            value,\n            column: table[columnName] as MaterialColumn,\n            encoding,\n          }),\n        ]) satisfies [string, any][];\n        query = query\n          .where((eb) =>\n            buildCursorConditions(cursorValues, \"after\", orderDirection, eb),\n          )\n          .limit(limit + 2);\n\n        const records = await query\n          .execute()\n          .then((records) =>\n            records.map((record) => decodeRecord({ record, table, encoding })),\n          );\n\n        if (records.length === 0) {\n          return {\n            items: records,\n            pageInfo: {\n              hasNextPage,\n              hasPreviousPage,\n              startCursor,\n              endCursor,\n            },\n          };\n        }\n\n        // If the cursor of the first returned record equals the `after` cursor,\n        // `hasPreviousPage` is true. Remove that record.\n        if (encodeCursor(records[0]!, orderByConditions) === after) {\n          records.shift();\n          hasPreviousPage = true;\n        } else {\n          // Otherwise, remove the last record.\n          records.pop();\n        }\n\n        // Now if the length of the records is still equal to limit + 1,\n        // there is a next page.\n        if (records.length === limit + 1) {\n          records.pop();\n          hasNextPage = true;\n        }\n\n        // Now calculate the cursors.\n        startCursor =\n          records.length > 0\n            ? encodeCursor(records[0]!, orderByConditions)\n            : null;\n        endCursor =\n          records.length > 0\n            ? encodeCursor(records[records.length - 1]!, orderByConditions)\n            : null;\n\n        return {\n          items: records,\n          pageInfo: { hasNextPage, hasPreviousPage, startCursor, endCursor },\n        };\n      } else {\n        // User specified a 'before' cursor.\n        const rawCursorValues = decodeCursor(before!, orderByConditions);\n        const cursorValues = rawCursorValues.map(([columnName, value]) => [\n          columnName,\n          encodeValue({\n            value,\n            column: table[columnName] as MaterialColumn,\n            encoding,\n          }),\n        ]) satisfies [string, any][];\n        query = query\n          .where((eb) =>\n            buildCursorConditions(cursorValues, \"before\", orderDirection, eb),\n          )\n          .limit(limit + 2);\n\n        // Reverse the order by conditions to get the previous page.\n        query = query.clearOrderBy();\n        const reversedOrderByConditions =\n          reverseOrderByConditions(orderByConditions);\n        for (const [column, direction] of reversedOrderByConditions) {\n          query = query.orderBy(column, direction);\n        }\n\n        const records = await query.execute().then((records) =>\n          records\n            .map((record) => decodeRecord({ record, table, encoding }))\n            // Reverse the records again, back to the original order.\n            .reverse(),\n        );\n\n        if (records.length === 0) {\n          return {\n            items: records,\n            pageInfo: {\n              hasNextPage,\n              hasPreviousPage,\n              startCursor,\n              endCursor,\n            },\n          };\n        }\n\n        // If the cursor of the last returned record equals the `before` cursor,\n        // `hasNextPage` is true. Remove that record.\n        if (\n          encodeCursor(records[records.length - 1]!, orderByConditions) ===\n          before\n        ) {\n          records.pop();\n          hasNextPage = true;\n        } else {\n          // Otherwise, remove the first record.\n          records.shift();\n        }\n\n        // Now if the length of the records is equal to limit + 1, we know\n        // there is a previous page.\n        if (records.length === limit + 1) {\n          records.shift();\n          hasPreviousPage = true;\n        }\n\n        // Now calculate the cursors.\n        startCursor =\n          records.length > 0\n            ? encodeCursor(records[0]!, orderByConditions)\n            : null;\n        endCursor =\n          records.length > 0\n            ? encodeCursor(records[records.length - 1]!, orderByConditions)\n            : null;\n\n        return {\n          items: records,\n          pageInfo: { hasNextPage, hasPreviousPage, startCursor, endCursor },\n        };\n      }\n    });\n  },\n});\n","/**\n * Serialize function that handles BigInt.\n *\n * Forked from https://github.com/wevm/wagmi\n *\n * @param value to stringify\n * @returns the stringified output\n */\nexport function serialize(value: any) {\n  return JSON.stringify(value, (_, v) =>\n    typeof v === \"bigint\" ? { __type: \"bigint\", value: v.toString() } : v,\n  );\n}\n\n/**\n * Deserialize function that handles BigInt.\n *\n * Forked from https://github.com/wevm/wagmi\n *\n * @param value to parse\n * @returns the output object\n */\nexport function deserialize<type>(value: string): type {\n  return JSON.parse(value, (_, value_) =>\n    value_?.__type === \"bigint\" ? BigInt(value_.value) : value_,\n  );\n}\n","import { StoreError } from \"@/common/errors.js\";\nimport type { UserRecord } from \"@/types/schema.js\";\nimport { deserialize, serialize } from \"@/utils/serialize.js\";\nimport type { ExpressionBuilder } from \"kysely\";\nimport type { OrderByConditions } from \"./sort.js\";\n\nexport function encodeCursor(\n  record: UserRecord,\n  orderByConditions: OrderByConditions,\n) {\n  const cursorValues = orderByConditions.map(([columnName]) => [\n    columnName,\n    record[columnName],\n  ]);\n\n  return Buffer.from(serialize(cursorValues)).toString(\"base64\");\n}\n\nexport function decodeCursor(\n  cursor: string,\n  orderByConditions: OrderByConditions,\n) {\n  const cursorValues = deserialize<[string, any][]>(\n    Buffer.from(cursor, \"base64\").toString(),\n  );\n\n  // Validate cursor values against order by conditions.\n  if (cursorValues.length !== orderByConditions.length) {\n    throw new StoreError(\n      `Invalid cursor. Got ${cursorValues.length}, ${orderByConditions.length} conditions`,\n    );\n  }\n\n  for (const [index, [columnName]] of orderByConditions.entries()) {\n    if (cursorValues[index]![0] !== columnName) {\n      throw new StoreError(\n        `Invalid cursor. Got column '${\n          cursorValues[index]![0]\n        }' at index ${index}, expected '${columnName}'.`,\n      );\n    }\n  }\n\n  return cursorValues;\n}\n\nexport function buildCursorConditions(\n  cursorValues: [string, any][],\n  kind: \"after\" | \"before\",\n  direction: \"asc\" | \"desc\",\n  eb: ExpressionBuilder<any, any>,\n) {\n  const comparator =\n    kind === \"after\"\n      ? direction === \"asc\"\n        ? \">\" // after, asc\n        : \"<\" // after, desc\n      : direction === \"asc\"\n        ? \"<\" // before, asc\n        : \">\"; // before, desc\n  const comparatorOrEquals = `${comparator}=` as const;\n\n  if (cursorValues.length === 1) {\n    const [columnName, value] = cursorValues[0]!;\n    return eb.eb(columnName, comparatorOrEquals, value);\n  } else if (cursorValues.length === 2) {\n    const [columnName1, value1] = cursorValues[0]!;\n    const [columnName2, value2] = cursorValues[1]!;\n\n    return eb.or([\n      eb.eb(columnName1, comparator, value1),\n      eb.and([\n        eb.eb(columnName1, \"=\", value1),\n        eb.eb(columnName2, comparatorOrEquals, value2),\n      ]),\n    ]);\n  } else {\n    throw new StoreError(\n      `Invalid cursor. Got ${cursorValues.length} value pairs, expected 1 or 2.`,\n    );\n  }\n}\n","import { StoreError } from \"@/common/errors.js\";\nimport type { Table } from \"@/schema/common.js\";\nimport {\n  isEnumColumn,\n  isJSONColumn,\n  isManyColumn,\n  isOneColumn,\n  isReferenceColumn,\n  isScalarColumn,\n} from \"@/schema/utils.js\";\nimport type { OrderByInput } from \"../store.js\";\n\nexport type OrderByConditions = [\n  columnName: string,\n  direction: \"asc\" | \"desc\",\n][];\n\nexport function buildOrderByConditions({\n  orderBy,\n  table,\n}: {\n  orderBy: OrderByInput<any> | undefined;\n  table: Table;\n}): OrderByConditions {\n  if (!orderBy) {\n    return [[\"id\", \"asc\"]];\n  }\n\n  const conditions = Object.entries(orderBy);\n  if (conditions.length > 1)\n    throw new StoreError(\"Invalid sort. Cannot sort by multiple columns.\");\n\n  const [columnName, orderDirection] = conditions[0]!;\n\n  // Validate column name.\n  const column = table[columnName];\n  if (!column) {\n    throw new StoreError(\n      `Invalid sort. Column does not exist. Got '${columnName}', expected one of [${Object.keys(\n        table,\n      )\n        .filter(\n          (columnName) =>\n            isScalarColumn(table[columnName]!) ||\n            isReferenceColumn(table[columnName]!) ||\n            isEnumColumn(table[columnName]!) ||\n            isJSONColumn(table[columnName]!),\n        )\n        .map((c) => `'${c}'`)\n        .join(\", \")}]`,\n    );\n  }\n  if (isOneColumn(column) || isManyColumn(column)) {\n    throw new StoreError(\n      `Invalid sort. Cannot sort on virtual column '${columnName}'.`,\n    );\n  }\n\n  if (isJSONColumn(column)) {\n    throw new StoreError(\n      `Invalid sort. Cannot sort on json column '${columnName}'.`,\n    );\n  }\n\n  if (orderDirection === undefined || ![\"asc\", \"desc\"].includes(orderDirection))\n    throw new StoreError(\n      `Invalid sort direction. Got '${orderDirection}', expected 'asc' or 'desc'.`,\n    );\n\n  const orderByConditions: OrderByConditions = [[columnName, orderDirection]];\n\n  // If the specified order by column is not the ID column, add the ID column\n  // as a secondary using the same order to enforce a consistent sort.\n  if (columnName !== \"id\") {\n    orderByConditions.push([\"id\", orderDirection]);\n  }\n\n  return orderByConditions;\n}\n\nexport function reverseOrderByConditions(orderByConditions: OrderByConditions) {\n  return orderByConditions.map(([columnName, direction]) => [\n    columnName,\n    direction === \"asc\" ? \"desc\" : \"asc\",\n  ]) satisfies OrderByConditions;\n}\n","import type { Common } from \"@/common/common.js\";\nimport type { HeadlessKysely } from \"@/database/kysely.js\";\nimport type { NamespaceInfo } from \"@/database/service.js\";\nimport type { Schema, Table } from \"@/schema/common.js\";\nimport type {\n  DatabaseRecord,\n  DatabaseValue,\n  UserId,\n  UserRecord,\n} from \"@/types/schema.js\";\nimport type { WhereInput, WriteStore } from \"./store.js\";\nimport { decodeRecord, encodeRecord, encodeValue } from \"./utils/encoding.js\";\nimport { parseStoreError } from \"./utils/errors.js\";\nimport { buildWhereConditions } from \"./utils/filter.js\";\n\nexport const getRealtimeStore = ({\n  encoding,\n  schema,\n  namespaceInfo,\n  db,\n  common,\n}: {\n  encoding: \"sqlite\" | \"postgres\";\n  schema: Schema;\n  namespaceInfo: NamespaceInfo;\n  db: HeadlessKysely<any>;\n  common: Common;\n}): WriteStore<\"realtime\"> => ({\n  create: ({\n    tableName,\n    encodedCheckpoint,\n    id,\n    data = {},\n  }: {\n    tableName: string;\n    encodedCheckpoint: string;\n    id: UserId;\n    data?: Omit<UserRecord, \"id\">;\n  }) => {\n    const table = (schema[tableName] as { table: Table }).table;\n\n    return db.wrap({ method: `${tableName}.create` }, async () => {\n      const createRecord = encodeRecord({\n        record: { id, ...data },\n        table,\n        encoding,\n        schema,\n        skipValidation: false,\n      });\n\n      return await db.transaction().execute(async (tx) => {\n        const record = await tx\n          .withSchema(namespaceInfo.userNamespace)\n          .insertInto(tableName)\n          .values(createRecord)\n          .returningAll()\n          .executeTakeFirstOrThrow()\n          .catch((err) => {\n            throw parseStoreError(err, { id, ...data });\n          });\n\n        await tx\n          .withSchema(namespaceInfo.internalNamespace)\n          .insertInto(namespaceInfo.internalTableIds[tableName]!)\n          .values({\n            operation: 0,\n            id: createRecord.id,\n            checkpoint: encodedCheckpoint,\n          })\n          .execute();\n\n        return decodeRecord({ record: record, table, encoding });\n      });\n    });\n  },\n  createMany: ({\n    tableName,\n    encodedCheckpoint,\n    data,\n  }: {\n    tableName: string;\n    encodedCheckpoint: string;\n    data: UserRecord[];\n  }) => {\n    const table = (schema[tableName] as { table: Table }).table;\n\n    return db.wrap({ method: `${tableName}.createMany` }, async () => {\n      const records: DatabaseRecord[] = [];\n      await db.transaction().execute(async (tx) => {\n        const batchSize = Math.round(\n          common.options.databaseMaxQueryParameters / Object.keys(table).length,\n        );\n        for (let i = 0, len = data.length; i < len; i += batchSize) {\n          const createRecords = data.slice(i, i + batchSize).map((d) =>\n            encodeRecord({\n              record: d,\n              table,\n              encoding,\n              schema,\n              skipValidation: false,\n            }),\n          );\n\n          const _records = await tx\n            .withSchema(namespaceInfo.userNamespace)\n            .insertInto(tableName)\n            .values(createRecords)\n            .returningAll()\n            .execute()\n            .catch((err) => {\n              throw parseStoreError(err, data.length > 0 ? data[0]! : {});\n            });\n\n          records.push(..._records);\n\n          await tx\n            .withSchema(namespaceInfo.internalNamespace)\n            .insertInto(namespaceInfo.internalTableIds[tableName]!)\n            .values(\n              createRecords.map((record) => ({\n                operation: 0,\n                id: record.id,\n                checkpoint: encodedCheckpoint,\n              })),\n            )\n            .execute();\n        }\n      });\n\n      return records.map((record) => decodeRecord({ record, table, encoding }));\n    });\n  },\n  update: ({\n    tableName,\n    encodedCheckpoint,\n    id,\n    data = {},\n  }: {\n    tableName: string;\n    encodedCheckpoint: string;\n    id: UserId;\n    data?:\n      | Partial<Omit<UserRecord, \"id\">>\n      | ((args: { current: UserRecord }) => Partial<Omit<UserRecord, \"id\">>);\n  }) => {\n    const table = (schema[tableName] as { table: Table }).table;\n\n    return db.wrap({ method: `${tableName}.update` }, async () => {\n      const encodedId = encodeValue({ value: id, column: table.id, encoding });\n\n      const record = await db.transaction().execute(async (tx) => {\n        const latestRecord = await tx\n          .withSchema(namespaceInfo.userNamespace)\n          .selectFrom(tableName)\n          .selectAll()\n          .where(\"id\", \"=\", encodedId)\n          .executeTakeFirstOrThrow()\n          .catch((err) => {\n            throw parseStoreError(err, { id, data: \"(function)\" });\n          });\n\n        const updateObject =\n          typeof data === \"function\"\n            ? data({\n                current: decodeRecord({\n                  record: latestRecord,\n                  table,\n                  encoding,\n                }),\n              })\n            : data;\n        const updateRecord = encodeRecord({\n          record: { id, ...updateObject },\n          table,\n          encoding,\n          schema,\n          skipValidation: false,\n        });\n\n        const updateResult = await tx\n          .withSchema(namespaceInfo.userNamespace)\n          .updateTable(tableName)\n          .set(updateRecord)\n          .where(\"id\", \"=\", encodedId)\n          .returningAll()\n          .executeTakeFirstOrThrow()\n          .catch((err) => {\n            throw parseStoreError(err, { id, ...updateObject });\n          });\n\n        await tx\n          .withSchema(namespaceInfo.internalNamespace)\n          .insertInto(namespaceInfo.internalTableIds[tableName]!)\n          .values({\n            operation: 1,\n            checkpoint: encodedCheckpoint,\n            ...latestRecord,\n          })\n          .execute();\n\n        return updateResult;\n      });\n\n      const result = decodeRecord({ record: record, table, encoding });\n\n      return result;\n    });\n  },\n  updateMany: async ({\n    tableName,\n    encodedCheckpoint,\n    where,\n    data = {},\n  }: {\n    tableName: string;\n    encodedCheckpoint: string;\n    where: WhereInput<any>;\n    data?:\n      | Partial<Omit<UserRecord, \"id\">>\n      | ((args: { current: UserRecord }) => Partial<Omit<UserRecord, \"id\">>);\n  }) => {\n    const table = (schema[tableName] as { table: Table }).table;\n\n    const records: UserRecord[] = [];\n    let cursor: DatabaseValue = null;\n\n    while (true) {\n      const _records = await db.wrap(\n        { method: `${tableName}.updateMany` },\n        () =>\n          db.transaction().execute(async (tx) => {\n            const latestRecords: DatabaseRecord[] = await tx\n              .withSchema(namespaceInfo.userNamespace)\n              .selectFrom(tableName)\n              .selectAll()\n              .where((eb) =>\n                buildWhereConditions({\n                  eb,\n                  where,\n                  table,\n                  encoding,\n                }),\n              )\n              .orderBy(\"id\", \"asc\")\n              .limit(common.options.databaseMaxRowLimit)\n              .$if(cursor !== null, (qb) => qb.where(\"id\", \">\", cursor))\n              .execute();\n\n            const records: DatabaseRecord[] = [];\n\n            for (const latestRecord of latestRecords) {\n              const updateObject =\n                typeof data === \"function\"\n                  ? data({\n                      current: decodeRecord({\n                        record: latestRecord,\n                        table,\n                        encoding,\n                      }),\n                    })\n                  : data;\n\n              // Here, `latestRecord` is already encoded, so we need to exclude it from `encodeRecord`.\n              const updateRecord = {\n                id: latestRecord.id,\n                ...encodeRecord({\n                  record: updateObject,\n                  table,\n                  encoding,\n                  schema,\n                  skipValidation: false,\n                }),\n              };\n\n              const record = await tx\n                .withSchema(namespaceInfo.userNamespace)\n                .updateTable(tableName)\n                .set(updateRecord)\n                .where(\"id\", \"=\", latestRecord.id)\n                .returningAll()\n                .executeTakeFirstOrThrow()\n                .catch((err) => {\n                  throw parseStoreError(err, updateObject);\n                });\n\n              records.push(record);\n\n              await tx\n                .withSchema(namespaceInfo.internalNamespace)\n                .insertInto(namespaceInfo.internalTableIds[tableName]!)\n                .values({\n                  operation: 1,\n                  checkpoint: encodedCheckpoint,\n                  ...latestRecord,\n                })\n                .execute();\n            }\n\n            return records.map((record) =>\n              decodeRecord({ record, table, encoding }),\n            );\n          }),\n      );\n\n      records.push(..._records);\n\n      if (_records.length === 0) {\n        break;\n      } else {\n        cursor = encodeValue({\n          value: _records[_records.length - 1]!.id,\n          column: table.id,\n          encoding,\n        });\n      }\n    }\n\n    return records;\n  },\n  upsert: ({\n    tableName,\n    encodedCheckpoint,\n    id,\n    create = {},\n    update = {},\n  }: {\n    tableName: string;\n    encodedCheckpoint: string;\n    id: UserId;\n    create?: Omit<UserRecord, \"id\">;\n    update?:\n      | Partial<Omit<UserRecord, \"id\">>\n      | ((args: { current: UserRecord }) => Partial<Omit<UserRecord, \"id\">>);\n  }) => {\n    const table = (schema[tableName] as { table: Table }).table;\n\n    return db.wrap({ method: `${tableName}.upsert` }, async () => {\n      const encodedId = encodeValue({ value: id, column: table.id, encoding });\n      const createRecord = encodeRecord({\n        record: { id, ...create },\n        table,\n        encoding,\n        schema,\n        skipValidation: false,\n      });\n\n      const record = await db.transaction().execute(async (tx) => {\n        // Find the latest version of this instance.\n        const latestRecord = await tx\n          .withSchema(namespaceInfo.userNamespace)\n          .selectFrom(tableName)\n          .selectAll()\n          .where(\"id\", \"=\", encodedId)\n          .executeTakeFirst();\n\n        // If there is no latest version, insert a new version using the create data.\n        if (latestRecord === undefined) {\n          const record = await tx\n            .withSchema(namespaceInfo.userNamespace)\n            .insertInto(tableName)\n            .values(createRecord)\n            .returningAll()\n            .executeTakeFirstOrThrow()\n            .catch((err) => {\n              const prettyObject: any = { id };\n              for (const [key, value] of Object.entries(create))\n                prettyObject[`create.${key}`] = value;\n              if (typeof update === \"function\") {\n                prettyObject.update = \"(function)\";\n              } else {\n                for (const [key, value] of Object.entries(update))\n                  prettyObject[`update.${key}`] = value;\n              }\n              throw parseStoreError(err, prettyObject);\n            });\n\n          await tx\n            .withSchema(namespaceInfo.internalNamespace)\n            .insertInto(namespaceInfo.internalTableIds[tableName]!)\n            .values({\n              operation: 0,\n              id: createRecord.id,\n              checkpoint: encodedCheckpoint,\n            })\n            .execute();\n\n          return record;\n        }\n\n        const updateObject =\n          typeof update === \"function\"\n            ? update({\n                current: decodeRecord({\n                  record: latestRecord,\n                  table,\n                  encoding,\n                }),\n              })\n            : update;\n        const updateRecord = encodeRecord({\n          record: { id, ...updateObject },\n          table,\n          encoding,\n          schema,\n          skipValidation: false,\n        });\n\n        const record = await tx\n          .withSchema(namespaceInfo.userNamespace)\n          .updateTable(tableName)\n          .set(updateRecord)\n          .where(\"id\", \"=\", encodedId)\n          .returningAll()\n          .executeTakeFirstOrThrow()\n          .catch((err) => {\n            const prettyObject: any = { id };\n            for (const [key, value] of Object.entries(create))\n              prettyObject[`create.${key}`] = value;\n            for (const [key, value] of Object.entries(updateObject))\n              prettyObject[`update.${key}`] = value;\n            throw parseStoreError(err, prettyObject);\n          });\n\n        await tx\n          .withSchema(namespaceInfo.internalNamespace)\n          .insertInto(namespaceInfo.internalTableIds[tableName]!)\n          .values({\n            operation: 1,\n            checkpoint: encodedCheckpoint,\n            ...latestRecord,\n          })\n          .execute();\n\n        return record;\n      });\n\n      return decodeRecord({ record, table, encoding });\n    });\n  },\n  delete: ({\n    tableName,\n    encodedCheckpoint,\n    id,\n  }: {\n    tableName: string;\n    encodedCheckpoint: string;\n    id: UserId;\n  }) => {\n    const table = (schema[tableName] as { table: Table }).table;\n\n    return db.wrap({ method: `${tableName}.delete` }, async () => {\n      const encodedId = encodeValue({ value: id, column: table.id, encoding });\n\n      const isDeleted = await db.transaction().execute(async (tx) => {\n        const record = await tx\n          .withSchema(namespaceInfo.userNamespace)\n          .selectFrom(tableName)\n          .selectAll()\n          .where(\"id\", \"=\", encodedId)\n          .executeTakeFirst();\n\n        const deletedRecord = await tx\n          .withSchema(namespaceInfo.userNamespace)\n          .deleteFrom(tableName)\n          .where(\"id\", \"=\", encodedId)\n          .returning([\"id\"])\n          .executeTakeFirst()\n          .catch((err) => {\n            throw parseStoreError(err, { id });\n          });\n\n        if (record !== undefined) {\n          await tx\n            .withSchema(namespaceInfo.internalNamespace)\n            .insertInto(namespaceInfo.internalTableIds[tableName]!)\n            .values({\n              operation: 2,\n              checkpoint: encodedCheckpoint,\n              ...record,\n            })\n            .execute();\n        }\n\n        return !!deletedRecord;\n      });\n\n      return isDeleted;\n    });\n  },\n});\n","import type { IndexingFunctions } from \"@/build/configAndIndexingFunctions.js\";\nimport type { Common } from \"@/common/common.js\";\nimport type { Network } from \"@/config/networks.js\";\nimport {\n  type EventSource,\n  type FactoryLogSource,\n  type LogSource,\n  sourceIsFactoryLog,\n  sourceIsLog,\n} from \"@/config/sources.js\";\nimport type { IndexingStore } from \"@/indexing-store/store.js\";\nimport type { Schema } from \"@/schema/common.js\";\nimport type { SyncService } from \"@/sync/index.js\";\nimport type { DatabaseModel } from \"@/types/model.js\";\nimport type { UserRecord } from \"@/types/schema.js\";\nimport {\n  type Checkpoint,\n  decodeCheckpoint,\n  encodeCheckpoint,\n  zeroCheckpoint,\n} from \"@/utils/checkpoint.js\";\nimport { never } from \"@/utils/never.js\";\nimport { prettyPrint } from \"@/utils/print.js\";\nimport { startClock } from \"@/utils/timer.js\";\nimport type { Abi, Address } from \"viem\";\nimport { checksumAddress, createClient } from \"viem\";\nimport type {\n  BlockEvent,\n  CallTraceEvent,\n  Event,\n  LogEvent,\n  SetupEvent,\n} from \"../sync/events.js\";\nimport { addStackTrace } from \"./addStackTrace.js\";\nimport {\n  type ReadOnlyClient,\n  buildCachedActions,\n  buildDb,\n} from \"./ponderActions.js\";\n\nexport type Context = {\n  network: { chainId: number; name: string };\n  client: ReadOnlyClient;\n  db: Record<string, DatabaseModel<UserRecord>>;\n  contracts: Record<\n    string,\n    {\n      abi: Abi;\n      address?: Address | readonly Address[];\n      startBlock: number;\n      endBlock?: number;\n      maxBlockRange?: number;\n    }\n  >;\n};\n\nexport type Service = {\n  // static\n  common: Common;\n  indexingFunctions: IndexingFunctions;\n  indexingStore: IndexingStore;\n\n  // state\n  isKilled: boolean;\n\n  eventCount: {\n    [eventName: string]: { [networkName: string]: number };\n  };\n  startCheckpoint: Checkpoint;\n\n  /**\n   * Reduce memory usage by reserving space for objects ahead of time\n   * instead of creating a new one for each event.\n   */\n  currentEvent: {\n    contextState: {\n      encodedCheckpoint: string;\n      blockNumber: bigint;\n    };\n    context: Context;\n  };\n\n  // static cache\n  networkByChainId: { [chainId: number]: Network };\n  clientByChainId: { [chainId: number]: Context[\"client\"] };\n  contractsByChainId: { [chainId: number]: Context[\"contracts\"] };\n};\n\nexport const create = ({\n  indexingFunctions,\n  common,\n  sources,\n  networks,\n  syncService,\n  indexingStore,\n  schema,\n}: {\n  indexingFunctions: IndexingFunctions;\n  common: Common;\n  sources: EventSource[];\n  networks: Network[];\n  syncService: SyncService;\n  indexingStore: IndexingStore;\n  schema: Schema;\n}): Service => {\n  const contextState: Service[\"currentEvent\"][\"contextState\"] = {\n    encodedCheckpoint: undefined!,\n    blockNumber: undefined!,\n  };\n  const clientByChainId: Service[\"clientByChainId\"] = {};\n  const contractsByChainId: Service[\"contractsByChainId\"] = {};\n\n  const networkByChainId = networks.reduce<Service[\"networkByChainId\"]>(\n    (acc, cur) => {\n      acc[cur.chainId] = cur;\n      return acc;\n    },\n    {},\n  );\n\n  // build contractsByChainId\n  for (const source of sources) {\n    if (source.type === \"block\") continue;\n\n    const address =\n      source.type === \"factoryCallTrace\" || source.type === \"factoryLog\"\n        ? undefined\n        : source.type === \"callTrace\"\n          ? source.criteria.toAddress!.length === 1\n            ? source.criteria.toAddress![0]\n            : undefined\n          : typeof source.criteria.address === \"string\"\n            ? source.criteria.address\n            : undefined;\n\n    if (contractsByChainId[source.chainId] === undefined) {\n      contractsByChainId[source.chainId] = {};\n    }\n\n    // Note: multiple sources with the same contract (logs and traces)\n    // should only create one entry in the `contracts` object\n    if (contractsByChainId[source.chainId]![source.contractName] !== undefined)\n      continue;\n\n    contractsByChainId[source.chainId]![source.contractName] = {\n      abi: source.abi,\n      address: address ? checksumAddress(address) : address,\n      startBlock: source.startBlock,\n      endBlock: source.endBlock,\n      maxBlockRange: source.maxBlockRange,\n    };\n  }\n\n  // build db\n  const db = buildDb({ common, schema, indexingStore, contextState });\n\n  // build cachedActions\n  const cachedActions = buildCachedActions(contextState);\n\n  // build clientByChainId\n  for (const network of networks) {\n    const transport = syncService.getCachedTransport(network);\n    clientByChainId[network.chainId] = createClient({\n      transport,\n      chain: network.chain,\n    }).extend(cachedActions);\n  }\n\n  // build eventCount\n  const eventCount: Service[\"eventCount\"] = {};\n  for (const eventName of Object.keys(indexingFunctions)) {\n    eventCount[eventName] = {};\n    for (const network of networks) {\n      eventCount[eventName]![network.name] = 0;\n    }\n  }\n\n  return {\n    common,\n    indexingFunctions,\n    indexingStore,\n    isKilled: false,\n    eventCount,\n    startCheckpoint: syncService.startCheckpoint,\n    currentEvent: {\n      contextState,\n      context: {\n        network: { name: undefined!, chainId: undefined! },\n        contracts: undefined!,\n        client: undefined!,\n        db,\n      },\n    },\n    networkByChainId,\n    clientByChainId,\n    contractsByChainId,\n  };\n};\n\nexport const updateIndexingStore = async (\n  indexingService: Service,\n  { indexingStore, schema }: { indexingStore: IndexingStore; schema: Schema },\n) => {\n  const db = buildDb({\n    common: indexingService.common,\n    schema,\n    indexingStore,\n    contextState: indexingService.currentEvent.contextState,\n  });\n\n  indexingService.currentEvent.context.db = db;\n};\n\nexport const processSetupEvents = async (\n  indexingService: Service,\n  {\n    sources,\n    networks,\n  }: {\n    sources: EventSource[];\n    networks: Network[];\n  },\n): Promise<\n  | { status: \"error\"; error: Error }\n  | { status: \"success\" }\n  | { status: \"killed\" }\n> => {\n  for (const eventName of Object.keys(indexingService.indexingFunctions)) {\n    if (!eventName.endsWith(\":setup\")) continue;\n\n    const [contractName] = eventName.split(\":\");\n\n    for (const network of networks) {\n      const source = sources.find(\n        (s) =>\n          (sourceIsLog(s) || sourceIsFactoryLog(s)) &&\n          s.contractName === contractName &&\n          s.chainId === network.chainId,\n      )! as LogSource | FactoryLogSource;\n\n      if (indexingService.isKilled) return { status: \"killed\" };\n      indexingService.eventCount[eventName]![source.networkName]++;\n\n      const result = await executeSetup(indexingService, {\n        event: {\n          type: \"setup\",\n          chainId: network.chainId,\n          contractName: source.contractName,\n          startBlock: BigInt(source.startBlock),\n          encodedCheckpoint: encodeCheckpoint({\n            ...zeroCheckpoint,\n            chainId: BigInt(network.chainId),\n            blockNumber: BigInt(source.startBlock),\n          }),\n        },\n      });\n\n      if (result.status !== \"success\") {\n        return result;\n      }\n    }\n  }\n\n  return { status: \"success\" };\n};\n\nexport const processEvents = async (\n  indexingService: Service,\n  { events }: { events: Event[] },\n): Promise<\n  | { status: \"error\"; error: Error }\n  | { status: \"success\" }\n  | { status: \"killed\" }\n> => {\n  const eventCounts: { [eventName: string]: number } = {};\n\n  for (let i = 0; i < events.length; i++) {\n    if (indexingService.isKilled) return { status: \"killed\" };\n\n    const event = events[i]!;\n\n    switch (event.type) {\n      case \"log\": {\n        const eventName = `${event.contractName}:${event.logEventName}`;\n\n        indexingService.eventCount[eventName]![\n          indexingService.networkByChainId[event.chainId]!.name\n        ]++;\n\n        indexingService.common.logger.trace({\n          service: \"indexing\",\n          msg: `Started indexing function (event=\"${eventName}\", checkpoint=${event.encodedCheckpoint})`,\n        });\n\n        const result = await executeLog(indexingService, { event });\n        if (result.status !== \"success\") {\n          return result;\n        }\n\n        if (eventCounts[eventName] === undefined) eventCounts[eventName] = 0;\n        eventCounts[eventName]++;\n\n        indexingService.common.logger.trace({\n          service: \"indexing\",\n          msg: `Completed indexing function (event=\"${eventName}\", checkpoint=${event.encodedCheckpoint})`,\n        });\n\n        break;\n      }\n\n      case \"block\": {\n        const eventName = `${event.sourceName}:block`;\n\n        indexingService.eventCount[eventName]![\n          indexingService.networkByChainId[event.chainId]!.name\n        ]++;\n\n        indexingService.common.logger.trace({\n          service: \"indexing\",\n          msg: `Started indexing function (event=\"${eventName}\", checkpoint=${event.encodedCheckpoint})`,\n        });\n\n        const result = await executeBlock(indexingService, { event });\n        if (result.status !== \"success\") {\n          return result;\n        }\n\n        if (eventCounts[eventName] === undefined) eventCounts[eventName] = 0;\n        eventCounts[eventName]++;\n\n        indexingService.common.logger.trace({\n          service: \"indexing\",\n          msg: `Completed indexing function (event=\"${eventName}\", checkpoint=${event.encodedCheckpoint})`,\n        });\n\n        break;\n      }\n\n      case \"callTrace\": {\n        const eventName = `${event.contractName}.${event.functionName}`;\n\n        indexingService.eventCount[eventName]![\n          indexingService.networkByChainId[event.chainId]!.name\n        ]++;\n\n        indexingService.common.logger.trace({\n          service: \"indexing\",\n          msg: `Started indexing function (event=\"${eventName}\", checkpoint=${event.encodedCheckpoint})`,\n        });\n\n        const result = await executeCallTrace(indexingService, { event });\n        if (result.status !== \"success\") {\n          return result;\n        }\n\n        if (eventCounts[eventName] === undefined) eventCounts[eventName] = 0;\n        eventCounts[eventName]++;\n\n        indexingService.common.logger.trace({\n          service: \"indexing\",\n          msg: `Completed indexing function (event=\"${eventName}\", checkpoint=${event.encodedCheckpoint})`,\n        });\n\n        break;\n      }\n\n      default:\n        never(event);\n    }\n\n    // periodically update metrics\n    if (i % 93 === 0) {\n      updateCompletedEvents(indexingService);\n\n      const eventTimestamp = decodeCheckpoint(\n        event.encodedCheckpoint,\n      ).blockTimestamp;\n\n      indexingService.common.metrics.ponder_indexing_completed_seconds.set(\n        eventTimestamp - indexingService.startCheckpoint.blockTimestamp,\n      );\n      indexingService.common.metrics.ponder_indexing_completed_timestamp.set(\n        eventTimestamp,\n      );\n\n      // Note: allows for terminal and logs to be updated\n      await new Promise(setImmediate);\n    }\n  }\n\n  // set completed seconds\n  if (events.length > 0) {\n    const lastEventInBatchTimestamp = decodeCheckpoint(\n      events[events.length - 1]!.encodedCheckpoint,\n    ).blockTimestamp;\n\n    indexingService.common.metrics.ponder_indexing_completed_seconds.set(\n      lastEventInBatchTimestamp -\n        indexingService.startCheckpoint.blockTimestamp,\n    );\n    indexingService.common.metrics.ponder_indexing_completed_timestamp.set(\n      lastEventInBatchTimestamp,\n    );\n  }\n  // set completed events\n  updateCompletedEvents(indexingService);\n\n  for (const [eventName, count] of Object.entries(eventCounts)) {\n    if (count === 1) {\n      indexingService.common.logger.info({\n        service: \"indexing\",\n        msg: `Indexed 1 '${eventName}' event`,\n      });\n    } else {\n      indexingService.common.logger.info({\n        service: \"indexing\",\n        msg: `Indexed ${count} '${eventName}' events`,\n      });\n    }\n  }\n\n  return { status: \"success\" };\n};\n\nexport const kill = (indexingService: Service) => {\n  indexingService.common.logger.debug({\n    service: \"indexing\",\n    msg: \"Killed indexing service\",\n  });\n  indexingService.isKilled = true;\n};\n\nexport const updateTotalSeconds = (\n  indexingService: Service,\n  endCheckpoint: Checkpoint,\n) => {\n  indexingService.common.metrics.ponder_indexing_total_seconds.set(\n    endCheckpoint.blockTimestamp -\n      indexingService.startCheckpoint.blockTimestamp,\n  );\n};\n\nconst updateCompletedEvents = (indexingService: Service) => {\n  for (const event of Object.keys(indexingService.eventCount)) {\n    for (const network of Object.keys(indexingService.eventCount[event]!)) {\n      const metricLabel = {\n        event,\n        network,\n      };\n      indexingService.common.metrics.ponder_indexing_completed_events.set(\n        metricLabel,\n        indexingService.eventCount[event]![network]!,\n      );\n    }\n  }\n};\n\nconst executeSetup = async (\n  indexingService: Service,\n  { event }: { event: SetupEvent },\n): Promise<\n  | { status: \"error\"; error: Error }\n  | { status: \"success\" }\n  | { status: \"killed\" }\n> => {\n  const {\n    common,\n    indexingFunctions,\n    currentEvent,\n    networkByChainId,\n    contractsByChainId,\n    clientByChainId,\n  } = indexingService;\n  const eventName = `${event.contractName}:setup`;\n  const indexingFunction = indexingFunctions[eventName];\n\n  const networkName = networkByChainId[event.chainId]!.name;\n  const metricLabel = { event: eventName, network: networkName };\n\n  try {\n    // set currentEvent\n    currentEvent.context.network.chainId = event.chainId;\n    currentEvent.context.network.name = networkByChainId[event.chainId]!.name;\n    currentEvent.context.client = clientByChainId[event.chainId]!;\n    currentEvent.context.contracts = contractsByChainId[event.chainId]!;\n    currentEvent.contextState.encodedCheckpoint = event.encodedCheckpoint;\n    currentEvent.contextState.blockNumber = event.startBlock;\n\n    const endClock = startClock();\n\n    await indexingFunction!({\n      context: currentEvent.context,\n    });\n\n    common.metrics.ponder_indexing_function_duration.observe(\n      metricLabel,\n      endClock(),\n    );\n  } catch (_error) {\n    if (indexingService.isKilled) return { status: \"killed\" };\n    const error = _error as Error;\n\n    common.metrics.ponder_indexing_function_error_total.inc(metricLabel);\n\n    const decodedCheckpoint = decodeCheckpoint(event.encodedCheckpoint);\n\n    addStackTrace(error, common.options);\n\n    common.metrics.ponder_indexing_has_error.set(1);\n\n    common.logger.error({\n      service: \"indexing\",\n      msg: `Error while processing '${eventName}' event in '${networkName}' block ${decodedCheckpoint.blockNumber}`,\n      error,\n    });\n\n    return { status: \"error\", error: error };\n  }\n\n  return { status: \"success\" };\n};\n\nconst executeLog = async (\n  indexingService: Service,\n  { event }: { event: LogEvent },\n): Promise<\n  | { status: \"error\"; error: Error }\n  | { status: \"success\" }\n  | { status: \"killed\" }\n> => {\n  const {\n    common,\n    indexingFunctions,\n    currentEvent,\n    networkByChainId,\n    contractsByChainId,\n    clientByChainId,\n  } = indexingService;\n  const eventName = `${event.contractName}:${event.logEventName}`;\n  const indexingFunction = indexingFunctions[eventName];\n\n  const networkName = networkByChainId[event.chainId]!.name;\n  const metricLabel = { event: eventName, network: networkName };\n\n  try {\n    // set currentEvent\n    currentEvent.context.network.chainId = event.chainId;\n    currentEvent.context.network.name = networkByChainId[event.chainId]!.name;\n    currentEvent.context.client = clientByChainId[event.chainId]!;\n    currentEvent.context.contracts = contractsByChainId[event.chainId]!;\n    currentEvent.contextState.encodedCheckpoint = event.encodedCheckpoint;\n    currentEvent.contextState.blockNumber = event.event.block.number;\n\n    const endClock = startClock();\n\n    await indexingFunction!({\n      event: {\n        name: event.logEventName,\n        args: event.event.args,\n        log: event.event.log,\n        block: event.event.block,\n        transaction: event.event.transaction,\n        transactionReceipt: event.event.transactionReceipt,\n      },\n      context: currentEvent.context,\n    });\n\n    common.metrics.ponder_indexing_function_duration.observe(\n      metricLabel,\n      endClock(),\n    );\n  } catch (_error) {\n    if (indexingService.isKilled) return { status: \"killed\" };\n    const error = _error as Error & { meta?: string[] };\n\n    common.metrics.ponder_indexing_function_error_total.inc(metricLabel);\n\n    const decodedCheckpoint = decodeCheckpoint(event.encodedCheckpoint);\n\n    addStackTrace(error, common.options);\n\n    error.meta = Array.isArray(error.meta) ? error.meta : [];\n    error.meta.push(`Event arguments:\\n${prettyPrint(event.event.args)}`);\n\n    common.logger.error({\n      service: \"indexing\",\n      msg: `Error while processing '${eventName}' event in '${networkName}' block ${decodedCheckpoint.blockNumber}`,\n      error,\n    });\n\n    common.metrics.ponder_indexing_has_error.set(1);\n\n    return { status: \"error\", error };\n  }\n\n  return { status: \"success\" };\n};\n\nconst executeBlock = async (\n  indexingService: Service,\n  { event }: { event: BlockEvent },\n): Promise<\n  | { status: \"error\"; error: Error }\n  | { status: \"success\" }\n  | { status: \"killed\" }\n> => {\n  const {\n    common,\n    indexingFunctions,\n    currentEvent,\n    networkByChainId,\n    contractsByChainId,\n    clientByChainId,\n  } = indexingService;\n  const eventName = `${event.sourceName}:block`;\n  const indexingFunction = indexingFunctions[eventName];\n\n  const metricLabel = {\n    event: eventName,\n    network: networkByChainId[event.chainId]!.name,\n  };\n\n  try {\n    // set currentEvent\n    currentEvent.context.network.chainId = event.chainId;\n    currentEvent.context.network.name = networkByChainId[event.chainId]!.name;\n    currentEvent.context.client = clientByChainId[event.chainId]!;\n    currentEvent.context.contracts = contractsByChainId[event.chainId]!;\n    currentEvent.contextState.encodedCheckpoint = event.encodedCheckpoint;\n    currentEvent.contextState.blockNumber = event.event.block.number;\n\n    const endClock = startClock();\n\n    await indexingFunction!({\n      event: {\n        block: event.event.block,\n      },\n      context: currentEvent.context,\n    });\n\n    common.metrics.ponder_indexing_function_duration.observe(\n      metricLabel,\n      endClock(),\n    );\n  } catch (_error) {\n    if (indexingService.isKilled) return { status: \"killed\" };\n    const error = _error as Error & { meta?: string[] };\n    common.metrics.ponder_indexing_function_error_total.inc(metricLabel);\n\n    const decodedCheckpoint = decodeCheckpoint(event.encodedCheckpoint);\n\n    addStackTrace(error, common.options);\n\n    error.meta = Array.isArray(error.meta) ? error.meta : [];\n    error.meta.push(\n      `Block:\\n${prettyPrint({\n        hash: event.event.block.hash,\n        number: event.event.block.number,\n        timestamp: event.event.block.timestamp,\n      })}`,\n    );\n\n    common.logger.error({\n      service: \"indexing\",\n      msg: `Error while processing ${eventName} event at chainId=${decodedCheckpoint.chainId}, block=${decodedCheckpoint.blockNumber}`,\n      error,\n    });\n\n    common.metrics.ponder_indexing_has_error.set(1);\n\n    return { status: \"error\", error: error };\n  }\n\n  return { status: \"success\" };\n};\n\nconst executeCallTrace = async (\n  indexingService: Service,\n  { event }: { event: CallTraceEvent },\n): Promise<\n  | { status: \"error\"; error: Error }\n  | { status: \"success\" }\n  | { status: \"killed\" }\n> => {\n  const {\n    common,\n    indexingFunctions,\n    currentEvent,\n    networkByChainId,\n    contractsByChainId,\n    clientByChainId,\n  } = indexingService;\n  const eventName = `${event.contractName}.${event.functionName}`;\n  const indexingFunction = indexingFunctions[eventName];\n\n  const networkName = networkByChainId[event.chainId]!.name;\n  const metricLabel = { event: eventName, network: networkName };\n\n  try {\n    // set currentEvent\n    currentEvent.context.network.chainId = event.chainId;\n    currentEvent.context.network.name = networkByChainId[event.chainId]!.name;\n    currentEvent.context.client = clientByChainId[event.chainId]!;\n    currentEvent.context.contracts = contractsByChainId[event.chainId]!;\n    currentEvent.contextState.encodedCheckpoint = event.encodedCheckpoint;\n    currentEvent.contextState.blockNumber = event.event.block.number;\n\n    const endClock = startClock();\n\n    await indexingFunction!({\n      event: {\n        args: event.event.args,\n        result: event.event.result,\n        trace: event.event.trace,\n        block: event.event.block,\n        transaction: event.event.transaction,\n        transactionReceipt: event.event.transactionReceipt,\n      },\n      context: currentEvent.context,\n    });\n\n    common.metrics.ponder_indexing_function_duration.observe(\n      metricLabel,\n      endClock(),\n    );\n  } catch (_error) {\n    if (indexingService.isKilled) return { status: \"killed\" };\n    const error = _error as Error & { meta?: string[] };\n\n    common.metrics.ponder_indexing_function_error_total.inc(metricLabel);\n\n    const decodedCheckpoint = decodeCheckpoint(event.encodedCheckpoint);\n\n    addStackTrace(error, common.options);\n\n    error.meta = Array.isArray(error.meta) ? error.meta : [];\n    error.meta.push(`Call trace arguments:\\n${prettyPrint(event.event.args)}`);\n\n    common.logger.error({\n      service: \"indexing\",\n      msg: `Error while processing '${eventName}' event in '${networkName}' block ${decodedCheckpoint.blockNumber}`,\n      error,\n    });\n\n    common.metrics.ponder_indexing_has_error.set(1);\n\n    return { status: \"error\", error: error };\n  }\n\n  return { status: \"success\" };\n};\n","import { readFileSync } from \"node:fs\";\nimport type { Options } from \"@/common/options.js\";\nimport { codeFrameColumns } from \"@babel/code-frame\";\nimport { type StackFrame, parse as parseStackTrace } from \"stacktrace-parser\";\n\n// Note: this currently works for both indexing functions and api\n// routes only because the api route dir is a subdir of the indexing function\n// dir.\n\nexport const addStackTrace = (error: Error, options: Options) => {\n  if (!error.stack) return;\n\n  const stackTrace = parseStackTrace(error.stack);\n\n  let codeFrame: string | undefined;\n  let userStackTrace: StackFrame[];\n\n  // Find first frame that occurred within user code.\n  const firstUserFrameIndex = stackTrace.findIndex((frame) =>\n    frame.file?.includes(options.indexingDir),\n  );\n\n  if (firstUserFrameIndex >= 0) {\n    userStackTrace = stackTrace.filter((frame) =>\n      frame.file?.includes(options.indexingDir),\n    );\n\n    const firstUserFrame = stackTrace[firstUserFrameIndex];\n    if (firstUserFrame?.file && firstUserFrame?.lineNumber) {\n      try {\n        const sourceContent = readFileSync(firstUserFrame.file, {\n          encoding: \"utf-8\",\n        });\n        codeFrame = codeFrameColumns(\n          sourceContent,\n          {\n            start: {\n              line: firstUserFrame.lineNumber,\n              column: firstUserFrame.column ?? undefined,\n            },\n          },\n          { highlightCode: true },\n        );\n      } catch (err) {\n        // Ignore errors here.\n      }\n    }\n  } else {\n    userStackTrace = stackTrace;\n  }\n\n  const formattedStackTrace = [\n    `${error.name}: ${error.message}`,\n    ...userStackTrace.map(({ file, lineNumber, column, methodName }) => {\n      const prefix = \"    at\";\n      const path = `${file}${lineNumber !== null ? `:${lineNumber}` : \"\"}${\n        column !== null ? `:${column}` : \"\"\n      }`;\n      if (methodName === null || methodName === \"<unknown>\") {\n        return `${prefix} ${path}`;\n      } else {\n        return `${prefix} ${methodName} (${path})`;\n      }\n    }),\n    codeFrame,\n  ].join(\"\\n\");\n\n  error.stack = formattedStackTrace;\n};\n","import { getTables } from \"@/schema/utils.js\";\nimport type { Prettify } from \"@/types/utils.js\";\nimport type {\n  Abi,\n  Account,\n  Chain,\n  Client,\n  ContractFunctionConfig,\n  GetBalanceParameters,\n  GetBalanceReturnType,\n  GetBytecodeParameters,\n  GetBytecodeReturnType,\n  GetEnsNameParameters,\n  GetEnsNameReturnType,\n  GetStorageAtParameters,\n  GetStorageAtReturnType,\n  MulticallParameters,\n  MulticallReturnType,\n  PublicRpcSchema,\n  ReadContractParameters,\n  ReadContractReturnType,\n  Transport,\n} from \"viem\";\nimport {\n  getBalance as viemGetBalance,\n  getBytecode as viemGetBytecode,\n  getStorageAt as viemGetStorageAt,\n  multicall as viemMulticall,\n  readContract as viemReadContract,\n} from \"viem/actions\";\nimport type { Service, create } from \"./service.js\";\n\nexport type BlockOptions =\n  | {\n      cache?: undefined;\n      blockNumber?: undefined;\n    }\n  | {\n      cache: \"immutable\";\n      blockNumber?: undefined;\n    }\n  | {\n      cache?: undefined;\n      blockNumber: bigint;\n    };\n\nexport type PonderActions = {\n  getBalance: (\n    args: Omit<GetBalanceParameters, \"blockTag\" | \"blockNumber\"> & BlockOptions,\n  ) => Promise<GetBalanceReturnType>;\n  getBytecode: (\n    args: Omit<GetBytecodeParameters, \"blockTag\" | \"blockNumber\"> &\n      BlockOptions,\n  ) => Promise<GetBytecodeReturnType>;\n  getStorageAt: (\n    args: Omit<GetStorageAtParameters, \"blockTag\" | \"blockNumber\"> &\n      BlockOptions,\n  ) => Promise<GetStorageAtReturnType>;\n  multicall: <\n    TContracts extends ContractFunctionConfig[],\n    TAllowFailure extends boolean = true,\n  >(\n    args: Omit<\n      MulticallParameters<TContracts, TAllowFailure>,\n      \"blockTag\" | \"blockNumber\"\n    > &\n      BlockOptions,\n  ) => Promise<MulticallReturnType<TContracts, TAllowFailure>>;\n  readContract: <\n    const TAbi extends Abi | readonly unknown[],\n    TFunctionName extends string,\n  >(\n    args: Omit<\n      ReadContractParameters<TAbi, TFunctionName>,\n      \"blockTag\" | \"blockNumber\"\n    > &\n      BlockOptions,\n  ) => Promise<ReadContractReturnType<TAbi, TFunctionName>>;\n  getEnsName: (\n    args: Omit<GetEnsNameParameters, \"blockTag\" | \"blockNumber\"> & BlockOptions,\n  ) => Promise<GetEnsNameReturnType>;\n};\n\nexport type ReadOnlyClient<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n> = Prettify<\n  Client<transport, chain, undefined, PublicRpcSchema, PonderActions>\n>;\n\nexport const buildCachedActions = (\n  contextState: Pick<Service[\"currentEvent\"][\"contextState\"], \"blockNumber\">,\n) => {\n  return <\n    TTransport extends Transport = Transport,\n    TChain extends Chain | undefined = Chain | undefined,\n    TAccount extends Account | undefined = Account | undefined,\n  >(\n    client: Client<TTransport, TChain, TAccount>,\n  ): PonderActions => ({\n    getBalance: ({\n      cache,\n      blockNumber: userBlockNumber,\n      ...args\n    }: Omit<GetBalanceParameters, \"blockTag\" | \"blockNumber\"> &\n      BlockOptions): Promise<GetBalanceReturnType> =>\n      viemGetBalance(client, {\n        ...args,\n        ...(cache === \"immutable\"\n          ? { blockTag: \"latest\" }\n          : { blockNumber: userBlockNumber ?? contextState.blockNumber }),\n      }),\n    getBytecode: ({\n      cache,\n      blockNumber: userBlockNumber,\n      ...args\n    }: Omit<GetBytecodeParameters, \"blockTag\" | \"blockNumber\"> &\n      BlockOptions): Promise<GetBytecodeReturnType> =>\n      viemGetBytecode(client, {\n        ...args,\n        ...(cache === \"immutable\"\n          ? { blockTag: \"latest\" }\n          : { blockNumber: userBlockNumber ?? contextState.blockNumber }),\n      }),\n    getStorageAt: ({\n      cache,\n      blockNumber: userBlockNumber,\n      ...args\n    }: Omit<GetStorageAtParameters, \"blockTag\" | \"blockNumber\"> &\n      BlockOptions): Promise<GetStorageAtReturnType> =>\n      viemGetStorageAt(client, {\n        ...args,\n        ...(cache === \"immutable\"\n          ? { blockTag: \"latest\" }\n          : { blockNumber: userBlockNumber ?? contextState.blockNumber }),\n      }),\n    multicall: <\n      TContracts extends ContractFunctionConfig[],\n      TAllowFailure extends boolean = true,\n    >({\n      cache,\n      blockNumber: userBlockNumber,\n      ...args\n    }: Omit<\n      MulticallParameters<TContracts, TAllowFailure>,\n      \"blockTag\" | \"blockNumber\"\n    > &\n      BlockOptions): Promise<MulticallReturnType<TContracts, TAllowFailure>> =>\n      viemMulticall(client, {\n        ...args,\n        ...(cache === \"immutable\"\n          ? { blockTag: \"latest\" }\n          : { blockNumber: userBlockNumber ?? contextState.blockNumber }),\n      }),\n    // @ts-ignore\n    readContract: <\n      const TAbi extends Abi | readonly unknown[],\n      TFunctionName extends string,\n    >({\n      cache,\n      blockNumber: userBlockNumber,\n      ...args\n    }: Omit<\n      ReadContractParameters<TAbi, TFunctionName>,\n      \"blockTag\" | \"blockNumber\"\n    > &\n      BlockOptions): Promise<ReadContractReturnType<TAbi, TFunctionName>> =>\n      viemReadContract(client, {\n        ...args,\n        ...(cache === \"immutable\"\n          ? { blockTag: \"latest\" }\n          : { blockNumber: userBlockNumber ?? contextState.blockNumber }),\n      } as ReadContractParameters<TAbi, TFunctionName>),\n  });\n};\n\nexport const buildDb = ({\n  common,\n  schema,\n  indexingStore,\n  contextState,\n}: Pick<Parameters<typeof create>[0], \"common\" | \"schema\" | \"indexingStore\"> & {\n  contextState: Pick<\n    Service[\"currentEvent\"][\"contextState\"],\n    \"encodedCheckpoint\"\n  >;\n}) => {\n  return Object.keys(getTables(schema)).reduce<\n    Service[\"currentEvent\"][\"context\"][\"db\"]\n  >((acc, tableName) => {\n    acc[tableName] = {\n      findUnique: async ({ id }) => {\n        common.logger.trace({\n          service: \"store\",\n          msg: `${tableName}.findUnique(id=${id})`,\n        });\n        return indexingStore.findUnique({\n          tableName,\n          id,\n        });\n      },\n      findMany: async ({ where, orderBy, limit, before, after } = {}) => {\n        common.logger.trace({\n          service: \"store\",\n          msg: `${tableName}.findMany`,\n        });\n        return indexingStore.findMany({\n          tableName,\n          where,\n          orderBy,\n          limit,\n          before,\n          after,\n        });\n      },\n      create: async ({ id, data }) => {\n        common.logger.trace({\n          service: \"store\",\n          msg: `${tableName}.create(id=${id})`,\n        });\n        return indexingStore.create({\n          tableName,\n          encodedCheckpoint: contextState.encodedCheckpoint,\n          id,\n          data,\n        });\n      },\n      createMany: async ({ data }) => {\n        common.logger.trace({\n          service: \"store\",\n          msg: `${tableName}.createMany(count=${data.length})`,\n        });\n        return indexingStore.createMany({\n          tableName,\n          encodedCheckpoint: contextState.encodedCheckpoint,\n          data,\n        });\n      },\n      update: async ({ id, data }) => {\n        common.logger.trace({\n          service: \"store\",\n          msg: `${tableName}.update(id=${id})`,\n        });\n        return indexingStore.update({\n          tableName,\n          encodedCheckpoint: contextState.encodedCheckpoint,\n          id,\n          data,\n        });\n      },\n      updateMany: async ({ where, data }) => {\n        common.logger.trace({\n          service: \"store\",\n          msg: `${tableName}.updateMany`,\n        });\n        return indexingStore.updateMany({\n          tableName,\n          encodedCheckpoint: contextState.encodedCheckpoint,\n          where,\n          data,\n        });\n      },\n      upsert: async ({ id, create, update }) => {\n        common.logger.trace({\n          service: \"store\",\n          msg: `${tableName}.upsert(id=${id})`,\n        });\n        return indexingStore.upsert({\n          tableName,\n          encodedCheckpoint: contextState.encodedCheckpoint,\n          id,\n          create,\n          update,\n        });\n      },\n      delete: async ({ id }) => {\n        common.logger.trace({\n          service: \"store\",\n          msg: `${tableName}.delete(id=${id})`,\n        });\n        return indexingStore.delete({\n          tableName,\n          encodedCheckpoint: contextState.encodedCheckpoint,\n          id,\n        });\n      },\n    };\n    return acc;\n  }, {});\n};\n","import { type Extend, extend } from \"@/utils/extend.js\";\nimport {\n  create,\n  kill,\n  processEvents,\n  processSetupEvents,\n  updateIndexingStore,\n  updateTotalSeconds,\n} from \"./service.js\";\nimport type { Context, Service } from \"./service.js\";\n\nconst methods = {\n  create,\n  kill,\n  processEvents,\n  processSetupEvents,\n  updateIndexingStore,\n  updateTotalSeconds,\n};\n\nexport const createIndexingService = extend(create, methods);\n\nexport type IndexingService = Extend<Service, typeof methods>;\n\nexport type { Context };\n","import type {\n  CallTraceFilterCriteria,\n  ChildAddressCriteria,\n  FactoryCallTraceFilterCriteria,\n  FactoryLogFilterCriteria,\n  LogFilterCriteria,\n} from \"@/config/sources.js\";\nimport type { Address, Hex } from \"viem\";\n\n/**\n * Generates log filter fragments from a log filter.\n *\n * @param logFilter Log filter to be decompose into fragments.\n * @returns A list of log filter fragments.\n */\nexport function buildLogFilterFragments({\n  address,\n  topics,\n  includeTransactionReceipts,\n  chainId,\n}: LogFilterCriteria & {\n  chainId: number;\n}) {\n  return buildLogFragments({\n    address,\n    topics,\n    includeTransactionReceipts,\n    chainId,\n    idCallback: (address_, topic0_, topic1_, topic2_, topic3_) =>\n      `${chainId}_${address_}_${topic0_}_${topic1_}_${topic2_}_${topic3_}_${\n        includeTransactionReceipts ? 1 : 0\n      }`,\n  });\n}\n\n/**\n * Generates factory fragments from a factory.\n *\n * @param factory Factory to be decomposed into fragments.\n * @returns A list of factory fragments.\n */\nexport function buildFactoryLogFragments({\n  address,\n  eventSelector,\n  childAddressLocation,\n  topics,\n  includeTransactionReceipts,\n  chainId,\n}: FactoryLogFilterCriteria & {\n  chainId: number;\n}) {\n  const fragments = buildLogFragments({\n    address,\n    topics,\n    includeTransactionReceipts,\n    chainId,\n    childAddressLocation,\n    eventSelector,\n    idCallback: (address_, topic0_, topic1_, topic2_, topic3_) =>\n      `${chainId}_${address_}_${eventSelector}_${childAddressLocation}_${topic0_}_${topic1_}_${topic2_}_${topic3_}_${\n        includeTransactionReceipts ? 1 : 0\n      }`,\n  });\n\n  return fragments as ((typeof fragments)[number] & ChildAddressCriteria)[];\n}\n\nfunction buildLogFragments({\n  address,\n  topics,\n  chainId,\n  idCallback,\n  includeTransactionReceipts,\n  ...rest\n}: (LogFilterCriteria | FactoryLogFilterCriteria) & {\n  idCallback: (\n    address: Address | null,\n    topic0: ReturnType<typeof parseTopics>[\"topic0\"],\n    topic1: ReturnType<typeof parseTopics>[\"topic1\"],\n    topic2: ReturnType<typeof parseTopics>[\"topic2\"],\n    topic3: ReturnType<typeof parseTopics>[\"topic3\"],\n  ) => string;\n  chainId: number;\n}) {\n  const fragments: {\n    id: string;\n    chainId: number;\n    address: Hex | null;\n    topic0: Hex | null;\n    topic1: Hex | null;\n    topic2: Hex | null;\n    topic3: Hex | null;\n    includeTransactionReceipts: 0 | 1;\n  }[] = [];\n\n  const { topic0, topic1, topic2, topic3 } = parseTopics(topics);\n\n  for (const address_ of Array.isArray(address) ? address : [address ?? null]) {\n    for (const topic0_ of Array.isArray(topic0) ? topic0 : [topic0]) {\n      for (const topic1_ of Array.isArray(topic1) ? topic1 : [topic1]) {\n        for (const topic2_ of Array.isArray(topic2) ? topic2 : [topic2]) {\n          for (const topic3_ of Array.isArray(topic3) ? topic3 : [topic3]) {\n            fragments.push({\n              id: idCallback(address_, topic0_, topic1_, topic2_, topic3_),\n              ...rest,\n              chainId,\n              address: address_,\n              topic0: topic0_,\n              topic1: topic1_,\n              topic2: topic2_,\n              topic3: topic3_,\n              includeTransactionReceipts: includeTransactionReceipts ? 1 : 0,\n            });\n          }\n        }\n      }\n    }\n  }\n\n  return fragments;\n}\n\nfunction parseTopics(topics: (Hex | Hex[] | null)[] | undefined) {\n  return {\n    topic0: topics?.[0] ?? null,\n    topic1: topics?.[1] ?? null,\n    topic2: topics?.[2] ?? null,\n    topic3: topics?.[3] ?? null,\n  } as {\n    topic0: Hex | Hex[] | null;\n    topic1: Hex | Hex[] | null;\n    topic2: Hex | Hex[] | null;\n    topic3: Hex | Hex[] | null;\n  };\n}\n\nexport function buildTraceFragments({\n  fromAddress,\n  toAddress,\n  chainId,\n}: CallTraceFilterCriteria & {\n  chainId: number;\n}) {\n  const fragments: {\n    id: string;\n    chainId: number;\n    fromAddress: Hex | null;\n    toAddress: Hex | null;\n  }[] = [];\n\n  for (const _fromAddress of Array.isArray(fromAddress)\n    ? fromAddress\n    : [null]) {\n    for (const _toAddress of Array.isArray(toAddress) ? toAddress : [null]) {\n      fragments.push({\n        id: `${chainId}_${_fromAddress}_${_toAddress}`,\n        chainId,\n        fromAddress: _fromAddress,\n        toAddress: _toAddress,\n      });\n    }\n  }\n\n  return fragments;\n}\n\nexport function buildFactoryTraceFragments({\n  address,\n  eventSelector,\n  childAddressLocation,\n  fromAddress,\n  chainId,\n}: FactoryCallTraceFilterCriteria & {\n  chainId: number;\n}) {\n  const fragments: ({\n    id: string;\n    chainId: number;\n    fromAddress: Hex | null;\n  } & ChildAddressCriteria)[] = [];\n\n  for (const _fromAddress of Array.isArray(fromAddress)\n    ? fromAddress\n    : [null]) {\n    fragments.push({\n      id: `${chainId}_${address}_${eventSelector}_${childAddressLocation}_${_fromAddress}`,\n      chainId,\n      address,\n      eventSelector,\n      childAddressLocation,\n      fromAddress: _fromAddress,\n    });\n  }\n\n  return fragments;\n}\n","/**\n * Return the total sum of a list of numeric intervals.\n *\n * @param intervals List of numeric intervals to find the sum of.\n * @returns Sum of the intervals.\n */\nexport function intervalSum(intervals: [number, number][]) {\n  let totalSum = 0;\n\n  for (const [start, end] of intervals) {\n    totalSum += end - start + 1;\n  }\n\n  return totalSum;\n}\n\n/**\n * Return the union of a list of numeric intervals.\n *\n * @param intervals List of numeric intervals to find the union of.\n * @returns Union of the intervals, represented as a list of intervals.\n */\nexport function intervalUnion(intervals_: [number, number][]) {\n  if (intervals_.length === 0) return [];\n\n  // Create copies to avoid mutating the originals.\n  const intervals = intervals_.map(\n    (interval) => [...interval] as [number, number],\n  );\n  // Sort intervals based on the left end.\n  intervals.sort((a, b) => a[0] - b[0]);\n\n  const result: [number, number][] = [];\n  let currentInterval = intervals[0]!;\n\n  for (let i = 1; i < intervals.length; i++) {\n    const nextInterval = intervals[i]!;\n\n    if (currentInterval[1] >= nextInterval[0] - 1) {\n      // Merge overlapping intervals\n      currentInterval[1] = Math.max(currentInterval[1], nextInterval[1]);\n    } else {\n      // No overlap, add current interval to result\n      result.push(currentInterval);\n      currentInterval = nextInterval;\n    }\n  }\n\n  result.push(currentInterval); // Add the last interval\n  return result;\n}\n\n/**\n * Return the intersection of two lists of numeric intervals.\n *\n * @param list1 First list of numeric intervals.\n * @param list2 Second list of numeric intervals.\n * @returns Intersection of the intervals, represented as a list of intervals.\n */\nexport function intervalIntersection(\n  list1: [number, number][],\n  list2: [number, number][],\n): [number, number][] {\n  const result: [number, number][] = [];\n  let i = 0;\n  let j = 0;\n\n  while (i < list1.length && j < list2.length) {\n    const [start1, end1] = list1[i]!;\n    const [start2, end2] = list2[j]!;\n\n    const intersectionStart = Math.max(start1, start2);\n    const intersectionEnd = Math.min(end1, end2);\n\n    if (intersectionStart <= intersectionEnd) {\n      result.push([intersectionStart, intersectionEnd]);\n    }\n\n    if (end1 < end2) {\n      i++;\n    } else {\n      j++;\n    }\n  }\n\n  // Merge potentially overlapping intervals before returning.\n  return intervalUnion(result);\n}\n\n/**\n * Return the intersection of many lists of numeric intervals.\n *\n * @param list1 First list of numeric intervals.\n * @param list2 Second list of numeric intervals.\n * @returns Intersection of the intervals, represented as a list of intervals.\n */\nexport function intervalIntersectionMany(\n  lists: [number, number][][],\n): [number, number][] {\n  if (lists.length === 0) return [];\n  if (lists.length === 1) return lists[0]!;\n\n  let result: [number, number][] = lists[0]!;\n\n  for (let i = 1; i < lists.length; i++) {\n    result = intervalIntersection(result, lists[i]!);\n  }\n\n  return intervalUnion(result);\n}\n\n/**\n * Return the difference between two lists of numeric intervals (initial - remove).\n *\n * @param initial Starting/base list of numeric intervals.\n * @param remove List of numeric intervals to remove.\n * @returns Difference of the intervals, represented as a list of intervals.\n */\nexport function intervalDifference(\n  initial: [number, number][],\n  remove: [number, number][],\n): [number, number][] {\n  // Create copies to avoid mutating the originals.\n  const initial_ = initial.map((interval) => [...interval] as [number, number]);\n  const remove_ = remove.map((interval) => [...interval] as [number, number]);\n\n  const result: [number, number][] = [];\n\n  let i = 0;\n  let j = 0;\n\n  while (i < initial.length && j < remove.length) {\n    const interval1 = initial_[i]!;\n    const interval2 = remove_[j]!;\n\n    if (interval1[1] < interval2[0]) {\n      // No overlap, add interval1 to the result\n      result.push(interval1);\n      i++;\n    } else if (interval2[1] < interval1[0]) {\n      // No overlap, move to the next interval in remove\n      j++;\n    } else {\n      // There is an overlap\n      if (interval1[0] < interval2[0]) {\n        // Add the left part of interval1\n        result.push([interval1[0], interval2[0] - 1]);\n      }\n      if (interval1[1] > interval2[1]) {\n        // Update interval1's start to exclude the overlap\n        interval1[0] = interval2[1] + 1;\n        j++;\n      } else {\n        // No more overlap, move to the next interval in initial\n        i++;\n      }\n    }\n  }\n\n  // Add any remaining intervals from initial\n  while (i < initial_.length) {\n    result.push(initial_[i]!);\n    i++;\n  }\n\n  return result;\n}\n\nexport function getChunks({\n  intervals,\n  maxChunkSize,\n}: {\n  intervals: [number, number][];\n  maxChunkSize: number;\n}) {\n  const _chunks: [number, number][] = [];\n\n  for (const interval of intervals) {\n    const [startBlock, endBlock] = interval;\n\n    let fromBlock = startBlock;\n    let toBlock = Math.min(fromBlock + maxChunkSize - 1, endBlock);\n\n    while (fromBlock <= endBlock) {\n      _chunks.push([fromBlock, toBlock]);\n\n      fromBlock = toBlock + 1;\n      toBlock = Math.min(fromBlock + maxChunkSize - 1, endBlock);\n    }\n  }\n\n  return _chunks;\n}\n\nexport class ProgressTracker {\n  target: [number, number];\n  private _completed: [number, number][];\n  private _required: [number, number][] | null = null;\n  private _checkpoint: number | null = null;\n\n  /**\n   * Constructs a new ProgressTracker object.\n\n   * @throws Will throw an error if the target interval is invalid.\n   */\n  constructor({\n    target,\n    completed,\n  }: {\n    target: [number, number];\n    completed: [number, number][];\n  }) {\n    if (target[0] > target[1])\n      throw new Error(\n        `Invalid interval: start (${target[0]}) is greater than end (${target[1]})`,\n      );\n\n    this.target = target;\n    this._completed = completed;\n  }\n\n  /**\n   * Adds a completed interval.\n   *\n   * @throws Will throw an error if the new interval is invalid.\n   */\n  addCompletedInterval(interval: [number, number]) {\n    if (interval[0] > interval[1])\n      throw new Error(\n        `Invalid interval: start (${interval[0]}) is greater than end (${interval[1]})`,\n      );\n\n    const prevCheckpoint = this.getCheckpoint();\n    this._completed = intervalUnion([...this._completed, interval]);\n    this.invalidateCache();\n    const newCheckpoint = this.getCheckpoint();\n\n    return {\n      isUpdated: newCheckpoint > prevCheckpoint,\n      prevCheckpoint,\n      newCheckpoint,\n    };\n  }\n\n  /**\n   * Returns the remaining required intervals.\n   */\n  getRequired() {\n    if (this._required === null) {\n      this._required = intervalDifference([this.target], this._completed);\n    }\n    return this._required;\n  }\n\n  /**\n   * Returns the checkpoint value. If no progress has been made, the checkpoint\n   * is equal to the target start minus one.\n   */\n  getCheckpoint() {\n    if (this._checkpoint !== null) return this._checkpoint;\n\n    const completedIntervalIncludingTargetStart = this._completed\n      .sort((a, b) => a[0] - b[0])\n      .find((i) => i[0] <= this.target[0] && i[1] >= this.target[0]);\n\n    if (completedIntervalIncludingTargetStart) {\n      this._checkpoint = completedIntervalIncludingTargetStart[1];\n    } else {\n      this._checkpoint = this.target[0] - 1;\n    }\n\n    return this._checkpoint;\n  }\n\n  private invalidateCache() {\n    this._required = null;\n    this._checkpoint = null;\n  }\n}\n\n/**\n * Need granular writes to db and retries at each step rather than at the task level\n */\n\nexport class BlockProgressTracker {\n  private pendingBlocks: number[] = [];\n  private completedBlocks: {\n    blockNumber: number;\n    blockTimestamp: number;\n  }[] = [];\n\n  checkpoint: { blockNumber: number; blockTimestamp: number } | null = null;\n\n  addPendingBlocks({ blockNumbers }: { blockNumbers: number[] }): void {\n    if (blockNumbers.length === 0) return;\n\n    const maxPendingBlock = this.pendingBlocks[this.pendingBlocks.length - 1]!;\n\n    const sorted = blockNumbers.sort((a, b) => a - b);\n    const minNewPendingBlock = sorted[0]!;\n\n    if (\n      this.pendingBlocks.length > 0 &&\n      minNewPendingBlock <= maxPendingBlock\n    ) {\n      throw new Error(\n        `New pending block number ${minNewPendingBlock} was added out of order. Already added block number ${maxPendingBlock}.`,\n      );\n    }\n\n    sorted.forEach((blockNumber) => {\n      this.pendingBlocks.push(blockNumber);\n    });\n  }\n\n  /**\n   * Add a new completed block. If adding this block moves the checkpoint, returns the\n   * new checkpoint. Otherwise, returns null.\n   */\n  addCompletedBlock({\n    blockNumber,\n    blockTimestamp,\n  }: {\n    blockNumber: number;\n    blockTimestamp: number;\n  }) {\n    // Find and remove the completed block from the pending list.\n    const pendingBlockIndex = this.pendingBlocks.findIndex(\n      (pendingBlock) => pendingBlock === blockNumber,\n    );\n    if (pendingBlockIndex === -1) {\n      throw new Error(\n        `Block number ${blockNumber} was not pending. Ensure to add blocks as pending before marking them as completed.`,\n      );\n    }\n    this.pendingBlocks.splice(pendingBlockIndex, 1);\n\n    // Add the new completed block to the completed block list, and maintain the sort order.\n    // Note that this could be optimized using a for loop with a break.\n    this.completedBlocks.push({ blockNumber, blockTimestamp });\n    this.completedBlocks.sort((a, b) => a.blockNumber - b.blockNumber);\n\n    // If the pending blocks list is now empty, return the max block present in\n    // the list of completed blocks. This happens at the end of the sync.\n    if (this.pendingBlocks.length === 0) {\n      this.checkpoint = this.completedBlocks[this.completedBlocks.length - 1]!;\n      return this.checkpoint;\n    }\n\n    // Find all completed blocks that are less than the minimum pending block.\n    // These blocks are \"safe\".\n    const safeCompletedBlocks = this.completedBlocks.filter(\n      ({ blockNumber }) => blockNumber < this.pendingBlocks[0]!,\n    );\n\n    // If there are no safe blocks, the first pending block has not been completed yet.\n    if (safeCompletedBlocks.length === 0) return null;\n\n    const maximumSafeCompletedBlock =\n      safeCompletedBlocks[safeCompletedBlocks.length - 1]!;\n\n    // Remove all safe completed blocks that are less than the new checkpoint.\n    // This avoid a memory leak and speeds up subsequent calls.\n    this.completedBlocks = this.completedBlocks.filter(\n      ({ blockNumber }) => blockNumber >= maximumSafeCompletedBlock.blockNumber,\n    );\n\n    // If this is the first checkpoint OR this checkpoint is greater than\n    // the previous checkpoint, store and return it as updated.\n    if (\n      !this.checkpoint ||\n      maximumSafeCompletedBlock.blockNumber > this.checkpoint.blockNumber\n    ) {\n      this.checkpoint = maximumSafeCompletedBlock;\n      return this.checkpoint;\n    }\n\n    // Otherwise, the checkpoint is not updated.\n    return null;\n  }\n}\n","/**\n * Generates an array of integers between two bounds. Exclusive on the right.\n *\n * @param start Integer to start at.\n * @param stop Integer to stop at (exclusive).\n */\nexport const range = (start: number, stop: number) =>\n  Array.from({ length: stop - start }, (_, i) => start + i);\n","import type { Common } from \"@/common/common.js\";\nimport { NonRetryableError } from \"@/common/errors.js\";\nimport {\n  type BlockFilterCriteria,\n  type CallTraceFilterCriteria,\n  type CallTraceSource,\n  type EventSource,\n  type FactoryCallTraceFilterCriteria,\n  type FactoryCallTraceSource,\n  type FactoryLogFilterCriteria,\n  type FactoryLogSource,\n  type LogFilterCriteria,\n  type LogSource,\n  sourceIsBlock,\n  sourceIsCallTrace,\n  sourceIsFactoryCallTrace,\n  sourceIsFactoryLog,\n  sourceIsLog,\n} from \"@/config/sources.js\";\nimport type { HeadlessKysely } from \"@/database/kysely.js\";\nimport type {\n  SyncBlock,\n  SyncCallTrace,\n  SyncLog,\n  SyncTransaction,\n  SyncTransactionReceipt,\n} from \"@/sync/index.js\";\nimport type { CallTrace, Log, TransactionReceipt } from \"@/types/eth.js\";\nimport type { NonNull } from \"@/types/utils.js\";\nimport {\n  type Checkpoint,\n  EVENT_TYPES,\n  decodeCheckpoint,\n  encodeCheckpoint,\n  maxCheckpoint,\n  zeroCheckpoint,\n} from \"@/utils/checkpoint.js\";\nimport {\n  buildFactoryLogFragments,\n  buildFactoryTraceFragments,\n  buildLogFilterFragments,\n  buildTraceFragments,\n} from \"@/utils/fragments.js\";\nimport { intervalIntersectionMany, intervalUnion } from \"@/utils/interval.js\";\nimport { range } from \"@/utils/range.js\";\nimport {\n  type ExpressionBuilder,\n  type Transaction as KyselyTransaction,\n  type OperandExpression,\n  type SqlBool,\n  sql,\n} from \"kysely\";\nimport { type Hex, checksumAddress, hexToBigInt, hexToNumber } from \"viem\";\nimport type { RawEvent, SyncStore } from \"../store.js\";\nimport {\n  type InsertableCallTrace,\n  type SyncStoreTables,\n  rpcToPostgresBlock,\n  rpcToPostgresLog,\n  rpcToPostgresTrace,\n  rpcToPostgresTransaction,\n  rpcToPostgresTransactionReceipt,\n} from \"./encoding.js\";\n\nexport class PostgresSyncStore implements SyncStore {\n  kind = \"postgres\" as const;\n  db: HeadlessKysely<SyncStoreTables>;\n  common: Common;\n\n  private seconds: number;\n\n  constructor({\n    db,\n    common,\n  }: { db: HeadlessKysely<SyncStoreTables>; common: Common }) {\n    this.db = db;\n    this.common = common;\n\n    this.seconds = common.options.syncEventsQuerySize * 2;\n  }\n\n  insertLogFilterInterval = async ({\n    chainId,\n    logFilter,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    transactionReceipts: rpcTransactionReceipts,\n    logs: rpcLogs,\n    interval,\n  }: {\n    chainId: number;\n    logFilter: LogFilterCriteria;\n    block: SyncBlock;\n    transactions: SyncTransaction[];\n    transactionReceipts: SyncTransactionReceipt[];\n    logs: SyncLog[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    return this.db.wrap({ method: \"insertLogFilterInterval\" }, async () => {\n      await this.db.transaction().execute(async (tx) => {\n        await tx\n          .insertInto(\"blocks\")\n          .values({\n            ...rpcToPostgresBlock(rpcBlock),\n            chainId,\n            checkpoint: this.createBlockCheckpoint(rpcBlock, chainId),\n          })\n          .onConflict((oc) => oc.column(\"hash\").doNothing())\n          .execute();\n\n        if (rpcTransactions.length > 0) {\n          const transactions = rpcTransactions.map((transaction) => ({\n            ...rpcToPostgresTransaction(transaction),\n            chainId,\n          }));\n          await tx\n            .insertInto(\"transactions\")\n            .values(transactions)\n            .onConflict((oc) => oc.column(\"hash\").doNothing())\n            .execute();\n        }\n\n        if (rpcTransactionReceipts.length > 0) {\n          const transactionReceipts = rpcTransactionReceipts.map(\n            (rpcTransactionReceipt) => ({\n              ...rpcToPostgresTransactionReceipt(rpcTransactionReceipt),\n              chainId,\n            }),\n          );\n          await tx\n            .insertInto(\"transactionReceipts\")\n            .values(transactionReceipts)\n            .onConflict((oc) => oc.column(\"transactionHash\").doNothing())\n            .execute();\n        }\n\n        if (rpcLogs.length > 0) {\n          const logs = rpcLogs.map((rpcLog) => ({\n            ...rpcToPostgresLog(rpcLog),\n            chainId,\n            checkpoint: this.createLogCheckpoint(rpcLog, rpcBlock, chainId),\n          }));\n          await tx\n            .insertInto(\"logs\")\n            .values(logs)\n            .onConflict((oc) =>\n              oc.column(\"id\").doUpdateSet((eb) => ({\n                checkpoint: eb.ref(\"excluded.checkpoint\"),\n              })),\n            )\n            .execute();\n        }\n\n        await this._insertLogFilterInterval({\n          tx,\n          chainId,\n          logFilters: [logFilter],\n          interval,\n        });\n      });\n    });\n  };\n\n  getLogFilterIntervals = async ({\n    chainId,\n    logFilter,\n  }: {\n    chainId: number;\n    logFilter: LogFilterCriteria;\n  }) => {\n    return this.db.wrap({ method: \"getLogFilterIntervals\" }, async () => {\n      const fragments = buildLogFilterFragments({ ...logFilter, chainId });\n\n      // First, attempt to merge overlapping and adjacent intervals.\n      for (const fragment of fragments) {\n        await this.db.transaction().execute(async (tx) => {\n          while (true) {\n            const { id: logFilterId } = await tx\n              .insertInto(\"logFilters\")\n              .values(fragment)\n              .onConflict((oc) => oc.column(\"id\").doUpdateSet(fragment))\n              .returningAll()\n              .executeTakeFirstOrThrow();\n\n            // This is a trick to add a LIMIT to a DELETE statement\n            const existingIntervals = await tx\n              .deleteFrom(\"logFilterIntervals\")\n              .where(\n                \"id\",\n                \"in\",\n                tx\n                  .selectFrom(\"logFilterIntervals\")\n                  .where(\"logFilterId\", \"=\", logFilterId)\n                  .select(\"id\")\n                  .limit(this.common.options.syncStoreMaxIntervals),\n              )\n              .returning([\"startBlock\", \"endBlock\"])\n              .execute();\n\n            const mergedIntervals = intervalUnion(\n              existingIntervals.map((i) => [\n                Number(i.startBlock),\n                Number(i.endBlock),\n              ]),\n            );\n\n            const mergedIntervalRows = mergedIntervals.map(\n              ([startBlock, endBlock]) => ({\n                logFilterId,\n                startBlock: BigInt(startBlock),\n                endBlock: BigInt(endBlock),\n              }),\n            );\n\n            if (mergedIntervalRows.length > 0) {\n              await tx\n                .insertInto(\"logFilterIntervals\")\n                .values(mergedIntervalRows)\n                .execute();\n            }\n\n            if (\n              mergedIntervalRows.length ===\n              this.common.options.syncStoreMaxIntervals\n            ) {\n              // This occurs when there are too many non-mergeable ranges with the same logFilterId. Should be almost impossible.\n              throw new NonRetryableError(\n                `'logFilterIntervals' table for chain '${chainId}' has reached an unrecoverable level of fragmentation.`,\n              );\n            }\n\n            if (\n              existingIntervals.length !==\n              this.common.options.syncStoreMaxIntervals\n            )\n              break;\n          }\n        });\n      }\n\n      const intervals = await this.db\n        .with(\n          \"logFilterFragments(fragmentId, fragmentAddress, fragmentTopic0, fragmentTopic1, fragmentTopic2, fragmentTopic3, fragmentIncludeTransactionReceipts)\",\n          () =>\n            sql`( values ${sql.join(\n              fragments.map(\n                (f) =>\n                  sql`( ${sql.val(f.id)}, ${sql.val(f.address)}, ${sql.val(f.topic0)}, ${sql.val(\n                    f.topic1,\n                  )}, ${sql.val(f.topic2)}, ${sql.val(f.topic3)}, ${sql.lit(\n                    f.includeTransactionReceipts,\n                  )} )`,\n              ),\n            )} )`,\n        )\n        .selectFrom(\"logFilterIntervals\")\n        .innerJoin(\"logFilters\", \"logFilterId\", \"logFilters.id\")\n        .innerJoin(\"logFilterFragments\", (join) => {\n          let baseJoin = join.on((eb) =>\n            eb.or([\n              eb(\"address\", \"is\", null),\n              eb(\"fragmentAddress\", \"=\", sql.ref(\"address\")),\n            ]),\n          );\n          baseJoin = baseJoin.on((eb) =>\n            eb(\n              \"fragmentIncludeTransactionReceipts\",\n              \"<=\",\n              sql.ref(\"includeTransactionReceipts\"),\n            ),\n          );\n          for (const idx_ of range(0, 4)) {\n            baseJoin = baseJoin.on((eb) => {\n              const idx = idx_ as 0 | 1 | 2 | 3;\n              return eb.or([\n                eb(`topic${idx}`, \"is\", null),\n                eb(`fragmentTopic${idx}`, \"=\", sql.ref(`topic${idx}`)),\n              ]);\n            });\n          }\n\n          return baseJoin;\n        })\n        .select([\"fragmentId\", \"startBlock\", \"endBlock\"])\n        .where(\"chainId\", \"=\", chainId)\n        .execute();\n\n      const intervalsByFragmentId = intervals.reduce(\n        (acc, cur) => {\n          const { fragmentId, startBlock, endBlock } = cur;\n          (acc[fragmentId] ||= []).push([Number(startBlock), Number(endBlock)]);\n          return acc;\n        },\n        {} as Record<string, [number, number][]>,\n      );\n\n      const intervalsForEachFragment = fragments.map((f) =>\n        intervalUnion(intervalsByFragmentId[f.id] ?? []),\n      );\n      return intervalIntersectionMany(intervalsForEachFragment);\n    });\n  };\n\n  insertFactoryChildAddressLogs = async ({\n    chainId,\n    logs: rpcLogs,\n  }: {\n    chainId: number;\n    logs: SyncLog[];\n  }) => {\n    return this.db.wrap(\n      { method: \"insertFactoryChildAddressLogs\" },\n      async () => {\n        if (rpcLogs.length > 0) {\n          const logs = rpcLogs.map((rpcLog) => ({\n            ...rpcToPostgresLog(rpcLog),\n            chainId,\n          }));\n          await this.db\n            .insertInto(\"logs\")\n            .values(logs)\n            .onConflict((oc) => oc.column(\"id\").doNothing())\n            .execute();\n        }\n      },\n    );\n  };\n\n  async *getFactoryChildAddresses({\n    chainId,\n    fromBlock,\n    toBlock,\n    factory,\n    pageSize = 500,\n  }: {\n    chainId: number;\n    fromBlock: bigint;\n    toBlock: bigint;\n    factory: FactoryLogFilterCriteria | FactoryCallTraceFilterCriteria;\n    pageSize?: number;\n  }) {\n    const { address, eventSelector, childAddressLocation } = factory;\n    const selectChildAddressExpression =\n      buildFactoryChildAddressSelectExpression({\n        childAddressLocation,\n      });\n\n    const baseQuery = this.db\n      .selectFrom(\"logs\")\n      .select([\"id\", selectChildAddressExpression.as(\"childAddress\")])\n      .where(\"chainId\", \"=\", chainId)\n      .where(\"address\", \"=\", address)\n      .where(\"topic0\", \"=\", eventSelector)\n      .where(\"blockNumber\", \">=\", fromBlock)\n      .where(\"blockNumber\", \"<=\", toBlock)\n      .orderBy(\"id\", \"asc\")\n      .limit(pageSize);\n\n    let cursor: string | undefined = undefined;\n\n    while (true) {\n      let query = baseQuery;\n      if (cursor !== undefined) query = query.where(\"id\", \">\", cursor);\n\n      const batch = await this.db.wrap(\n        { method: \"getFactoryChildAddresses\" },\n        () => query.execute(),\n      );\n\n      if (batch.length > 0) {\n        yield batch.map((a) => a.childAddress);\n      }\n\n      // If the batch is less than the page size, there are no more pages.\n      if (batch.length < pageSize) break;\n      // Otherwise, set the cursor to the last block number in the batch.\n      cursor = batch[batch.length - 1]!.id;\n    }\n  }\n\n  insertFactoryLogFilterInterval = async ({\n    chainId,\n    factory,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    transactionReceipts: rpcTransactionReceipts,\n    logs: rpcLogs,\n    interval,\n  }: {\n    chainId: number;\n    factory: FactoryLogFilterCriteria;\n    block: SyncBlock;\n    transactions: SyncTransaction[];\n    transactionReceipts: SyncTransactionReceipt[];\n    logs: SyncLog[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    return this.db.wrap(\n      { method: \"insertFactoryLogFilterInterval\" },\n      async () => {\n        await this.db.transaction().execute(async (tx) => {\n          await tx\n            .insertInto(\"blocks\")\n            .values({\n              ...rpcToPostgresBlock(rpcBlock),\n              chainId,\n              checkpoint: this.createBlockCheckpoint(rpcBlock, chainId),\n            })\n            .onConflict((oc) => oc.column(\"hash\").doNothing())\n            .execute();\n\n          if (rpcTransactions.length > 0) {\n            const transactions = rpcTransactions.map((transaction) => ({\n              ...rpcToPostgresTransaction(transaction),\n              chainId,\n            }));\n            await tx\n              .insertInto(\"transactions\")\n              .values(transactions)\n              .onConflict((oc) => oc.column(\"hash\").doNothing())\n              .execute();\n          }\n\n          if (rpcTransactionReceipts.length > 0) {\n            const transactionReceipts = rpcTransactionReceipts.map(\n              (rpcTransactionReceipt) => ({\n                ...rpcToPostgresTransactionReceipt(rpcTransactionReceipt),\n                chainId,\n              }),\n            );\n            await tx\n              .insertInto(\"transactionReceipts\")\n              .values(transactionReceipts)\n              .onConflict((oc) => oc.column(\"transactionHash\").doNothing())\n              .execute();\n          }\n\n          if (rpcLogs.length > 0) {\n            const logs = rpcLogs.map((rpcLog) => ({\n              ...rpcToPostgresLog(rpcLog),\n              chainId,\n              checkpoint: this.createLogCheckpoint(rpcLog, rpcBlock, chainId),\n            }));\n\n            await tx\n              .insertInto(\"logs\")\n              .values(logs)\n              .onConflict((oc) =>\n                oc.column(\"id\").doUpdateSet((eb) => ({\n                  checkpoint: eb.ref(\"excluded.checkpoint\"),\n                })),\n              )\n              .execute();\n          }\n\n          await this._insertFactoryLogFilterInterval({\n            tx,\n            chainId,\n            factoryLogFilters: [factory],\n            interval,\n          });\n        });\n      },\n    );\n  };\n\n  getFactoryLogFilterIntervals = async ({\n    chainId,\n    factory,\n  }: {\n    chainId: number;\n    factory: FactoryLogFilterCriteria;\n  }) => {\n    return this.db.wrap(\n      { method: \"getFactoryLogFilterIntervals\" },\n      async () => {\n        const fragments = buildFactoryLogFragments({ ...factory, chainId });\n\n        for (const fragment of fragments) {\n          await this.db.transaction().execute(async (tx) => {\n            while (true) {\n              const { id: factoryId } = await tx\n                .insertInto(\"factoryLogFilters\")\n                .values(fragment)\n                .onConflict((oc) => oc.column(\"id\").doUpdateSet(fragment))\n                .returningAll()\n                .executeTakeFirstOrThrow();\n\n              // This is a trick to add a LIMIT to a DELETE statement\n              const existingIntervals = await tx\n                .deleteFrom(\"factoryLogFilterIntervals\")\n                .where(\n                  \"id\",\n                  \"in\",\n                  tx\n                    .selectFrom(\"factoryLogFilterIntervals\")\n                    .where(\"factoryId\", \"=\", factoryId)\n                    .select(\"id\")\n                    .limit(this.common.options.syncStoreMaxIntervals),\n                )\n                .returning([\"startBlock\", \"endBlock\"])\n                .execute();\n\n              const mergedIntervals = intervalUnion(\n                existingIntervals.map((i) => [\n                  Number(i.startBlock),\n                  Number(i.endBlock),\n                ]),\n              );\n\n              const mergedIntervalRows = mergedIntervals.map(\n                ([startBlock, endBlock]) => ({\n                  factoryId,\n                  startBlock: BigInt(startBlock),\n                  endBlock: BigInt(endBlock),\n                }),\n              );\n\n              if (mergedIntervalRows.length > 0) {\n                await tx\n                  .insertInto(\"factoryLogFilterIntervals\")\n                  .values(mergedIntervalRows)\n                  .execute();\n              }\n\n              if (\n                mergedIntervalRows.length ===\n                this.common.options.syncStoreMaxIntervals\n              ) {\n                // This occurs when there are too many non-mergeable ranges with the same factoryId. Should be almost impossible.\n                throw new NonRetryableError(\n                  `'factoryLogFilterIntervals' table for chain '${chainId}' has reached an unrecoverable level of fragmentation.`,\n                );\n              }\n\n              if (\n                existingIntervals.length !==\n                this.common.options.syncStoreMaxIntervals\n              )\n                break;\n            }\n          });\n        }\n\n        const intervals = await this.db\n          .with(\n            \"factoryFilterFragments(fragmentId, fragmentAddress, fragmentEventSelector, fragmentChildAddressLocation, fragmentTopic0, fragmentTopic1, fragmentTopic2, fragmentTopic3, fragmentIncludeTransactionReceipts)\",\n            () =>\n              sql`( values ${sql.join(\n                fragments.map(\n                  (f) =>\n                    sql`( ${sql.val(f.id)}, ${sql.val(f.address)}, ${sql.val(\n                      f.eventSelector,\n                    )}, ${sql.val(f.childAddressLocation)}, ${sql.val(f.topic0)}, ${sql.val(\n                      f.topic1,\n                    )}, ${sql.val(f.topic2)}, ${sql.val(f.topic3)}, ${sql.lit(\n                      f.includeTransactionReceipts,\n                    )} )`,\n                ),\n              )} )`,\n          )\n          .selectFrom(\"factoryLogFilterIntervals\")\n          .innerJoin(\"factoryLogFilters\", \"factoryId\", \"factoryLogFilters.id\")\n          .innerJoin(\"factoryFilterFragments\", (join) => {\n            let baseJoin = join.on((eb) =>\n              eb.and([\n                eb(\"fragmentAddress\", \"=\", sql.ref(\"address\")),\n                eb(\"fragmentEventSelector\", \"=\", sql.ref(\"eventSelector\")),\n                eb(\n                  \"fragmentChildAddressLocation\",\n                  \"=\",\n                  sql.ref(\"childAddressLocation\"),\n                ),\n              ]),\n            );\n            baseJoin = baseJoin.on((eb) =>\n              eb(\n                \"fragmentIncludeTransactionReceipts\",\n                \"<=\",\n                sql.ref(\"includeTransactionReceipts\"),\n              ),\n            );\n            for (const idx_ of range(0, 4)) {\n              baseJoin = baseJoin.on((eb) => {\n                const idx = idx_ as 0 | 1 | 2 | 3;\n                return eb.or([\n                  eb(`topic${idx}`, \"is\", null),\n                  eb(`fragmentTopic${idx}`, \"=\", sql.ref(`topic${idx}`)),\n                ]);\n              });\n            }\n\n            return baseJoin;\n          })\n          .select([\"fragmentId\", \"startBlock\", \"endBlock\"])\n          .where(\"chainId\", \"=\", chainId)\n          .execute();\n\n        const intervalsByFragmentId = intervals.reduce(\n          (acc, cur) => {\n            const { fragmentId, startBlock, endBlock } = cur;\n            (acc[fragmentId] ||= []).push([\n              Number(startBlock),\n              Number(endBlock),\n            ]);\n            return acc;\n          },\n          {} as Record<string, [number, number][]>,\n        );\n\n        const intervalsForEachFragment = fragments.map((f) =>\n          intervalUnion(intervalsByFragmentId[f.id] ?? []),\n        );\n        return intervalIntersectionMany(intervalsForEachFragment);\n      },\n    );\n  };\n\n  insertBlockFilterInterval = async ({\n    chainId,\n    blockFilter,\n    block: rpcBlock,\n    interval,\n  }: {\n    chainId: number;\n    blockFilter: BlockFilterCriteria;\n    block?: SyncBlock;\n    interval: { startBlock: bigint; endBlock: bigint };\n  }): Promise<void> => {\n    return this.db.wrap({ method: \"insertBlockFilterInterval\" }, async () => {\n      await this.db.transaction().execute(async (tx) => {\n        if (rpcBlock !== undefined) {\n          await tx\n            .insertInto(\"blocks\")\n            .values({\n              ...rpcToPostgresBlock(rpcBlock),\n              chainId,\n              checkpoint: this.createBlockCheckpoint(rpcBlock, chainId),\n            })\n            .onConflict((oc) => oc.column(\"hash\").doNothing())\n            .execute();\n        }\n\n        await this._insertBlockFilterInterval({\n          tx,\n          chainId,\n          blockFilters: [blockFilter],\n          interval,\n        });\n      });\n    });\n  };\n\n  getBlockFilterIntervals = async ({\n    chainId,\n    blockFilter,\n  }: {\n    chainId: number;\n    blockFilter: BlockFilterCriteria;\n  }) => {\n    return this.db.wrap({ method: \"getBlockFilterIntervals\" }, async () => {\n      const fragment = {\n        id: `${chainId}_${blockFilter.interval}_${blockFilter.offset}`,\n        chainId,\n        interval: blockFilter.interval,\n        offset: blockFilter.offset,\n      };\n\n      // First, attempt to merge overlapping and adjacent intervals.\n      await this.db.transaction().execute(async (tx) => {\n        const { id: blockFilterId } = await tx\n          .insertInto(\"blockFilters\")\n          .values(fragment)\n          .onConflict((oc) => oc.column(\"id\").doUpdateSet(fragment))\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        const existingIntervalRows = await tx\n          .deleteFrom(\"blockFilterIntervals\")\n          .where(\"blockFilterId\", \"=\", blockFilterId)\n          .returningAll()\n          .execute();\n\n        const mergedIntervals = intervalUnion(\n          existingIntervalRows.map((i) => [\n            Number(i.startBlock),\n            Number(i.endBlock),\n          ]),\n        );\n\n        const mergedIntervalRows = mergedIntervals.map(\n          ([startBlock, endBlock]) => ({\n            blockFilterId,\n            startBlock: BigInt(startBlock),\n            endBlock: BigInt(endBlock),\n          }),\n        );\n\n        if (mergedIntervalRows.length > 0) {\n          await tx\n            .insertInto(\"blockFilterIntervals\")\n            .values(mergedIntervalRows)\n            .execute();\n        }\n      });\n\n      const intervals = await this.db\n        .selectFrom(\"blockFilterIntervals\")\n        .innerJoin(\"blockFilters\", \"blockFilterId\", \"blockFilters.id\")\n        .select([\n          \"blockFilterIntervals.startBlock\",\n          \"blockFilterIntervals.endBlock\",\n        ])\n        .where(\"blockFilterId\", \"=\", fragment.id)\n        .execute();\n\n      return intervals.map(\n        ({ startBlock, endBlock }) =>\n          [Number(startBlock), Number(endBlock)] as [number, number],\n      );\n    });\n  };\n\n  getBlock = async ({\n    chainId,\n    blockNumber,\n  }: {\n    chainId: number;\n    blockNumber: number;\n  }): Promise<boolean> => {\n    const hasBlock = await this.db\n      .selectFrom(\"blocks\")\n      .select(\"hash\")\n      .where(\"number\", \"=\", BigInt(blockNumber))\n      .where(\"chainId\", \"=\", chainId)\n      .executeTakeFirst();\n\n    return hasBlock !== undefined;\n  };\n\n  insertTraceFilterInterval = async ({\n    chainId,\n    traceFilter,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    transactionReceipts: rpcTransactionReceipts,\n    traces: rpcTraces,\n    interval,\n  }: {\n    chainId: number;\n    traceFilter: CallTraceFilterCriteria;\n    block: SyncBlock;\n    transactions: SyncTransaction[];\n    transactionReceipts: SyncTransactionReceipt[];\n    traces: SyncCallTrace[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    return this.db.wrap({ method: \"insertTraceFilterInterval\" }, async () => {\n      await this.db.transaction().execute(async (tx) => {\n        await tx\n          .insertInto(\"blocks\")\n          .values({\n            ...rpcToPostgresBlock(rpcBlock),\n            chainId,\n            checkpoint: this.createBlockCheckpoint(rpcBlock, chainId),\n          })\n          .onConflict((oc) => oc.column(\"hash\").doNothing())\n          .execute();\n\n        if (rpcTransactions.length > 0) {\n          const transactions = rpcTransactions.map((transaction) => ({\n            ...rpcToPostgresTransaction(transaction),\n            chainId,\n          }));\n          await tx\n            .insertInto(\"transactions\")\n            .values(transactions)\n            .onConflict((oc) => oc.column(\"hash\").doNothing())\n            .execute();\n        }\n\n        if (rpcTransactionReceipts.length > 0) {\n          const transactionReceipts = rpcTransactionReceipts.map(\n            (rpcTransactionReceipt) => ({\n              ...rpcToPostgresTransactionReceipt(rpcTransactionReceipt),\n              chainId,\n            }),\n          );\n          await tx\n            .insertInto(\"transactionReceipts\")\n            .values(transactionReceipts)\n            .onConflict((oc) => oc.column(\"transactionHash\").doNothing())\n            .execute();\n        }\n\n        // Delete existing traces with the same `transactionHash`. Then, calculate \"callTraces.checkpoint\"\n        // based on the ordering of \"callTraces.traceAddress\" and add all traces to \"callTraces\" table.\n        const traceByTransactionHash: {\n          [transactionHash: Hex]: SyncCallTrace[];\n        } = {};\n        for (const trace of rpcTraces) {\n          if (traceByTransactionHash[trace.transactionHash] === undefined) {\n            traceByTransactionHash[trace.transactionHash] = [];\n          }\n          traceByTransactionHash[trace.transactionHash]!.push(trace);\n        }\n\n        for (const transactionHash of Object.keys(traceByTransactionHash)) {\n          const traces = await tx\n            .deleteFrom(\"callTraces\")\n            .returningAll()\n            .where(\"transactionHash\", \"=\", transactionHash as Hex)\n            .where(\"chainId\", \"=\", chainId)\n            .execute();\n\n          (traces as Omit<InsertableCallTrace, \"checkpoint\">[]).push(\n            ...traceByTransactionHash[transactionHash as Hex]!.map((trace) => ({\n              ...rpcToPostgresTrace(trace),\n              chainId,\n            })),\n          );\n\n          // Use lexographical sort of stringified `traceAddress`.\n          traces.sort((a, b) => {\n            return a.traceAddress < b.traceAddress ? -1 : 1;\n          });\n\n          for (let i = 0; i < traces.length; i++) {\n            const trace = traces[i]!;\n            const checkpoint = encodeCheckpoint({\n              blockTimestamp: hexToNumber(rpcBlock.timestamp),\n              chainId: BigInt(chainId),\n              blockNumber: trace.blockNumber,\n              transactionIndex: BigInt(trace.transactionPosition),\n              eventType: EVENT_TYPES.callTraces,\n              eventIndex: BigInt(i),\n            });\n\n            trace.checkpoint = checkpoint;\n          }\n\n          await tx\n            .insertInto(\"callTraces\")\n            .values(traces)\n            .onConflict((oc) => oc.column(\"id\").doNothing())\n            .execute();\n        }\n\n        await this._insertTraceFilterInterval({\n          tx,\n          chainId,\n          traceFilters: [traceFilter],\n          interval,\n        });\n      });\n    });\n  };\n\n  getTraceFilterIntervals = async ({\n    traceFilter,\n    chainId,\n  }: {\n    chainId: number;\n    traceFilter: CallTraceFilterCriteria;\n  }) => {\n    return this.db.wrap({ method: \"getTraceFilterIntervals\" }, async () => {\n      const fragments = buildTraceFragments({ ...traceFilter, chainId });\n\n      // First, attempt to merge overlapping and adjacent intervals.\n      for (const fragment of fragments) {\n        await this.db.transaction().execute(async (tx) => {\n          while (true) {\n            const { id: traceFilterId } = await tx\n              .insertInto(\"traceFilters\")\n              .values(fragment)\n              .onConflict((oc) => oc.column(\"id\").doUpdateSet(fragment))\n              .returningAll()\n              .executeTakeFirstOrThrow();\n\n            // This is a trick to add a LIMIT to a DELETE statement This is a trick to add a LIMIT to a DELETE statement\n            const existingIntervals = await tx\n              .deleteFrom(\"traceFilterIntervals\")\n              .where(\n                \"id\",\n                \"in\",\n                tx\n                  .selectFrom(\"traceFilterIntervals\")\n                  .where(\"traceFilterId\", \"=\", traceFilterId)\n                  .select(\"id\")\n                  .limit(this.common.options.syncStoreMaxIntervals),\n              )\n              .returning([\"startBlock\", \"endBlock\"])\n              .execute();\n\n            const mergedIntervals = intervalUnion(\n              existingIntervals.map((i) => [\n                Number(i.startBlock),\n                Number(i.endBlock),\n              ]),\n            );\n\n            const mergedIntervalRows = mergedIntervals.map(\n              ([startBlock, endBlock]) => ({\n                traceFilterId,\n                startBlock: BigInt(startBlock),\n                endBlock: BigInt(endBlock),\n              }),\n            );\n\n            if (mergedIntervalRows.length > 0) {\n              await tx\n                .insertInto(\"traceFilterIntervals\")\n                .values(mergedIntervalRows)\n                .execute();\n            }\n\n            if (\n              mergedIntervalRows.length ===\n              this.common.options.syncStoreMaxIntervals\n            ) {\n              // This occurs when there are too many non-mergeable ranges with the same factoryId. Should be almost impossible.\n              throw new NonRetryableError(\n                `'traceFilterIntervals' table for chain '${chainId}' has reached an unrecoverable level of fragmentation.`,\n              );\n            }\n\n            if (\n              existingIntervals.length !==\n              this.common.options.syncStoreMaxIntervals\n            )\n              break;\n          }\n        });\n      }\n\n      const intervals = await this.db\n        .with(\n          \"traceFilterFragments(fragmentId, fragmentFromAddress, fragmentToAddress)\",\n          () =>\n            sql`( values ${sql.join(\n              fragments.map(\n                (f) =>\n                  sql`( ${sql.val(f.id)}, ${sql.val(f.fromAddress)}, ${sql.val(f.toAddress)} )`,\n              ),\n            )} )`,\n        )\n        .selectFrom(\"traceFilterIntervals\")\n        .innerJoin(\"traceFilters\", \"traceFilterId\", \"traceFilters.id\")\n        .innerJoin(\"traceFilterFragments\", (join) => {\n          return join.on((eb) =>\n            eb.and([\n              eb.or([\n                eb(\"fromAddress\", \"is\", null),\n                eb(\"fragmentFromAddress\", \"=\", sql.ref(\"fromAddress\")),\n              ]),\n              eb.or([\n                eb(\"toAddress\", \"is\", null),\n                eb(\"fragmentToAddress\", \"=\", sql.ref(\"toAddress\")),\n              ]),\n            ]),\n          );\n        })\n        .select([\"fragmentId\", \"startBlock\", \"endBlock\"])\n        .where(\"chainId\", \"=\", chainId)\n        .execute();\n\n      const intervalsByFragmentId = intervals.reduce(\n        (acc, cur) => {\n          const { fragmentId, startBlock, endBlock } = cur;\n          (acc[fragmentId] ||= []).push([Number(startBlock), Number(endBlock)]);\n          return acc;\n        },\n        {} as Record<string, [number, number][]>,\n      );\n\n      const intervalsForEachFragment = fragments.map((f) =>\n        intervalUnion(intervalsByFragmentId[f.id] ?? []),\n      );\n      return intervalIntersectionMany(intervalsForEachFragment);\n    });\n  };\n\n  insertFactoryTraceFilterInterval = async ({\n    chainId,\n    factory,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    transactionReceipts: rpcTransactionReceipts,\n    traces: rpcTraces,\n    interval,\n  }: {\n    chainId: number;\n    factory: FactoryCallTraceFilterCriteria;\n    block: SyncBlock;\n    transactions: SyncTransaction[];\n    transactionReceipts: SyncTransactionReceipt[];\n    traces: SyncCallTrace[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    return this.db.wrap(\n      { method: \"insertFactoryTraceFilterInterval\" },\n      async () => {\n        await this.db.transaction().execute(async (tx) => {\n          await tx\n            .insertInto(\"blocks\")\n            .values({\n              ...rpcToPostgresBlock(rpcBlock),\n              chainId,\n              checkpoint: this.createBlockCheckpoint(rpcBlock, chainId),\n            })\n            .onConflict((oc) => oc.column(\"hash\").doNothing())\n            .execute();\n\n          if (rpcTransactions.length > 0) {\n            const transactions = rpcTransactions.map((rpcTransaction) => ({\n              ...rpcToPostgresTransaction(rpcTransaction),\n              chainId,\n            }));\n            await tx\n              .insertInto(\"transactions\")\n              .values(transactions)\n              .onConflict((oc) => oc.column(\"hash\").doNothing())\n              .execute();\n          }\n\n          if (rpcTransactionReceipts.length > 0) {\n            const transactionReceipts = rpcTransactionReceipts.map(\n              (rpcTransactionReceipt) => ({\n                ...rpcToPostgresTransactionReceipt(rpcTransactionReceipt),\n                chainId,\n              }),\n            );\n            await tx\n              .insertInto(\"transactionReceipts\")\n              .values(transactionReceipts)\n              .onConflict((oc) => oc.column(\"transactionHash\").doNothing())\n              .execute();\n          }\n\n          // Delete existing traces with the same `transactionHash`. Then, calculate \"callTraces.checkpoint\"\n          // based on the ordering of \"callTraces.traceAddress\" and add all traces to \"callTraces\" table.\n          const traceByTransactionHash: {\n            [transactionHash: Hex]: SyncCallTrace[];\n          } = {};\n          for (const trace of rpcTraces) {\n            if (traceByTransactionHash[trace.transactionHash] === undefined) {\n              traceByTransactionHash[trace.transactionHash] = [];\n            }\n            traceByTransactionHash[trace.transactionHash]!.push(trace);\n          }\n\n          for (const transactionHash of Object.keys(traceByTransactionHash)) {\n            const traces = await tx\n              .deleteFrom(\"callTraces\")\n              .returningAll()\n              .where(\"transactionHash\", \"=\", transactionHash as Hex)\n              .where(\"chainId\", \"=\", chainId)\n              .execute();\n\n            (traces as Omit<InsertableCallTrace, \"checkpoint\">[]).push(\n              ...traceByTransactionHash[transactionHash as Hex]!.map(\n                (trace) => ({\n                  ...rpcToPostgresTrace(trace),\n                  chainId,\n                }),\n              ),\n            );\n\n            // Use lexographical sort of stringified `traceAddress`.\n            traces.sort((a, b) => {\n              return a.traceAddress < b.traceAddress ? -1 : 1;\n            });\n\n            for (let i = 0; i < traces.length; i++) {\n              const trace = traces[i]!;\n              const checkpoint = encodeCheckpoint({\n                blockTimestamp: hexToNumber(rpcBlock.timestamp),\n                chainId: BigInt(chainId),\n                blockNumber: trace.blockNumber,\n                transactionIndex: BigInt(trace.transactionPosition),\n                eventType: EVENT_TYPES.callTraces,\n                eventIndex: BigInt(i),\n              });\n\n              trace.checkpoint = checkpoint;\n            }\n\n            await tx\n              .insertInto(\"callTraces\")\n              .values(traces)\n              .onConflict((oc) => oc.column(\"id\").doNothing())\n              .execute();\n          }\n\n          await this._insertFactoryTraceFilterInterval({\n            tx,\n            chainId,\n            factoryTraceFilters: [factory],\n            interval,\n          });\n        });\n      },\n    );\n  };\n\n  getFactoryTraceFilterIntervals = async ({\n    chainId,\n    factory,\n  }: {\n    chainId: number;\n    factory: FactoryCallTraceFilterCriteria;\n  }) => {\n    return this.db.wrap(\n      { method: \"getFactoryLogFilterIntervals\" },\n      async () => {\n        const fragments = buildFactoryTraceFragments({ ...factory, chainId });\n\n        for (const fragment of fragments) {\n          await this.db.transaction().execute(async (tx) => {\n            while (true) {\n              const { id: factoryId } = await tx\n                .insertInto(\"factoryTraceFilters\")\n                .values(fragment)\n                .onConflict((oc) => oc.column(\"id\").doUpdateSet(fragment))\n                .returningAll()\n                .executeTakeFirstOrThrow();\n\n              // This is a trick to add a LIMIT to a DELETE statement\n              const existingIntervals = await tx\n                .deleteFrom(\"factoryTraceFilterIntervals\")\n                .where(\n                  \"id\",\n                  \"in\",\n                  tx\n                    .selectFrom(\"factoryTraceFilterIntervals\")\n                    .where(\"factoryId\", \"=\", factoryId)\n                    .select(\"id\")\n                    .limit(this.common.options.syncStoreMaxIntervals),\n                )\n                .returning([\"startBlock\", \"endBlock\"])\n                .execute();\n\n              const mergedIntervals = intervalUnion(\n                existingIntervals.map((i) => [\n                  Number(i.startBlock),\n                  Number(i.endBlock),\n                ]),\n              );\n\n              const mergedIntervalRows = mergedIntervals.map(\n                ([startBlock, endBlock]) => ({\n                  factoryId,\n                  startBlock: BigInt(startBlock),\n                  endBlock: BigInt(endBlock),\n                }),\n              );\n\n              if (mergedIntervalRows.length > 0) {\n                await tx\n                  .insertInto(\"factoryTraceFilterIntervals\")\n                  .values(mergedIntervalRows)\n                  .execute();\n              }\n\n              if (\n                mergedIntervalRows.length ===\n                this.common.options.syncStoreMaxIntervals\n              ) {\n                // This occurs when there are too many non-mergeable ranges with the same factoryId. Should be almost impossible.\n                throw new NonRetryableError(\n                  `'factoryTraceFilterIntervals' table for chain '${chainId}' has reached an unrecoverable level of fragmentation.`,\n                );\n              }\n\n              if (\n                existingIntervals.length !==\n                this.common.options.syncStoreMaxIntervals\n              )\n                break;\n            }\n          });\n        }\n\n        const intervals = await this.db\n          .with(\n            \"factoryFilterFragments(fragmentId, fragmentAddress, fragmentEventSelector, fragmentChildAddressLocation, fragmentFromAddress)\",\n            () =>\n              sql`( values ${sql.join(\n                fragments.map(\n                  (f) =>\n                    sql`( ${sql.val(f.id)}, ${sql.val(f.address)}, ${sql.val(\n                      f.eventSelector,\n                    )}, ${sql.val(f.childAddressLocation)}, ${sql.val(f.fromAddress)} )`,\n                ),\n              )} )`,\n          )\n          .selectFrom(\"factoryTraceFilterIntervals\")\n          .innerJoin(\n            \"factoryTraceFilters\",\n            \"factoryId\",\n            \"factoryTraceFilters.id\",\n          )\n          .innerJoin(\"factoryFilterFragments\", (join) =>\n            join.on((eb) =>\n              eb.and([\n                eb(\"fragmentAddress\", \"=\", sql.ref(\"address\")),\n                eb(\"fragmentEventSelector\", \"=\", sql.ref(\"eventSelector\")),\n                eb(\n                  \"fragmentChildAddressLocation\",\n                  \"=\",\n                  sql.ref(\"childAddressLocation\"),\n                ),\n                eb.or([\n                  eb(\"fromAddress\", \"is\", null),\n                  eb(\"fragmentFromAddress\", \"=\", sql.ref(\"fromAddress\")),\n                ]),\n              ]),\n            ),\n          )\n          .select([\"fragmentId\", \"startBlock\", \"endBlock\"])\n          .where(\"chainId\", \"=\", chainId)\n          .execute();\n\n        const intervalsByFragmentId = intervals.reduce(\n          (acc, cur) => {\n            const { fragmentId, startBlock, endBlock } = cur;\n            (acc[fragmentId] ||= []).push([\n              Number(startBlock),\n              Number(endBlock),\n            ]);\n            return acc;\n          },\n          {} as Record<string, [number, number][]>,\n        );\n\n        const intervalsForEachFragment = fragments.map((f) =>\n          intervalUnion(intervalsByFragmentId[f.id] ?? []),\n        );\n        return intervalIntersectionMany(intervalsForEachFragment);\n      },\n    );\n  };\n\n  private createLogCheckpoint = (\n    log: SyncLog,\n    block: SyncBlock,\n    chainId: number,\n  ) => {\n    return encodeCheckpoint({\n      blockTimestamp: Number(BigInt(block.timestamp)),\n      chainId: BigInt(chainId),\n      blockNumber: hexToBigInt(block.number),\n      transactionIndex: hexToBigInt(log.transactionIndex),\n      eventType: EVENT_TYPES.logs,\n      eventIndex: hexToBigInt(log.logIndex),\n    });\n  };\n\n  private createBlockCheckpoint = (block: SyncBlock, chainId: number) => {\n    return encodeCheckpoint({\n      blockTimestamp: hexToNumber(block.timestamp),\n      chainId: BigInt(chainId),\n      blockNumber: hexToBigInt(block.number),\n      transactionIndex: maxCheckpoint.transactionIndex,\n      eventType: EVENT_TYPES.blocks,\n      eventIndex: zeroCheckpoint.eventIndex,\n    });\n  };\n\n  insertRealtimeBlock = async ({\n    chainId,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    transactionReceipts: rpcTransactionReceipts,\n    logs: rpcLogs,\n    traces: rpcTraces,\n  }: {\n    chainId: number;\n    block: SyncBlock;\n    transactions: SyncTransaction[];\n    transactionReceipts: SyncTransactionReceipt[];\n    logs: SyncLog[];\n    traces: SyncCallTrace[];\n  }) => {\n    return this.db.wrap({ method: \"insertRealtimeBlock\" }, async () => {\n      await this.db.transaction().execute(async (tx) => {\n        await tx\n          .insertInto(\"blocks\")\n          .values({\n            ...rpcToPostgresBlock(rpcBlock),\n            chainId,\n            checkpoint: this.createBlockCheckpoint(rpcBlock, chainId),\n          })\n          .onConflict((oc) => oc.column(\"hash\").doNothing())\n          .execute();\n\n        if (rpcTransactions.length > 0) {\n          const transactions = rpcTransactions.map((transaction) => ({\n            ...rpcToPostgresTransaction(transaction),\n            chainId,\n          }));\n          await tx\n            .insertInto(\"transactions\")\n            .values(transactions)\n            .onConflict((oc) =>\n              oc.column(\"hash\").doUpdateSet((eb) => ({\n                blockHash: eb.ref(\"excluded.blockHash\"),\n                blockNumber: eb.ref(\"excluded.blockNumber\"),\n                transactionIndex: eb.ref(\"excluded.transactionIndex\"),\n              })),\n            )\n            .execute();\n        }\n\n        if (rpcTransactionReceipts.length > 0) {\n          const transactionReceipts = rpcTransactionReceipts.map(\n            (rpcTransactionReceipt) => ({\n              ...rpcToPostgresTransactionReceipt(rpcTransactionReceipt),\n              chainId,\n            }),\n          );\n          await tx\n            .insertInto(\"transactionReceipts\")\n            .values(transactionReceipts)\n            .onConflict((oc) =>\n              oc.column(\"transactionHash\").doUpdateSet((eb) => ({\n                blockHash: eb.ref(\"excluded.blockHash\"),\n                blockNumber: eb.ref(\"excluded.blockNumber\"),\n                contractAddress: eb.ref(\"excluded.contractAddress\"),\n                cumulativeGasUsed: eb.ref(\"excluded.cumulativeGasUsed\"),\n                effectiveGasPrice: eb.ref(\"excluded.effectiveGasPrice\"),\n                gasUsed: eb.ref(\"excluded.gasUsed\"),\n                logs: eb.ref(\"excluded.logs\"),\n                logsBloom: eb.ref(\"excluded.logsBloom\"),\n                transactionIndex: eb.ref(\"excluded.transactionIndex\"),\n              })),\n            )\n            .execute();\n        }\n\n        if (rpcLogs.length > 0) {\n          const logs = rpcLogs.map((rpcLog) => ({\n            ...rpcToPostgresLog(rpcLog),\n            chainId,\n            checkpoint: this.createLogCheckpoint(rpcLog, rpcBlock, chainId),\n          }));\n          await tx\n            .insertInto(\"logs\")\n            .values(logs)\n            .onConflict((oc) =>\n              oc.column(\"id\").doUpdateSet((eb) => ({\n                checkpoint: eb.ref(\"excluded.checkpoint\"),\n              })),\n            )\n            .execute();\n        }\n\n        if (rpcTraces.length > 0) {\n          const traces = rpcTraces\n            .map((trace, i) => ({\n              ...rpcToPostgresTrace(trace),\n              chainId,\n              checkpoint: encodeCheckpoint({\n                blockTimestamp: hexToNumber(rpcBlock.timestamp),\n                chainId: BigInt(chainId),\n                blockNumber: hexToBigInt(trace.blockNumber),\n                transactionIndex: BigInt(trace.transactionPosition),\n                eventType: EVENT_TYPES.callTraces,\n                eventIndex: BigInt(i),\n              }),\n            }))\n            .sort((a, b) => {\n              if (a.transactionHash < b.transactionHash) return -1;\n              if (a.transactionHash > b.transactionHash) return 1;\n              return a.traceAddress < b.traceAddress ? -1 : 1;\n            });\n\n          await tx\n            .insertInto(\"callTraces\")\n            .values(traces)\n            .onConflict((oc) => oc.column(\"id\").doNothing())\n            .execute();\n        }\n      });\n    });\n  };\n\n  insertRealtimeInterval = async ({\n    chainId,\n    logFilters,\n    factoryLogFilters,\n    traceFilters,\n    factoryTraceFilters,\n    blockFilters,\n    interval,\n  }: {\n    chainId: number;\n    logFilters: LogFilterCriteria[];\n    factoryLogFilters: FactoryLogFilterCriteria[];\n    traceFilters: CallTraceFilterCriteria[];\n    factoryTraceFilters: FactoryCallTraceFilterCriteria[];\n    blockFilters: BlockFilterCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    return this.db.wrap({ method: \"insertRealtimeInterval\" }, async () => {\n      await this.db.transaction().execute(async (tx) => {\n        await this._insertLogFilterInterval({\n          tx,\n          chainId,\n          logFilters: [\n            ...logFilters,\n            ...factoryLogFilters.map((f) => ({\n              address: f.address,\n              topics: [f.eventSelector],\n              includeTransactionReceipts: f.includeTransactionReceipts,\n            })),\n            ...factoryTraceFilters.map((f) => ({\n              address: f.address,\n              topics: [f.eventSelector],\n              includeTransactionReceipts: f.includeTransactionReceipts,\n            })),\n          ],\n          interval,\n        });\n\n        await this._insertFactoryLogFilterInterval({\n          tx,\n          chainId,\n          factoryLogFilters,\n          interval,\n        });\n\n        await this._insertBlockFilterInterval({\n          tx,\n          chainId,\n          blockFilters,\n          interval,\n        });\n\n        await this._insertTraceFilterInterval({\n          tx,\n          chainId,\n          traceFilters,\n          interval,\n        });\n\n        await this._insertFactoryTraceFilterInterval({\n          tx,\n          chainId,\n          factoryTraceFilters,\n          interval,\n        });\n      });\n    });\n  };\n\n  deleteRealtimeData = async ({\n    chainId,\n    fromBlock,\n  }: {\n    chainId: number;\n    fromBlock: bigint;\n  }) => {\n    return this.db.wrap({ method: \"deleteRealtimeData\" }, async () => {\n      await this.db.transaction().execute(async (tx) => {\n        await tx\n          .deleteFrom(\"logs\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"blockNumber\", \">\", fromBlock)\n          .execute();\n        await tx\n          .deleteFrom(\"blocks\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"number\", \">\", fromBlock)\n          .execute();\n        await tx\n          .deleteFrom(\"rpcRequestResults\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"blockNumber\", \">\", fromBlock)\n          .execute();\n        await tx\n          .deleteFrom(\"callTraces\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"blockNumber\", \">\", fromBlock)\n          .execute();\n      });\n    });\n  };\n\n  /** SYNC HELPER METHODS */\n\n  private _insertLogFilterInterval = async ({\n    tx,\n    chainId,\n    logFilters,\n    interval: { startBlock, endBlock },\n  }: {\n    tx: KyselyTransaction<SyncStoreTables>;\n    chainId: number;\n    logFilters: LogFilterCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const logFilterFragments = logFilters.flatMap((logFilter) =>\n      buildLogFilterFragments({ ...logFilter, chainId }),\n    );\n\n    await Promise.all(\n      logFilterFragments.map(async (logFilterFragment) => {\n        const { id: logFilterId } = await tx\n          .insertInto(\"logFilters\")\n          .values(logFilterFragment)\n          .onConflict((oc) => oc.column(\"id\").doUpdateSet(logFilterFragment))\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        await tx\n          .insertInto(\"logFilterIntervals\")\n          .values({ logFilterId, startBlock, endBlock })\n          .execute();\n      }),\n    );\n  };\n\n  private _insertFactoryLogFilterInterval = async ({\n    tx,\n    chainId,\n    factoryLogFilters,\n    interval: { startBlock, endBlock },\n  }: {\n    tx: KyselyTransaction<SyncStoreTables>;\n    chainId: number;\n    factoryLogFilters: FactoryLogFilterCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const factoryFragments = factoryLogFilters.flatMap((factory) =>\n      buildFactoryLogFragments({ ...factory, chainId }),\n    );\n\n    await Promise.all(\n      factoryFragments.map(async (fragment) => {\n        const { id: factoryId } = await tx\n          .insertInto(\"factoryLogFilters\")\n          .values(fragment)\n          .onConflict((oc) => oc.column(\"id\").doUpdateSet(fragment))\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        await tx\n          .insertInto(\"factoryLogFilterIntervals\")\n          .values({ factoryId, startBlock, endBlock })\n          .execute();\n      }),\n    );\n  };\n\n  private _insertBlockFilterInterval = async ({\n    tx,\n    chainId,\n    blockFilters,\n    interval: { startBlock, endBlock },\n  }: {\n    tx: KyselyTransaction<SyncStoreTables>;\n    chainId: number;\n    blockFilters: BlockFilterCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const blockFilterFragments = blockFilters.map((blockFilter) => {\n      return {\n        id: `${chainId}_${blockFilter.interval}_${blockFilter.offset}`,\n        chainId,\n        interval: blockFilter.interval,\n        offset: blockFilter.offset,\n      };\n    });\n\n    await Promise.all(\n      blockFilterFragments.map(async (blockFilterFragment) => {\n        const { id: blockFilterId } = await tx\n          .insertInto(\"blockFilters\")\n          .values(blockFilterFragment)\n          .onConflict((oc) => oc.column(\"id\").doUpdateSet(blockFilterFragment))\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        await tx\n          .insertInto(\"blockFilterIntervals\")\n          .values({ blockFilterId, startBlock, endBlock })\n          .execute();\n      }),\n    );\n  };\n\n  private _insertTraceFilterInterval = async ({\n    tx,\n    chainId,\n    traceFilters,\n    interval: { startBlock, endBlock },\n  }: {\n    tx: KyselyTransaction<SyncStoreTables>;\n    chainId: number;\n    traceFilters: CallTraceFilterCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const traceFilterFragments = traceFilters.flatMap((traceFilter) =>\n      buildTraceFragments({ ...traceFilter, chainId }),\n    );\n\n    await Promise.all(\n      traceFilterFragments.map(async (traceFilterFragment) => {\n        const { id: traceFilterId } = await tx\n          .insertInto(\"traceFilters\")\n          .values(traceFilterFragment)\n          .onConflict((oc) => oc.column(\"id\").doUpdateSet(traceFilterFragment))\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        await tx\n          .insertInto(\"traceFilterIntervals\")\n          .values({ traceFilterId, startBlock, endBlock })\n          .execute();\n      }),\n    );\n  };\n\n  private _insertFactoryTraceFilterInterval = async ({\n    tx,\n    chainId,\n    factoryTraceFilters,\n    interval: { startBlock, endBlock },\n  }: {\n    tx: KyselyTransaction<SyncStoreTables>;\n    chainId: number;\n    factoryTraceFilters: FactoryCallTraceFilterCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const factoryFragments = factoryTraceFilters.flatMap((factory) =>\n      buildFactoryTraceFragments({ ...factory, chainId }),\n    );\n\n    await Promise.all(\n      factoryFragments.map(async (fragment) => {\n        const { id: factoryId } = await tx\n          .insertInto(\"factoryTraceFilters\")\n          .values(fragment)\n          .onConflict((oc) => oc.column(\"id\").doUpdateSet(fragment))\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        await tx\n          .insertInto(\"factoryTraceFilterIntervals\")\n          .values({\n            factoryId,\n            startBlock,\n            endBlock,\n          })\n          .execute();\n      }),\n    );\n  };\n\n  insertRpcRequestResult = async ({\n    request,\n    blockNumber,\n    chainId,\n    result,\n  }: {\n    request: string;\n    blockNumber: bigint;\n    chainId: number;\n    result: string;\n  }) => {\n    return this.db.wrap({ method: \"insertRpcRequestResult\" }, async () => {\n      await this.db\n        .insertInto(\"rpcRequestResults\")\n        .values({ request, blockNumber, chainId, result })\n        .onConflict((oc) =>\n          oc.constraint(\"rpcRequestResultPrimaryKey\").doUpdateSet({ result }),\n        )\n        .execute();\n    });\n  };\n\n  getRpcRequestResult = async ({\n    request,\n    blockNumber,\n    chainId,\n  }: {\n    request: string;\n    blockNumber: bigint;\n    chainId: number;\n  }) => {\n    return this.db.wrap({ method: \"getRpcRequestResult\" }, async () => {\n      const contractReadResult = await this.db\n        .selectFrom(\"rpcRequestResults\")\n        .selectAll()\n        .where(\"request\", \"=\", request)\n        .where(\"blockNumber\", \"=\", blockNumber)\n        .where(\"chainId\", \"=\", chainId)\n        .executeTakeFirst();\n\n      return contractReadResult ?? null;\n    });\n  };\n\n  async *getEvents({\n    sources,\n    fromCheckpoint,\n    toCheckpoint,\n  }: {\n    sources: EventSource[];\n    fromCheckpoint: Checkpoint;\n    toCheckpoint: Checkpoint;\n  }) {\n    let fromCursor = encodeCheckpoint(fromCheckpoint);\n    let toCursor = encodeCheckpoint(toCheckpoint);\n    const maxToCursor = toCursor;\n\n    const sourcesById = sources.reduce<{\n      [sourceId: string]: (typeof sources)[number];\n    }>((acc, cur) => {\n      acc[cur.id] = cur;\n      return acc;\n    }, {});\n\n    // We can assume that source won't be empty.\n    const logSources = sources.filter(\n      (s): s is LogSource | FactoryLogSource =>\n        sourceIsLog(s) || sourceIsFactoryLog(s),\n    );\n    const callTraceSources = sources.filter(\n      (s): s is CallTraceSource | FactoryCallTraceSource =>\n        sourceIsCallTrace(s) || sourceIsFactoryCallTrace(s),\n    );\n    const blockSources = sources.filter(sourceIsBlock);\n\n    const shouldJoinLogs = logSources.length !== 0;\n    const shouldJoinTransactions =\n      logSources.length !== 0 || callTraceSources.length !== 0;\n    const shouldJoinTraces = callTraceSources.length !== 0;\n    const shouldJoinReceipts =\n      logSources.some((source) => source.criteria.includeTransactionReceipts) ||\n      callTraceSources.some(\n        (source) => source.criteria.includeTransactionReceipts,\n      );\n\n    while (true) {\n      const estimatedToCursor = encodeCheckpoint({\n        ...zeroCheckpoint,\n        blockTimestamp: Math.min(\n          decodeCheckpoint(fromCursor).blockTimestamp + this.seconds,\n          maxCheckpoint.blockTimestamp,\n        ),\n      });\n      toCursor =\n        estimatedToCursor > maxToCursor ? maxToCursor : estimatedToCursor;\n\n      const events = await this.db.wrap({ method: \"getEvents\" }, async () => {\n        // Get full log objects, including the eventSelector clause.\n        const requestedLogs = await this.db\n          .with(\n            \"log_sources(source_id)\",\n            () =>\n              sql`( values ${\n                logSources.length === 0\n                  ? sql`( null )`\n                  : sql.join(\n                      logSources.map(\n                        (source) => sql`( ${sql.val(source.id)} )`,\n                      ),\n                    )\n              } )`,\n          )\n          .with(\n            \"block_sources(source_id)\",\n            () =>\n              sql`( values ${\n                blockSources.length === 0\n                  ? sql`( null )`\n                  : sql.join(\n                      blockSources.map(\n                        (source) => sql`( ${sql.val(source.id)} )`,\n                      ),\n                    )\n              } )`,\n          )\n          .with(\n            \"call_trace_sources(source_id)\",\n            () =>\n              sql`( values ${\n                callTraceSources.length === 0\n                  ? sql`( null )`\n                  : sql.join(\n                      callTraceSources.map(\n                        (source) => sql`( ${sql.val(source.id)} )`,\n                      ),\n                    )\n              } )`,\n          )\n          .with(\"events\", (db) =>\n            db\n              .selectFrom(\"logs\")\n              .innerJoin(\"log_sources\", (join) => join.onTrue())\n              .where((eb) => {\n                const logFilterCmprs = sources\n                  .filter(sourceIsLog)\n                  .map((logFilter) => {\n                    const exprs = this.buildLogFilterCmprs({\n                      eb,\n                      logFilter,\n                    });\n                    exprs.push(eb(\"source_id\", \"=\", logFilter.id));\n                    return eb.and(exprs);\n                  });\n\n                const factoryCmprs = sources\n                  .filter(sourceIsFactoryLog)\n                  .map((factory) => {\n                    const exprs = this.buildFactoryLogFilterCmprs({\n                      eb,\n                      factory,\n                    });\n                    exprs.push(eb(\"source_id\", \"=\", factory.id));\n                    return eb.and(exprs);\n                  });\n\n                return eb.or([...logFilterCmprs, ...factoryCmprs]);\n              })\n              .select([\n                \"source_id\",\n                \"checkpoint\",\n                \"blockHash\",\n                \"transactionHash\",\n\n                \"logs.id as log_id\",\n                sql`null`.as(\"callTrace_id\"),\n              ])\n              .unionAll(\n                // @ts-ignore\n                db\n                  .selectFrom(\"blocks\")\n                  .innerJoin(\"block_sources\", (join) => join.onTrue())\n                  .where((eb) => {\n                    const exprs = [];\n                    for (const blockSource of blockSources) {\n                      exprs.push(\n                        eb.and([\n                          eb(\"chainId\", \"=\", blockSource.chainId),\n                          eb(\"number\", \">=\", BigInt(blockSource.startBlock)),\n                          ...(blockSource.endBlock !== undefined\n                            ? [eb(\"number\", \"<=\", BigInt(blockSource.endBlock))]\n                            : []),\n                          sql`(number - ${sql.val(blockSource.criteria.offset)}) % ${sql.val(\n                            blockSource.criteria.interval,\n                          )} = 0`,\n                          eb(\"source_id\", \"=\", blockSource.id),\n                        ]),\n                      );\n                    }\n                    return eb.or(exprs);\n                  })\n                  .select([\n                    \"block_sources.source_id\",\n                    \"checkpoint\",\n                    \"hash as blockHash\",\n                    sql`null`.as(\"transactionHash\"),\n\n                    sql`null`.as(\"log_id\"),\n                    sql`null`.as(\"callTrace_id\"),\n                  ]),\n              )\n              .unionAll(\n                // @ts-ignore\n                db\n                  .selectFrom(\"callTraces\")\n                  .innerJoin(\"call_trace_sources\", (join) => join.onTrue())\n                  .where((eb) => {\n                    const traceFilterCmprs = sources\n                      .filter(sourceIsCallTrace)\n                      .map((callTraceSource) => {\n                        const exprs = this.buildTraceFilterCmprs({\n                          eb,\n                          callTraceSource,\n                        });\n                        exprs.push(eb(\"source_id\", \"=\", callTraceSource.id));\n                        return eb.and(exprs);\n                      });\n                    const factoryTraceFilterCmprs = sources\n                      .filter(sourceIsFactoryCallTrace)\n                      .map((factory) => {\n                        const exprs = this.buildFactoryTraceFilterCmprs({\n                          eb,\n                          factory,\n                        });\n                        exprs.push(eb(\"source_id\", \"=\", factory.id));\n                        return eb.and(exprs);\n                      });\n\n                    return eb.or([\n                      ...traceFilterCmprs,\n                      ...factoryTraceFilterCmprs,\n                    ]);\n                  })\n\n                  .select([\n                    \"source_id\",\n                    \"checkpoint\",\n                    \"blockHash\",\n                    \"transactionHash\",\n\n                    sql`null`.as(\"log_id\"),\n                    \"callTraces.id as callTrace_id\",\n                  ]),\n              ),\n          )\n          .selectFrom(\"events\")\n          .innerJoin(\"blocks\", \"blocks.hash\", \"events.blockHash\")\n          .select([\n            \"events.source_id\",\n            \"events.checkpoint\",\n\n            \"blocks.baseFeePerGas as block_baseFeePerGas\",\n            \"blocks.difficulty as block_difficulty\",\n            \"blocks.extraData as block_extraData\",\n            \"blocks.gasLimit as block_gasLimit\",\n            \"blocks.gasUsed as block_gasUsed\",\n            \"blocks.hash as block_hash\",\n            \"blocks.logsBloom as block_logsBloom\",\n            \"blocks.miner as block_miner\",\n            \"blocks.mixHash as block_mixHash\",\n            \"blocks.nonce as block_nonce\",\n            \"blocks.number as block_number\",\n            \"blocks.parentHash as block_parentHash\",\n            \"blocks.receiptsRoot as block_receiptsRoot\",\n            \"blocks.sha3Uncles as block_sha3Uncles\",\n            \"blocks.size as block_size\",\n            \"blocks.stateRoot as block_stateRoot\",\n            \"blocks.timestamp as block_timestamp\",\n            \"blocks.totalDifficulty as block_totalDifficulty\",\n            \"blocks.transactionsRoot as block_transactionsRoot\",\n          ])\n          .$if(shouldJoinLogs, (qb) =>\n            qb\n              .leftJoin(\"logs\", \"logs.id\", \"events.log_id\")\n              .select([\n                \"logs.address as log_address\",\n                \"logs.blockHash as log_blockHash\",\n                \"logs.blockNumber as log_blockNumber\",\n                \"logs.chainId as log_chainId\",\n                \"logs.data as log_data\",\n                \"logs.id as log_id\",\n                \"logs.logIndex as log_logIndex\",\n                \"logs.topic0 as log_topic0\",\n                \"logs.topic1 as log_topic1\",\n                \"logs.topic2 as log_topic2\",\n                \"logs.topic3 as log_topic3\",\n                \"logs.transactionHash as log_transactionHash\",\n                \"logs.transactionIndex as log_transactionIndex\",\n              ]),\n          )\n          .$if(shouldJoinTransactions, (qb) =>\n            qb\n              .leftJoin(\n                \"transactions\",\n                \"transactions.hash\",\n                \"events.transactionHash\",\n              )\n              .select([\n                \"transactions.accessList as tx_accessList\",\n                \"transactions.blockHash as tx_blockHash\",\n                \"transactions.blockNumber as tx_blockNumber\",\n                \"transactions.from as tx_from\",\n                \"transactions.gas as tx_gas\",\n                \"transactions.gasPrice as tx_gasPrice\",\n                \"transactions.hash as tx_hash\",\n                \"transactions.input as tx_input\",\n                \"transactions.maxFeePerGas as tx_maxFeePerGas\",\n                \"transactions.maxPriorityFeePerGas as tx_maxPriorityFeePerGas\",\n                \"transactions.nonce as tx_nonce\",\n                \"transactions.r as tx_r\",\n                \"transactions.s as tx_s\",\n                \"transactions.to as tx_to\",\n                \"transactions.transactionIndex as tx_transactionIndex\",\n                \"transactions.type as tx_type\",\n                \"transactions.value as tx_value\",\n                \"transactions.v as tx_v\",\n              ]),\n          )\n          .$if(shouldJoinTraces, (qb) =>\n            qb\n              .leftJoin(\"callTraces\", \"callTraces.id\", \"events.callTrace_id\")\n              .select([\n                \"callTraces.id as callTrace_id\",\n                \"callTraces.callType as callTrace_callType\",\n                \"callTraces.from as callTrace_from\",\n                \"callTraces.gas as callTrace_gas\",\n                \"callTraces.input as callTrace_input\",\n                \"callTraces.to as callTrace_to\",\n                \"callTraces.value as callTrace_value\",\n                \"callTraces.blockHash as callTrace_blockHash\",\n                \"callTraces.blockNumber as callTrace_blockNumber\",\n                \"callTraces.gasUsed as callTrace_gasUsed\",\n                \"callTraces.output as callTrace_output\",\n                \"callTraces.subtraces as callTrace_subtraces\",\n                \"callTraces.traceAddress as callTrace_traceAddress\",\n                \"callTraces.transactionHash as callTrace_transactionHash\",\n                \"callTraces.transactionPosition as callTrace_transactionPosition\",\n                \"callTraces.chainId as callTrace_chainId\",\n                \"callTraces.checkpoint as callTrace_checkpoint\",\n              ]),\n          )\n          .$if(shouldJoinReceipts, (qb) =>\n            qb\n              .leftJoin(\n                \"transactionReceipts\",\n                \"transactionReceipts.transactionHash\",\n                \"events.transactionHash\",\n              )\n              .select([\n                \"transactionReceipts.blockHash as txr_blockHash\",\n                \"transactionReceipts.blockNumber as txr_blockNumber\",\n                \"transactionReceipts.contractAddress as txr_contractAddress\",\n                \"transactionReceipts.cumulativeGasUsed as txr_cumulativeGasUsed\",\n                \"transactionReceipts.effectiveGasPrice as txr_effectiveGasPrice\",\n                \"transactionReceipts.from as txr_from\",\n                \"transactionReceipts.gasUsed as txr_gasUsed\",\n                \"transactionReceipts.logs as txr_logs\",\n                \"transactionReceipts.logsBloom as txr_logsBloom\",\n                \"transactionReceipts.status as txr_status\",\n                \"transactionReceipts.to as txr_to\",\n                \"transactionReceipts.transactionHash as txr_transactionHash\",\n                \"transactionReceipts.transactionIndex as txr_transactionIndex\",\n                \"transactionReceipts.type as txr_type\",\n              ]),\n          )\n          .where(\"events.checkpoint\", \">\", fromCursor)\n          .where(\"events.checkpoint\", \"<=\", toCursor)\n          .orderBy(\"events.checkpoint\", \"asc\")\n          .limit(this.common.options.syncEventsQuerySize)\n          .execute();\n\n        return requestedLogs.map((_row) => {\n          // Without this cast, the block_ and tx_ fields are all nullable\n          // which makes this very annoying. Should probably add a runtime check\n          // that those fields are indeed present before continuing here.\n          const row = _row as NonNull<(typeof requestedLogs)[number]>;\n\n          const source = sourcesById[row.source_id]!;\n\n          const shouldIncludeLog =\n            sourceIsLog(source) || sourceIsFactoryLog(source);\n          const shouldIncludeTransaction =\n            sourceIsLog(source) ||\n            sourceIsFactoryLog(source) ||\n            sourceIsCallTrace(source) ||\n            sourceIsFactoryCallTrace(source);\n          const shouldIncludeTrace =\n            sourceIsCallTrace(source) || sourceIsFactoryCallTrace(source);\n          const shouldIncludeTransactionReceipt =\n            (sourceIsLog(source) &&\n              source.criteria.includeTransactionReceipts) ||\n            (sourceIsFactoryLog(source) &&\n              source.criteria.includeTransactionReceipts);\n          return {\n            chainId: source.chainId,\n            sourceId: row.source_id,\n            encodedCheckpoint: row.checkpoint,\n            log: shouldIncludeLog\n              ? {\n                  address: checksumAddress(row.log_address),\n                  blockHash: row.log_blockHash,\n                  blockNumber: row.log_blockNumber,\n                  data: row.log_data,\n                  id: row.log_id as Log[\"id\"],\n                  logIndex: Number(row.log_logIndex),\n                  removed: false,\n                  topics: [\n                    row.log_topic0,\n                    row.log_topic1,\n                    row.log_topic2,\n                    row.log_topic3,\n                  ].filter((t): t is Hex => t !== null) as [Hex, ...Hex[]] | [],\n                  transactionHash: row.log_transactionHash,\n                  transactionIndex: Number(row.log_transactionIndex),\n                }\n              : undefined,\n            block: {\n              baseFeePerGas: row.block_baseFeePerGas,\n              difficulty: row.block_difficulty,\n              extraData: row.block_extraData,\n              gasLimit: row.block_gasLimit,\n              gasUsed: row.block_gasUsed,\n              hash: row.block_hash,\n              logsBloom: row.block_logsBloom,\n              miner: checksumAddress(row.block_miner),\n              mixHash: row.block_mixHash,\n              nonce: row.block_nonce,\n              number: row.block_number,\n              parentHash: row.block_parentHash,\n              receiptsRoot: row.block_receiptsRoot,\n              sha3Uncles: row.block_sha3Uncles,\n              size: row.block_size,\n              stateRoot: row.block_stateRoot,\n              timestamp: row.block_timestamp,\n              totalDifficulty: row.block_totalDifficulty,\n              transactionsRoot: row.block_transactionsRoot,\n            },\n            transaction: shouldIncludeTransaction\n              ? {\n                  blockHash: row.tx_blockHash,\n                  blockNumber: row.tx_blockNumber,\n                  from: checksumAddress(row.tx_from),\n                  gas: row.tx_gas,\n                  hash: row.tx_hash,\n                  input: row.tx_input,\n                  nonce: Number(row.tx_nonce),\n                  r: row.tx_r,\n                  s: row.tx_s,\n                  to: row.tx_to ? checksumAddress(row.tx_to) : row.tx_to,\n                  transactionIndex: Number(row.tx_transactionIndex),\n                  value: row.tx_value,\n                  v: row.tx_v,\n                  ...(row.tx_type === \"0x0\"\n                    ? { type: \"legacy\", gasPrice: row.tx_gasPrice }\n                    : row.tx_type === \"0x1\"\n                      ? {\n                          type: \"eip2930\",\n                          gasPrice: row.tx_gasPrice,\n                          accessList: JSON.parse(row.tx_accessList),\n                        }\n                      : row.tx_type === \"0x2\"\n                        ? {\n                            type: \"eip1559\",\n                            maxFeePerGas: row.tx_maxFeePerGas,\n                            maxPriorityFeePerGas: row.tx_maxPriorityFeePerGas,\n                          }\n                        : row.tx_type === \"0x7e\"\n                          ? {\n                              type: \"deposit\",\n                              maxFeePerGas: row.tx_maxFeePerGas ?? undefined,\n                              maxPriorityFeePerGas:\n                                row.tx_maxPriorityFeePerGas ?? undefined,\n                            }\n                          : { type: row.tx_type }),\n                }\n              : undefined,\n            trace: shouldIncludeTrace\n              ? {\n                  id: row.callTrace_id,\n                  from: checksumAddress(row.callTrace_from),\n                  to: checksumAddress(row.callTrace_to),\n                  gas: row.callTrace_gas,\n                  value: row.callTrace_value,\n                  input: row.callTrace_input,\n                  output: row.callTrace_output,\n                  gasUsed: row.callTrace_gasUsed,\n                  subtraces: row.callTrace_subtraces,\n                  traceAddress: JSON.parse(row.callTrace_traceAddress),\n                  blockHash: row.callTrace_blockHash,\n                  blockNumber: row.callTrace_blockNumber,\n                  transactionHash: row.callTrace_transactionHash,\n                  transactionIndex: row.callTrace_transactionPosition,\n                  callType: row.callTrace_callType as CallTrace[\"callType\"],\n                }\n              : undefined,\n            transactionReceipt: shouldIncludeTransactionReceipt\n              ? {\n                  blockHash: row.txr_blockHash,\n                  blockNumber: row.txr_blockNumber,\n                  contractAddress: row.txr_contractAddress\n                    ? checksumAddress(row.txr_contractAddress)\n                    : null,\n                  cumulativeGasUsed: row.txr_cumulativeGasUsed,\n                  effectiveGasPrice: row.txr_effectiveGasPrice,\n                  from: checksumAddress(row.txr_from),\n                  gasUsed: row.txr_gasUsed,\n                  logs: JSON.parse(row.txr_logs).map((log: SyncLog) => ({\n                    address: checksumAddress(log.address),\n                    blockHash: log.blockHash,\n                    blockNumber: hexToBigInt(log.blockNumber),\n                    data: log.data,\n                    logIndex: hexToNumber(log.logIndex),\n                    removed: false,\n                    topics: [\n                      log.topics[0] ?? null,\n                      log.topics[1] ?? null,\n                      log.topics[2] ?? null,\n                      log.topics[3] ?? null,\n                    ].filter((t): t is Hex => t !== null) as\n                      | [Hex, ...Hex[]]\n                      | [],\n                    transactionHash: log.transactionHash,\n                    transactionIndex: hexToNumber(log.transactionIndex),\n                  })),\n                  logsBloom: row.txr_logsBloom,\n                  status:\n                    row.txr_status === \"0x1\"\n                      ? \"success\"\n                      : row.txr_status === \"0x0\"\n                        ? \"reverted\"\n                        : (row.txr_status as TransactionReceipt[\"status\"]),\n                  to: row.txr_to ? checksumAddress(row.txr_to) : null,\n                  transactionHash: row.txr_transactionHash,\n                  transactionIndex: Number(row.txr_transactionIndex),\n                  type:\n                    row.txr_type === \"0x0\"\n                      ? \"legacy\"\n                      : row.txr_type === \"0x1\"\n                        ? \"eip2930\"\n                        : row.tx_type === \"0x2\"\n                          ? \"eip1559\"\n                          : row.tx_type === \"0x7e\"\n                            ? \"deposit\"\n                            : row.tx_type,\n                }\n              : undefined,\n          } satisfies RawEvent;\n        });\n      });\n\n      // set fromCursor + seconds\n      if (events.length === 0) {\n        this.seconds = Math.round(this.seconds * 2);\n        fromCursor = toCursor;\n      } else if (events.length === this.common.options.syncEventsQuerySize) {\n        this.seconds = Math.round(this.seconds / 2);\n        fromCursor = events[events.length - 1]!.encodedCheckpoint;\n      } else {\n        this.seconds = Math.round(\n          Math.min(\n            (this.seconds / events.length) *\n              this.common.options.syncEventsQuerySize *\n              0.9,\n            this.seconds * 2,\n          ),\n        );\n        fromCursor = toCursor;\n      }\n\n      if (events.length > 0) yield events;\n\n      // exit condition\n      if (\n        events.length !== this.common.options.syncEventsQuerySize &&\n        toCursor === maxToCursor\n      ) {\n        break;\n      }\n    }\n  }\n\n  private buildLogFilterCmprs = ({\n    eb,\n    logFilter,\n  }: {\n    eb: ExpressionBuilder<any, any>;\n    logFilter: LogSource;\n  }) => {\n    const exprs = [];\n\n    exprs.push(\n      eb(\n        \"logs.chainId\",\n        \"=\",\n        sql`cast (${sql.val(logFilter.chainId)} as numeric(16, 0))`,\n      ),\n    );\n\n    if (logFilter.criteria.address) {\n      // If it's an array of length 1, collapse it.\n      const address =\n        Array.isArray(logFilter.criteria.address) &&\n        logFilter.criteria.address.length === 1\n          ? logFilter.criteria.address[0]\n          : logFilter.criteria.address;\n      if (Array.isArray(address)) {\n        exprs.push(eb.or(address.map((a) => eb(\"logs.address\", \"=\", a))));\n      } else {\n        exprs.push(eb(\"logs.address\", \"=\", address));\n      }\n    }\n\n    if (logFilter.criteria.topics) {\n      for (const idx_ of range(0, 4)) {\n        const idx = idx_ as 0 | 1 | 2 | 3;\n        // If it's an array of length 1, collapse it.\n        const raw = logFilter.criteria.topics[idx] ?? null;\n        if (raw === null) continue;\n        const topic = Array.isArray(raw) && raw.length === 1 ? raw[0] : raw;\n        if (Array.isArray(topic)) {\n          exprs.push(eb.or(topic.map((a) => eb(`logs.topic${idx}`, \"=\", a))));\n        } else {\n          exprs.push(eb(`logs.topic${idx}`, \"=\", topic));\n        }\n      }\n    }\n\n    if (logFilter.startBlock !== undefined && logFilter.startBlock !== 0)\n      exprs.push(eb(\"logs.blockNumber\", \">=\", BigInt(logFilter.startBlock)));\n    if (logFilter.endBlock)\n      exprs.push(eb(\"logs.blockNumber\", \"<=\", BigInt(logFilter.endBlock)));\n\n    return exprs;\n  };\n\n  private buildFactoryLogFilterCmprs = ({\n    eb,\n    factory,\n  }: {\n    eb: ExpressionBuilder<any, any>;\n    factory: FactoryLogSource;\n  }) => {\n    const exprs = [];\n\n    exprs.push(\n      eb(\n        \"logs.chainId\",\n        \"=\",\n        sql`cast (${sql.val(factory.chainId)} as numeric(16, 0))`,\n      ),\n    );\n\n    const selectChildAddressExpression =\n      buildFactoryChildAddressSelectExpression({\n        childAddressLocation: factory.criteria.childAddressLocation,\n      });\n\n    exprs.push(\n      eb(\n        \"logs.address\",\n        \"in\",\n        eb\n          .selectFrom(\"logs\")\n          .select(selectChildAddressExpression.as(\"childAddress\"))\n          .where(\"chainId\", \"=\", factory.chainId)\n          .where(\"address\", \"=\", factory.criteria.address)\n          .where(\"topic0\", \"=\", factory.criteria.eventSelector),\n      ),\n    );\n\n    if (factory.criteria.topics) {\n      for (const idx_ of range(0, 4)) {\n        const idx = idx_ as 0 | 1 | 2 | 3;\n        // If it's an array of length 1, collapse it.\n        const raw = factory.criteria.topics[idx] ?? null;\n        if (raw === null) continue;\n        const topic = Array.isArray(raw) && raw.length === 1 ? raw[0] : raw;\n        if (Array.isArray(topic)) {\n          exprs.push(eb.or(topic.map((a) => eb(`logs.topic${idx}`, \"=\", a))));\n        } else {\n          exprs.push(eb(`logs.topic${idx}`, \"=\", topic));\n        }\n      }\n    }\n\n    if (factory.startBlock !== undefined && factory.startBlock !== 0)\n      exprs.push(eb(\"logs.blockNumber\", \">=\", BigInt(factory.startBlock)));\n    if (factory.endBlock)\n      exprs.push(eb(\"logs.blockNumber\", \"<=\", BigInt(factory.endBlock)));\n\n    return exprs;\n  };\n\n  private buildTraceFilterCmprs = ({\n    eb,\n    callTraceSource,\n  }: {\n    eb: ExpressionBuilder<any, any>;\n    callTraceSource: CallTraceSource;\n  }) => {\n    const exprs = [];\n\n    exprs.push(\n      eb(\n        \"callTraces.chainId\",\n        \"=\",\n        sql`cast (${sql.val(callTraceSource.chainId)} as numeric(16, 0))`,\n      ),\n    );\n\n    if (callTraceSource.criteria.fromAddress) {\n      // If it's an array of length 1, collapse it.\n      const fromAddress =\n        Array.isArray(callTraceSource.criteria.fromAddress) &&\n        callTraceSource.criteria.fromAddress.length === 1\n          ? callTraceSource.criteria.fromAddress[0]\n          : callTraceSource.criteria.fromAddress;\n      if (Array.isArray(fromAddress)) {\n        exprs.push(\n          eb.or(fromAddress.map((a) => eb(\"callTraces.from\", \"=\", a))),\n        );\n      } else {\n        exprs.push(eb(\"callTraces.from\", \"=\", fromAddress));\n      }\n    }\n\n    if (callTraceSource.criteria.toAddress) {\n      // If it's an array of length 1, collapse it.\n      const toAddress =\n        Array.isArray(callTraceSource.criteria.toAddress) &&\n        callTraceSource.criteria.toAddress.length === 1\n          ? callTraceSource.criteria.toAddress[0]\n          : callTraceSource.criteria.toAddress;\n      if (Array.isArray(toAddress)) {\n        exprs.push(eb.or(toAddress.map((a) => eb(\"callTraces.to\", \"=\", a))));\n      } else {\n        exprs.push(eb(\"callTraces.to\", \"=\", toAddress));\n      }\n    }\n\n    // Filter based on function selectors\n    exprs.push(\n      eb.or(\n        callTraceSource.criteria.functionSelectors.map((fs) =>\n          eb(\"callTraces.functionSelector\", \"=\", fs),\n        ),\n      ),\n    );\n\n    // Filter out callTraces with error\n    exprs.push(\n      sql`${sql.ref(\"callTraces.error\")} IS NULL` as OperandExpression<SqlBool>,\n    );\n\n    if (\n      callTraceSource.startBlock !== undefined &&\n      callTraceSource.startBlock !== 0\n    )\n      exprs.push(\n        eb(\"callTraces.blockNumber\", \">=\", BigInt(callTraceSource.startBlock)),\n      );\n    if (callTraceSource.endBlock)\n      exprs.push(\n        eb(\"callTraces.blockNumber\", \"<=\", BigInt(callTraceSource.endBlock)),\n      );\n\n    return exprs;\n  };\n\n  private buildFactoryTraceFilterCmprs = ({\n    eb,\n    factory,\n  }: {\n    eb: ExpressionBuilder<any, any>;\n    factory: FactoryCallTraceSource;\n  }) => {\n    const exprs = [];\n\n    exprs.push(\n      eb(\n        \"callTraces.chainId\",\n        \"=\",\n        sql`cast (${sql.val(factory.chainId)} as numeric(16, 0))`,\n      ),\n    );\n    const selectChildAddressExpression =\n      buildFactoryChildAddressSelectExpression({\n        childAddressLocation: factory.criteria.childAddressLocation,\n      });\n\n    exprs.push(\n      eb(\n        \"callTraces.to\",\n        \"in\",\n        eb\n          .selectFrom(\"logs\")\n          .select(selectChildAddressExpression.as(\"childAddress\"))\n          .where(\"chainId\", \"=\", factory.chainId)\n          .where(\"address\", \"=\", factory.criteria.address)\n          .where(\"topic0\", \"=\", factory.criteria.eventSelector),\n      ),\n    );\n\n    if (factory.criteria.fromAddress) {\n      // If it's an array of length 1, collapse it.\n      const fromAddress =\n        Array.isArray(factory.criteria.fromAddress) &&\n        factory.criteria.fromAddress.length === 1\n          ? factory.criteria.fromAddress[0]\n          : factory.criteria.fromAddress;\n      if (Array.isArray(fromAddress)) {\n        exprs.push(\n          eb.or(fromAddress.map((a) => eb(\"callTraces.from\", \"=\", a))),\n        );\n      } else {\n        exprs.push(eb(\"callTraces.from\", \"=\", fromAddress));\n      }\n    }\n\n    // Filter based on function selectors\n    exprs.push(\n      eb.or(\n        factory.criteria.functionSelectors.map((fs) =>\n          eb(\"callTraces.functionSelector\", \"=\", fs),\n        ),\n      ),\n    );\n\n    // Filter out callTraces with error\n    exprs.push(\n      sql`${sql.ref(\"callTraces.error\")} IS NULL` as OperandExpression<SqlBool>,\n    );\n\n    if (factory.startBlock !== undefined && factory.startBlock !== 0)\n      exprs.push(\n        eb(\"callTraces.blockNumber\", \">=\", BigInt(factory.startBlock)),\n      );\n    if (factory.endBlock)\n      exprs.push(eb(\"callTraces.blockNumber\", \"<=\", BigInt(factory.endBlock)));\n\n    return exprs;\n  };\n\n  async pruneByChainId({ chainId, block }: { chainId: number; block: number }) {\n    await this.db.wrap({ method: \"pruneByChainId\" }, () =>\n      this.db.transaction().execute(async (tx) => {\n        await tx\n          .with(\"deleteLogFilter(logFilterId)\", (qb) =>\n            qb\n              .selectFrom(\"logFilterIntervals\")\n              .innerJoin(\"logFilters\", \"logFilterId\", \"logFilters.id\")\n              .select(\"logFilterId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \">=\", BigInt(block)),\n          )\n          .deleteFrom(\"logFilterIntervals\")\n          .where(\n            \"logFilterId\",\n            \"in\",\n            sql`(SELECT \"logFilterId\" FROM ${sql.table(\"deleteLogFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .with(\"updateLogFilter(logFilterId)\", (qb) =>\n            qb\n              .selectFrom(\"logFilterIntervals\")\n              .innerJoin(\"logFilters\", \"logFilterId\", \"logFilters.id\")\n              .select(\"logFilterId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \"<\", BigInt(block))\n              .where(\"endBlock\", \">\", BigInt(block)),\n          )\n          .updateTable(\"logFilterIntervals\")\n          .set({\n            endBlock: BigInt(block),\n          })\n          .where(\n            \"logFilterId\",\n            \"in\",\n            sql`(SELECT \"logFilterId\" FROM ${sql.table(\"updateLogFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .with(\"deleteFactoryLogFilter(factoryId)\", (qb) =>\n            qb\n              .selectFrom(\"factoryLogFilterIntervals\")\n              .innerJoin(\n                \"factoryLogFilters\",\n                \"factoryId\",\n                \"factoryLogFilters.id\",\n              )\n\n              .select(\"factoryId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \">=\", BigInt(block)),\n          )\n          .deleteFrom(\"factoryLogFilterIntervals\")\n          .where(\n            \"factoryId\",\n            \"in\",\n            sql`(SELECT \"factoryId\" FROM ${sql.table(\"deleteFactoryLogFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .with(\"updateFactoryLogFilter(factoryId)\", (qb) =>\n            qb\n              .selectFrom(\"factoryLogFilterIntervals\")\n              .innerJoin(\n                \"factoryLogFilters\",\n                \"factoryId\",\n                \"factoryLogFilters.id\",\n              )\n\n              .select(\"factoryId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \"<\", BigInt(block))\n              .where(\"endBlock\", \">\", BigInt(block)),\n          )\n          .updateTable(\"factoryLogFilterIntervals\")\n          .set({\n            endBlock: BigInt(block),\n          })\n          .where(\n            \"factoryId\",\n            \"in\",\n            sql`(SELECT \"factoryId\" FROM ${sql.table(\"updateFactoryLogFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .with(\"deleteTraceFilter(traceFilterId)\", (qb) =>\n            qb\n              .selectFrom(\"traceFilterIntervals\")\n              .innerJoin(\"traceFilters\", \"traceFilterId\", \"traceFilters.id\")\n              .select(\"traceFilterId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \">=\", BigInt(block)),\n          )\n          .deleteFrom(\"traceFilterIntervals\")\n          .where(\n            \"traceFilterId\",\n            \"in\",\n            sql`(SELECT \"traceFilterId\" FROM ${sql.table(\"deleteTraceFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .with(\"updateTraceFilter(traceFilterId)\", (qb) =>\n            qb\n              .selectFrom(\"traceFilterIntervals\")\n              .innerJoin(\"traceFilters\", \"traceFilterId\", \"traceFilters.id\")\n              .select(\"traceFilterId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \"<\", BigInt(block))\n              .where(\"endBlock\", \">\", BigInt(block)),\n          )\n          .updateTable(\"traceFilterIntervals\")\n          .set({\n            endBlock: BigInt(block),\n          })\n          .where(\n            \"traceFilterId\",\n            \"in\",\n            sql`(SELECT \"traceFilterId\" FROM ${sql.table(\"updateTraceFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .with(\"deleteFactoryTraceFilter(factoryId)\", (qb) =>\n            qb\n              .selectFrom(\"factoryTraceFilterIntervals\")\n              .innerJoin(\n                \"factoryTraceFilters\",\n                \"factoryId\",\n                \"factoryTraceFilters.id\",\n              )\n              .select(\"factoryId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \">=\", BigInt(block)),\n          )\n          .deleteFrom(\"factoryTraceFilterIntervals\")\n          .where(\n            \"factoryId\",\n            \"in\",\n            sql`(SELECT \"factoryId\" FROM ${sql.table(\"deleteFactoryTraceFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .with(\"updateFactoryTraceFilter(factoryId)\", (qb) =>\n            qb\n              .selectFrom(\"factoryTraceFilterIntervals\")\n              .innerJoin(\n                \"factoryTraceFilters\",\n                \"factoryId\",\n                \"factoryTraceFilters.id\",\n              )\n\n              .select(\"factoryId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \"<\", BigInt(block))\n              .where(\"endBlock\", \">\", BigInt(block)),\n          )\n          .updateTable(\"factoryTraceFilterIntervals\")\n          .set({\n            endBlock: BigInt(block),\n          })\n          .where(\n            \"factoryId\",\n            \"in\",\n            sql`(SELECT \"factoryId\" FROM ${sql.table(\"updateFactoryTraceFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .with(\"deleteBlockFilter(blockFilterId)\", (qb) =>\n            qb\n              .selectFrom(\"blockFilterIntervals\")\n              .innerJoin(\"blockFilters\", \"blockFilterId\", \"blockFilters.id\")\n              .select(\"blockFilterId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \">=\", BigInt(block)),\n          )\n          .deleteFrom(\"blockFilterIntervals\")\n          .where(\n            \"blockFilterId\",\n            \"in\",\n            sql`(SELECT \"blockFilterId\" FROM ${sql.table(\"deleteBlockFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .with(\"updateBlockFilter(blockFilterId)\", (qb) =>\n            qb\n              .selectFrom(\"blockFilterIntervals\")\n              .innerJoin(\"blockFilters\", \"blockFilterId\", \"blockFilters.id\")\n              .select(\"blockFilterId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \"<\", BigInt(block))\n              .where(\"endBlock\", \">\", BigInt(block)),\n          )\n          .updateTable(\"blockFilterIntervals\")\n          .set({\n            endBlock: BigInt(block),\n          })\n          .where(\n            \"blockFilterId\",\n            \"in\",\n            sql`(SELECT \"blockFilterId\" FROM ${sql.table(\"updateBlockFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .deleteFrom(\"logs\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"blockNumber\", \">=\", BigInt(block))\n          .execute();\n        await tx\n          .deleteFrom(\"blocks\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"number\", \">=\", BigInt(block))\n          .execute();\n        await tx\n          .deleteFrom(\"rpcRequestResults\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"blockNumber\", \">=\", BigInt(block))\n          .execute();\n        await tx\n          .deleteFrom(\"callTraces\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"blockNumber\", \">=\", BigInt(block))\n          .execute();\n        await tx\n          .deleteFrom(\"transactions\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"blockNumber\", \">=\", BigInt(block))\n          .execute();\n        await tx\n          .deleteFrom(\"transactionReceipts\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"blockNumber\", \">=\", BigInt(block))\n          .execute();\n      }),\n    );\n  }\n}\n\nfunction buildFactoryChildAddressSelectExpression({\n  childAddressLocation,\n}: {\n  childAddressLocation: FactoryLogFilterCriteria[\"childAddressLocation\"];\n}) {\n  if (childAddressLocation.startsWith(\"offset\")) {\n    const childAddressOffset = Number(childAddressLocation.substring(6));\n    const start = 2 + 12 * 2 + childAddressOffset * 2 + 1;\n    const length = 20 * 2;\n    return sql<Hex>`'0x' || substring(data from ${start}::int for ${length}::int)`;\n  } else {\n    const start = 2 + 12 * 2 + 1;\n    const length = 20 * 2;\n    return sql<Hex>`'0x' || substring(${sql.ref(\n      childAddressLocation,\n    )} from ${start}::integer for ${length}::integer)`;\n  }\n}\n","import type { SyncCallTrace } from \"@/sync/index.js\";\nimport { toLowerCase } from \"@/utils/lowercase.js\";\nimport type { Generated, Insertable } from \"kysely\";\nimport {\n  type Address,\n  type Hash,\n  type Hex,\n  type RpcTransactionReceipt,\n  hexToBigInt,\n} from \"viem\";\nimport {\n  type RpcBlock,\n  type RpcLog,\n  type RpcTransaction,\n  hexToNumber,\n} from \"viem\";\n\ntype BlocksTable = {\n  baseFeePerGas: bigint | null;\n  difficulty: bigint;\n  extraData: Hex;\n  gasLimit: bigint;\n  gasUsed: bigint;\n  hash: Hash;\n  logsBloom: Hex;\n  miner: Address;\n  mixHash: Hash | null;\n  nonce: Hex | null;\n  number: bigint;\n  parentHash: Hash;\n  receiptsRoot: Hex;\n  sha3Uncles: Hash | null;\n  size: bigint;\n  stateRoot: Hash;\n  timestamp: bigint;\n  totalDifficulty: bigint | null;\n  transactionsRoot: Hash;\n\n  chainId: number;\n  checkpoint: string;\n};\n\nexport type InsertableBlock = Insertable<BlocksTable>;\n\nexport function rpcToPostgresBlock(\n  block: RpcBlock,\n): Omit<InsertableBlock, \"chainId\" | \"checkpoint\"> {\n  return {\n    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,\n    difficulty: BigInt(block.difficulty),\n    extraData: block.extraData,\n    gasLimit: BigInt(block.gasLimit),\n    gasUsed: BigInt(block.gasUsed),\n    hash: block.hash!,\n    logsBloom: block.logsBloom!,\n    miner: toLowerCase(block.miner),\n    mixHash: block.mixHash ?? null,\n    nonce: block.nonce ?? null,\n    number: BigInt(block.number!),\n    parentHash: block.parentHash,\n    receiptsRoot: block.receiptsRoot,\n    sha3Uncles: block.sha3Uncles ?? null,\n    size: BigInt(block.size),\n    stateRoot: block.stateRoot,\n    timestamp: BigInt(block.timestamp),\n    totalDifficulty: block.totalDifficulty\n      ? BigInt(block.totalDifficulty)\n      : null,\n    transactionsRoot: block.transactionsRoot,\n  };\n}\n\ntype TransactionsTable = {\n  blockHash: Hash;\n  blockNumber: bigint;\n  from: Address;\n  gas: bigint;\n  hash: Hash;\n  input: Hex;\n  nonce: number;\n  r: Hex | null;\n  s: Hex | null;\n  to: Address | null;\n  transactionIndex: number;\n  v: bigint | null;\n  value: bigint;\n\n  type: Hex;\n  gasPrice: bigint | null;\n  maxFeePerGas: bigint | null;\n  maxPriorityFeePerGas: bigint | null;\n  accessList: string | null;\n\n  chainId: number;\n};\n\nexport type InsertableTransaction = Insertable<TransactionsTable>;\n\nexport function rpcToPostgresTransaction(\n  transaction: RpcTransaction,\n): Omit<InsertableTransaction, \"chainId\"> {\n  return {\n    accessList: transaction.accessList\n      ? JSON.stringify(transaction.accessList)\n      : undefined,\n    blockHash: transaction.blockHash!,\n    blockNumber: BigInt(transaction.blockNumber!),\n    from: toLowerCase(transaction.from),\n    gas: BigInt(transaction.gas),\n    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : null,\n    hash: transaction.hash,\n    input: transaction.input,\n    maxFeePerGas: transaction.maxFeePerGas\n      ? BigInt(transaction.maxFeePerGas)\n      : null,\n    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas\n      ? BigInt(transaction.maxPriorityFeePerGas)\n      : null,\n    nonce: hexToNumber(transaction.nonce),\n    r: transaction.r ?? null,\n    s: transaction.s ?? null,\n    to: transaction.to ? toLowerCase(transaction.to) : null,\n    transactionIndex: Number(transaction.transactionIndex),\n    type: transaction.type ?? \"0x0\",\n    value: BigInt(transaction.value),\n    v: transaction.v ? BigInt(transaction.v) : null,\n  };\n}\n\ntype TransactionReceiptsTable = {\n  blockHash: Hash;\n  blockNumber: bigint;\n  contractAddress: Address | null;\n  cumulativeGasUsed: bigint;\n  effectiveGasPrice: bigint;\n  from: Address;\n  gasUsed: bigint;\n  logs: string;\n  logsBloom: Hex;\n  status: Hex;\n  to: Address | null;\n  transactionHash: Hash;\n  transactionIndex: number;\n  type: Hex;\n\n  chainId: number;\n};\n\nexport type InsertableTransactionReceipts =\n  Insertable<TransactionReceiptsTable>;\n\nexport function rpcToPostgresTransactionReceipt(\n  transactionReceipt: RpcTransactionReceipt,\n): Omit<TransactionReceiptsTable, \"chainId\"> {\n  return {\n    blockHash: transactionReceipt.blockHash,\n    blockNumber: BigInt(transactionReceipt.blockNumber),\n    contractAddress: transactionReceipt.contractAddress\n      ? toLowerCase(transactionReceipt.contractAddress)\n      : null,\n    cumulativeGasUsed: BigInt(transactionReceipt.cumulativeGasUsed),\n    effectiveGasPrice: BigInt(transactionReceipt.effectiveGasPrice),\n    from: toLowerCase(transactionReceipt.from),\n    gasUsed: BigInt(transactionReceipt.gasUsed),\n    logs: JSON.stringify(transactionReceipt.logs),\n    logsBloom: transactionReceipt.logsBloom,\n    status: transactionReceipt.status,\n    to: transactionReceipt.to ? toLowerCase(transactionReceipt.to) : null,\n    transactionHash: transactionReceipt.transactionHash,\n    transactionIndex: Number(transactionReceipt.transactionIndex),\n    type: transactionReceipt.type as Hex,\n  };\n}\n\ntype LogsTable = {\n  id: string;\n  address: Address;\n  blockHash: Hash;\n  blockNumber: bigint;\n  data: Hex;\n  logIndex: number;\n  transactionHash: Hash;\n  transactionIndex: number;\n\n  topic0: Hex | null;\n  topic1: Hex | null;\n  topic2: Hex | null;\n  topic3: Hex | null;\n\n  chainId: number;\n  checkpoint?: string;\n};\n\nexport type InsertableLog = Insertable<LogsTable>;\n\nexport function rpcToPostgresLog(log: RpcLog): Omit<InsertableLog, \"chainId\"> {\n  return {\n    address: toLowerCase(log.address),\n    blockHash: log.blockHash!,\n    blockNumber: BigInt(log.blockNumber!),\n    data: log.data,\n    id: `${log.blockHash}-${log.logIndex}`,\n    logIndex: Number(log.logIndex!),\n    topic0: log.topics[0] ? log.topics[0] : null,\n    topic1: log.topics[1] ? log.topics[1] : null,\n    topic2: log.topics[2] ? log.topics[2] : null,\n    topic3: log.topics[3] ? log.topics[3] : null,\n    transactionHash: log.transactionHash!,\n    transactionIndex: Number(log.transactionIndex!),\n  };\n}\n\ntype CallTracesTable = {\n  id: string;\n  callType: string;\n  from: Address;\n  gas: bigint;\n  input: Hex;\n  to: Address;\n  value: bigint;\n  blockHash: Hex;\n  blockNumber: bigint;\n  error: string | null;\n  gasUsed: bigint | null;\n  output: Hex | null;\n  subtraces: number;\n  traceAddress: string;\n  transactionHash: Hex;\n  transactionPosition: number;\n  functionSelector: Hex;\n  chainId: number;\n  checkpoint: string;\n};\n\nexport type InsertableCallTrace = Insertable<CallTracesTable>;\n\nexport function rpcToPostgresTrace(\n  trace: SyncCallTrace,\n): Omit<InsertableCallTrace, \"chainId\" | \"checkpoint\"> {\n  return {\n    id: `${trace.transactionHash}-${JSON.stringify(trace.traceAddress)}`,\n    callType: trace.action.callType,\n    from: toLowerCase(trace.action.from),\n    gas: hexToBigInt(trace.action.gas),\n    input: trace.action.input,\n    to: toLowerCase(trace.action.to),\n    value: hexToBigInt(trace.action.value),\n    blockHash: trace.blockHash,\n    blockNumber: hexToBigInt(trace.blockNumber),\n    error: trace.error ?? null,\n    gasUsed: trace.result ? hexToBigInt(trace.result.gasUsed) : null,\n    output: trace.result ? trace.result.output : null,\n    subtraces: trace.subtraces,\n    traceAddress: JSON.stringify(trace.traceAddress),\n    transactionHash: trace.transactionHash,\n    transactionPosition: trace.transactionPosition,\n    functionSelector: trace.action.input.slice(0, 10).toLowerCase() as Hex,\n  };\n}\n\ntype RpcRequestResultsTable = {\n  blockNumber: bigint;\n  chainId: number;\n  request: string;\n  result: string;\n};\n\ntype LogFiltersTable = {\n  id: string;\n  chainId: number;\n  address: Hex | null;\n  topic0: Hex | null;\n  topic1: Hex | null;\n  topic2: Hex | null;\n  topic3: Hex | null;\n  includeTransactionReceipts: 0 | 1;\n};\n\ntype LogFilterIntervalsTable = {\n  id: Generated<number>;\n  logFilterId: string;\n  startBlock: bigint;\n  endBlock: bigint;\n};\n\ntype FactoryLogFiltersTable = {\n  id: string;\n  chainId: number;\n  address: Hex;\n  eventSelector: Hex;\n  childAddressLocation: `topic${1 | 2 | 3}` | `offset${number}`;\n  topic0: Hex | null;\n  topic1: Hex | null;\n  topic2: Hex | null;\n  topic3: Hex | null;\n  includeTransactionReceipts: 0 | 1;\n};\n\ntype FactoryLogFilterIntervalsTable = {\n  id: Generated<number>;\n  factoryId: string;\n  startBlock: bigint;\n  endBlock: bigint;\n};\n\ntype TraceFiltersTable = {\n  id: string;\n  chainId: number;\n  fromAddress: Address | null;\n  toAddress: Address | null;\n};\n\ntype TraceFilterIntervalsTable = {\n  id: Generated<number>;\n  traceFilterId: string;\n  startBlock: bigint;\n  endBlock: bigint;\n};\n\ntype FactoryTraceFiltersTable = {\n  id: string;\n  chainId: number;\n  address: Hex;\n  eventSelector: Hex;\n  childAddressLocation: `topic${1 | 2 | 3}` | `offset${number}`;\n  fromAddress: Address | null;\n};\n\ntype FactoryTraceFilterIntervalsTable = {\n  id: Generated<number>;\n  factoryId: string;\n  startBlock: bigint;\n  endBlock: bigint;\n};\n\ntype BlockFiltersTable = {\n  id: string;\n  chainId: number;\n  interval: number;\n  offset: number;\n};\n\ntype BlockFilterIntervalsTable = {\n  id: Generated<number>;\n  blockFilterId: string;\n  startBlock: bigint;\n  endBlock: bigint;\n};\n\nexport type SyncStoreTables = {\n  blocks: BlocksTable;\n  transactions: TransactionsTable;\n  transactionReceipts: TransactionReceiptsTable;\n  logs: LogsTable;\n  callTraces: CallTracesTable;\n  rpcRequestResults: RpcRequestResultsTable;\n\n  logFilters: LogFiltersTable;\n  logFilterIntervals: LogFilterIntervalsTable;\n  factoryLogFilters: FactoryLogFiltersTable;\n  factoryLogFilterIntervals: FactoryLogFilterIntervalsTable;\n  traceFilters: TraceFiltersTable;\n  traceFilterIntervals: TraceFilterIntervalsTable;\n  factoryTraceFilters: FactoryTraceFiltersTable;\n  factoryTraceFilterIntervals: FactoryTraceFilterIntervalsTable;\n  blockFilters: BlockFiltersTable;\n  blockFilterIntervals: BlockFilterIntervalsTable;\n};\n","import type { Common } from \"@/common/common.js\";\nimport { NonRetryableError } from \"@/common/errors.js\";\nimport {\n  type BlockFilterCriteria,\n  type CallTraceFilterCriteria,\n  type CallTraceSource,\n  type EventSource,\n  type FactoryCallTraceFilterCriteria,\n  type FactoryCallTraceSource,\n  type FactoryLogFilterCriteria,\n  type FactoryLogSource,\n  type LogFilterCriteria,\n  type LogSource,\n  sourceIsBlock,\n  sourceIsCallTrace,\n  sourceIsFactoryCallTrace,\n  sourceIsFactoryLog,\n  sourceIsLog,\n} from \"@/config/sources.js\";\nimport type { HeadlessKysely } from \"@/database/kysely.js\";\nimport type {\n  SyncBlock,\n  SyncCallTrace,\n  SyncLog,\n  SyncTransaction,\n  SyncTransactionReceipt,\n} from \"@/sync/index.js\";\nimport type { CallTrace, Log } from \"@/types/eth.js\";\nimport type { NonNull } from \"@/types/utils.js\";\nimport {\n  type Checkpoint,\n  EVENT_TYPES,\n  decodeCheckpoint,\n  encodeCheckpoint,\n  maxCheckpoint,\n  zeroCheckpoint,\n} from \"@/utils/checkpoint.js\";\nimport { decodeToBigInt, encodeAsText } from \"@/utils/encoding.js\";\nimport {\n  buildFactoryLogFragments,\n  buildFactoryTraceFragments,\n  buildLogFilterFragments,\n  buildTraceFragments,\n} from \"@/utils/fragments.js\";\nimport { intervalIntersectionMany, intervalUnion } from \"@/utils/interval.js\";\nimport { range } from \"@/utils/range.js\";\nimport {\n  type ExpressionBuilder,\n  type Transaction as KyselyTransaction,\n  type OperandExpression,\n  type SqlBool,\n  sql,\n} from \"kysely\";\nimport {\n  type Hex,\n  type TransactionReceipt,\n  checksumAddress,\n  hexToBigInt,\n  hexToNumber,\n} from \"viem\";\nimport type { RawEvent, SyncStore } from \"../store.js\";\nimport {\n  type InsertableCallTrace,\n  rpcToSqliteTrace,\n  rpcToSqliteTransactionReceipt,\n} from \"./encoding.js\";\nimport {\n  type SyncStoreTables,\n  rpcToSqliteBlock,\n  rpcToSqliteLog,\n  rpcToSqliteTransaction,\n} from \"./encoding.js\";\n\nexport class SqliteSyncStore implements SyncStore {\n  kind = \"sqlite\" as const;\n  db: HeadlessKysely<SyncStoreTables>;\n  common: Common;\n\n  private seconds: number;\n\n  constructor({\n    db,\n    common,\n  }: { db: HeadlessKysely<SyncStoreTables>; common: Common }) {\n    this.db = db;\n    this.common = common;\n\n    this.seconds = common.options.syncEventsQuerySize * 2;\n  }\n\n  insertLogFilterInterval = async ({\n    chainId,\n    logFilter,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    transactionReceipts: rpcTransactionReceipts,\n    logs: rpcLogs,\n    interval,\n  }: {\n    chainId: number;\n    logFilter: LogFilterCriteria;\n    block: SyncBlock;\n    transactions: SyncTransaction[];\n    transactionReceipts: SyncTransactionReceipt[];\n    logs: SyncLog[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    return this.db.wrap({ method: \"insertLogFilterInterval\" }, async () => {\n      await this.db.transaction().execute(async (tx) => {\n        await tx\n          .insertInto(\"blocks\")\n          .values({\n            ...rpcToSqliteBlock(rpcBlock),\n            chainId,\n            checkpoint: this.createBlockCheckpoint(rpcBlock, chainId),\n          })\n          .onConflict((oc) => oc.column(\"hash\").doNothing())\n          .execute();\n\n        if (rpcTransactions.length > 0) {\n          const transactions = rpcTransactions.map((rpcTransaction) => ({\n            ...rpcToSqliteTransaction(rpcTransaction),\n            chainId,\n          }));\n          await tx\n            .insertInto(\"transactions\")\n            .values(transactions)\n            .onConflict((oc) => oc.column(\"hash\").doNothing())\n            .execute();\n        }\n\n        if (rpcTransactionReceipts.length > 0) {\n          const transactionReceipts = rpcTransactionReceipts.map(\n            (rpcTransactionReceipt) => ({\n              ...rpcToSqliteTransactionReceipt(rpcTransactionReceipt),\n              chainId,\n            }),\n          );\n          await tx\n            .insertInto(\"transactionReceipts\")\n            .values(transactionReceipts)\n            .onConflict((oc) => oc.column(\"transactionHash\").doNothing())\n            .execute();\n        }\n\n        if (rpcLogs.length > 0) {\n          const logs = rpcLogs.map((rpcLog) => ({\n            ...rpcToSqliteLog(rpcLog),\n            chainId,\n            checkpoint: this.createLogCheckpoint(rpcLog, rpcBlock, chainId),\n          }));\n          await tx\n            .insertInto(\"logs\")\n            .values(logs)\n            .onConflict((oc) =>\n              oc.column(\"id\").doUpdateSet((eb) => ({\n                checkpoint: eb.ref(\"excluded.checkpoint\"),\n              })),\n            )\n            .execute();\n        }\n\n        await this._insertLogFilterInterval({\n          tx,\n          chainId,\n          logFilters: [logFilter],\n          interval,\n        });\n      });\n    });\n  };\n\n  getLogFilterIntervals = async ({\n    chainId,\n    logFilter,\n  }: {\n    chainId: number;\n    logFilter: LogFilterCriteria;\n  }) => {\n    return this.db.wrap({ method: \"getLogFilterIntervals\" }, async () => {\n      const fragments = buildLogFilterFragments({ ...logFilter, chainId });\n\n      for (const fragment of fragments) {\n        await this.db.transaction().execute(async (tx) => {\n          while (true) {\n            const { id: logFilterId } = await tx\n              .insertInto(\"logFilters\")\n              .values(fragment)\n              .onConflict((oc) => oc.doUpdateSet(fragment))\n              .returningAll()\n              .executeTakeFirstOrThrow();\n\n            // This is a trick to add a LIMIT to a DELETE statement\n            const existingIntervals = await tx\n              .deleteFrom(\"logFilterIntervals\")\n              .where(\n                \"id\",\n                \"in\",\n                tx\n                  .selectFrom(\"logFilterIntervals\")\n                  .where(\"logFilterId\", \"=\", logFilterId)\n                  .select(\"id\")\n                  .limit(this.common.options.syncStoreMaxIntervals),\n              )\n              .returning([\"startBlock\", \"endBlock\"])\n              .execute();\n\n            const mergedIntervals = intervalUnion(\n              existingIntervals.map((i) => [\n                Number(decodeToBigInt(i.startBlock)),\n                Number(decodeToBigInt(i.endBlock)),\n              ]),\n            );\n\n            const mergedIntervalRows = mergedIntervals.map(\n              ([startBlock, endBlock]) => ({\n                logFilterId,\n                startBlock: encodeAsText(startBlock),\n                endBlock: encodeAsText(endBlock),\n              }),\n            );\n\n            if (mergedIntervalRows.length > 0) {\n              await tx\n                .insertInto(\"logFilterIntervals\")\n                .values(mergedIntervalRows)\n                .execute();\n            }\n\n            if (\n              mergedIntervalRows.length ===\n              this.common.options.syncStoreMaxIntervals\n            ) {\n              // This occurs when there are too many non-mergeable ranges with the same logFilterId. Should be almost impossible.\n              throw new NonRetryableError(\n                `'logFilterIntervals' table for chain '${chainId}' has reached an unrecoverable level of fragmentation.`,\n              );\n            }\n\n            if (\n              existingIntervals.length !==\n              this.common.options.syncStoreMaxIntervals\n            )\n              break;\n          }\n        });\n      }\n\n      const intervals = await this.db\n        .with(\n          \"logFilterFragments(fragmentId, fragmentAddress, fragmentTopic0, fragmentTopic1, fragmentTopic2, fragmentTopic3, fragmentIncludeTransactionReceipts)\",\n          () =>\n            sql`( values ${sql.join(\n              fragments.map(\n                (f) =>\n                  sql`( ${sql.val(f.id)}, ${sql.val(f.address)}, ${sql.val(f.topic0)}, ${sql.val(\n                    f.topic1,\n                  )}, ${sql.val(f.topic2)}, ${sql.val(f.topic3)}, ${sql.lit(\n                    f.includeTransactionReceipts,\n                  )} )`,\n              ),\n            )} )`,\n        )\n        .selectFrom(\"logFilterIntervals\")\n        .innerJoin(\"logFilters\", \"logFilterId\", \"logFilters.id\")\n        .innerJoin(\"logFilterFragments\", (join) => {\n          let baseJoin = join.on((eb) =>\n            eb.or([\n              eb(\"address\", \"is\", null),\n              eb(\"fragmentAddress\", \"=\", sql.ref(\"address\")),\n            ]),\n          );\n          baseJoin = baseJoin.on((eb) =>\n            eb(\n              \"fragmentIncludeTransactionReceipts\",\n              \"<=\",\n              sql.ref(\"includeTransactionReceipts\"),\n            ),\n          );\n          for (const idx_ of range(0, 4)) {\n            baseJoin = baseJoin.on((eb) => {\n              const idx = idx_ as 0 | 1 | 2 | 3;\n              return eb.or([\n                eb(`topic${idx}`, \"is\", null),\n                eb(`fragmentTopic${idx}`, \"=\", sql.ref(`topic${idx}`)),\n              ]);\n            });\n          }\n\n          return baseJoin;\n        })\n        .select([\"fragmentId\", \"startBlock\", \"endBlock\"])\n        .where(\"chainId\", \"=\", chainId)\n        .execute();\n\n      const intervalsByFragmentId = intervals.reduce(\n        (acc, cur) => {\n          const { fragmentId, startBlock, endBlock } = cur;\n          (acc[fragmentId] ||= []).push([\n            Number(decodeToBigInt(startBlock)),\n            Number(decodeToBigInt(endBlock)),\n          ]);\n          return acc;\n        },\n        {} as Record<string, [number, number][]>,\n      );\n\n      const intervalsForEachFragment = fragments.map((f) =>\n        intervalUnion(intervalsByFragmentId[f.id] ?? []),\n      );\n      return intervalIntersectionMany(intervalsForEachFragment);\n    });\n  };\n\n  insertFactoryChildAddressLogs = async ({\n    chainId,\n    logs: rpcLogs,\n  }: {\n    chainId: number;\n    logs: SyncLog[];\n  }) => {\n    return this.db.wrap(\n      { method: \"insertFactoryChildAddressLogs\" },\n      async () => {\n        if (rpcLogs.length > 0) {\n          const logs = rpcLogs.map((rpcLog) => ({\n            ...rpcToSqliteLog(rpcLog),\n            chainId,\n          }));\n          await this.db\n            .insertInto(\"logs\")\n            .values(logs)\n            .onConflict((oc) => oc.column(\"id\").doNothing())\n            .execute();\n        }\n      },\n    );\n  };\n\n  async *getFactoryChildAddresses({\n    chainId,\n    fromBlock,\n    toBlock,\n    factory,\n    pageSize = 500,\n  }: {\n    chainId: number;\n    fromBlock: bigint;\n    toBlock: bigint;\n    factory: FactoryLogFilterCriteria | FactoryCallTraceFilterCriteria;\n    pageSize?: number;\n  }) {\n    const { address, eventSelector, childAddressLocation } = factory;\n    const selectChildAddressExpression =\n      buildFactoryChildAddressSelectExpression({\n        childAddressLocation,\n      });\n\n    const baseQuery = this.db\n      .selectFrom(\"logs\")\n      .select([\"id\", selectChildAddressExpression.as(\"childAddress\")])\n      .where(\"chainId\", \"=\", chainId)\n      .where(\"address\", \"=\", address)\n      .where(\"topic0\", \"=\", eventSelector)\n      .where(\"blockNumber\", \">=\", encodeAsText(fromBlock))\n      .where(\"blockNumber\", \"<=\", encodeAsText(toBlock))\n      .orderBy(\"id\", \"asc\")\n      .limit(pageSize);\n\n    let cursor: string | undefined = undefined;\n\n    while (true) {\n      let query = baseQuery;\n      if (cursor !== undefined) query = query.where(\"id\", \">\", cursor);\n\n      const batch = await this.db.wrap(\n        { method: \"getFactoryChildAddresses\" },\n        () => query.execute(),\n      );\n\n      if (batch.length > 0) {\n        yield batch.map((a) => a.childAddress);\n      }\n\n      // If the batch is less than the page size, there are no more pages.\n      if (batch.length < pageSize) break;\n      // Otherwise, set the cursor to the last block number in the batch.\n      cursor = batch[batch.length - 1]!.id;\n    }\n  }\n\n  insertFactoryLogFilterInterval = async ({\n    chainId,\n    factory,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    transactionReceipts: rpcTransactionReceipts,\n    logs: rpcLogs,\n    interval,\n  }: {\n    chainId: number;\n    factory: FactoryLogFilterCriteria;\n    block: SyncBlock;\n    transactions: SyncTransaction[];\n    transactionReceipts: SyncTransactionReceipt[];\n    logs: SyncLog[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    return this.db.wrap(\n      { method: \"insertFactoryLogFilterInterval\" },\n      async () => {\n        await this.db.transaction().execute(async (tx) => {\n          await tx\n            .insertInto(\"blocks\")\n            .values({\n              ...rpcToSqliteBlock(rpcBlock),\n              chainId,\n              checkpoint: this.createBlockCheckpoint(rpcBlock, chainId),\n            })\n            .onConflict((oc) => oc.column(\"hash\").doNothing())\n            .execute();\n\n          if (rpcTransactions.length > 0) {\n            const transactions = rpcTransactions.map((rpcTransaction) => ({\n              ...rpcToSqliteTransaction(rpcTransaction),\n              chainId,\n            }));\n            await tx\n              .insertInto(\"transactions\")\n              .values(transactions)\n              .onConflict((oc) => oc.column(\"hash\").doNothing())\n              .execute();\n          }\n\n          if (rpcTransactionReceipts.length > 0) {\n            const transactionReceipts = rpcTransactionReceipts.map(\n              (rpcTransactionReceipt) => ({\n                ...rpcToSqliteTransactionReceipt(rpcTransactionReceipt),\n                chainId,\n              }),\n            );\n            await tx\n              .insertInto(\"transactionReceipts\")\n              .values(transactionReceipts)\n              .onConflict((oc) => oc.column(\"transactionHash\").doNothing())\n              .execute();\n          }\n\n          if (rpcLogs.length > 0) {\n            const logs = rpcLogs.map((rpcLog) => ({\n              ...rpcToSqliteLog(rpcLog),\n              chainId,\n              checkpoint: this.createLogCheckpoint(rpcLog, rpcBlock, chainId),\n            }));\n            await tx\n              .insertInto(\"logs\")\n              .values(logs)\n              .onConflict((oc) =>\n                oc.column(\"id\").doUpdateSet((eb) => ({\n                  checkpoint: eb.ref(\"excluded.checkpoint\"),\n                })),\n              )\n              .execute();\n          }\n\n          await this._insertFactoryLogFilterInterval({\n            tx,\n            chainId,\n            factoryLogFilters: [factory],\n            interval,\n          });\n        });\n      },\n    );\n  };\n\n  getFactoryLogFilterIntervals = async ({\n    chainId,\n    factory,\n  }: {\n    chainId: number;\n    factory: FactoryLogFilterCriteria;\n  }) => {\n    return this.db.wrap(\n      { method: \"getFactoryLogFilterIntervals\" },\n      async () => {\n        const fragments = buildFactoryLogFragments({ ...factory, chainId });\n\n        for (const fragment of fragments) {\n          await this.db.transaction().execute(async (tx) => {\n            while (true) {\n              const { id: factoryId } = await tx\n                .insertInto(\"factoryLogFilters\")\n                .values(fragment)\n                .onConflict((oc) => oc.doUpdateSet(fragment))\n                .returningAll()\n                .executeTakeFirstOrThrow();\n\n              // This is a trick to add a LIMIT to a DELETE statement\n              const existingIntervals = await tx\n                .deleteFrom(\"factoryLogFilterIntervals\")\n                .where(\n                  \"id\",\n                  \"in\",\n                  tx\n                    .selectFrom(\"factoryLogFilterIntervals\")\n                    .where(\"factoryId\", \"=\", factoryId)\n                    .select(\"id\")\n                    .limit(this.common.options.syncStoreMaxIntervals),\n                )\n                .returning([\"startBlock\", \"endBlock\"])\n                .execute();\n\n              const mergedIntervals = intervalUnion(\n                existingIntervals.map((i) => [\n                  Number(decodeToBigInt(i.startBlock)),\n                  Number(decodeToBigInt(i.endBlock)),\n                ]),\n              );\n\n              const mergedIntervalRows = mergedIntervals.map(\n                ([startBlock, endBlock]) => ({\n                  factoryId,\n                  startBlock: encodeAsText(startBlock),\n                  endBlock: encodeAsText(endBlock),\n                }),\n              );\n\n              if (mergedIntervalRows.length > 0) {\n                await tx\n                  .insertInto(\"factoryLogFilterIntervals\")\n                  .values(mergedIntervalRows)\n                  .execute();\n              }\n\n              if (\n                mergedIntervalRows.length ===\n                this.common.options.syncStoreMaxIntervals\n              ) {\n                // This occurs when there are too many non-mergeable ranges with the same factoryId. Should be almost impossible.\n                throw new NonRetryableError(\n                  `'factoryLogFilterIntervals' table for chain '${chainId}' has reached an unrecoverable level of fragmentation.`,\n                );\n              }\n\n              if (\n                existingIntervals.length !==\n                this.common.options.syncStoreMaxIntervals\n              )\n                break;\n            }\n          });\n        }\n\n        const intervals = await this.db\n          .with(\n            \"factoryFilterFragments(fragmentId, fragmentAddress, fragmentEventSelector, fragmentChildAddressLocation, fragmentTopic0, fragmentTopic1, fragmentTopic2, fragmentTopic3, fragmentIncludeTransactionReceipts)\",\n            () =>\n              sql`( values ${sql.join(\n                fragments.map(\n                  (f) =>\n                    sql`( ${sql.val(f.id)}, ${sql.val(f.address)}, ${sql.val(\n                      f.eventSelector,\n                    )}, ${sql.val(f.childAddressLocation)}, ${sql.val(f.topic0)}, ${sql.val(\n                      f.topic1,\n                    )}, ${sql.val(f.topic2)}, ${sql.val(f.topic3)}, ${sql.lit(\n                      f.includeTransactionReceipts,\n                    )} )`,\n                ),\n              )} )`,\n          )\n          .selectFrom(\"factoryLogFilterIntervals\")\n          .innerJoin(\"factoryLogFilters\", \"factoryId\", \"factoryLogFilters.id\")\n          .innerJoin(\"factoryFilterFragments\", (join) => {\n            let baseJoin = join.on((eb) =>\n              eb.and([\n                eb(\"fragmentAddress\", \"=\", sql.ref(\"address\")),\n                eb(\"fragmentEventSelector\", \"=\", sql.ref(\"eventSelector\")),\n                eb(\n                  \"fragmentChildAddressLocation\",\n                  \"=\",\n                  sql.ref(\"childAddressLocation\"),\n                ),\n              ]),\n            );\n            baseJoin = baseJoin.on((eb) =>\n              eb(\n                \"fragmentIncludeTransactionReceipts\",\n                \"<=\",\n                sql.ref(\"includeTransactionReceipts\"),\n              ),\n            );\n            for (const idx_ of range(0, 4)) {\n              baseJoin = baseJoin.on((eb) => {\n                const idx = idx_ as 0 | 1 | 2 | 3;\n                return eb.or([\n                  eb(`topic${idx}`, \"is\", null),\n                  eb(`fragmentTopic${idx}`, \"=\", sql.ref(`topic${idx}`)),\n                ]);\n              });\n            }\n\n            return baseJoin;\n          })\n          .select([\"fragmentId\", \"startBlock\", \"endBlock\"])\n          .where(\"chainId\", \"=\", chainId)\n          .execute();\n\n        const intervalsByFragmentId = intervals.reduce(\n          (acc, cur) => {\n            const { fragmentId, startBlock, endBlock } = cur;\n            (acc[fragmentId] ||= []).push([\n              Number(startBlock),\n              Number(endBlock),\n            ]);\n            return acc;\n          },\n          {} as Record<string, [number, number][]>,\n        );\n\n        const intervalsForEachFragment = fragments.map((f) =>\n          intervalUnion(intervalsByFragmentId[f.id] ?? []),\n        );\n        return intervalIntersectionMany(intervalsForEachFragment);\n      },\n    );\n  };\n\n  insertBlockFilterInterval = async ({\n    chainId,\n    blockFilter,\n    block: rpcBlock,\n    interval,\n  }: {\n    chainId: number;\n    blockFilter: BlockFilterCriteria;\n    block?: SyncBlock;\n    interval: { startBlock: bigint; endBlock: bigint };\n  }): Promise<void> => {\n    return this.db.wrap({ method: \"insertBlockFilterInterval\" }, async () => {\n      await this.db.transaction().execute(async (tx) => {\n        if (rpcBlock !== undefined) {\n          await tx\n            .insertInto(\"blocks\")\n            .values({\n              ...rpcToSqliteBlock(rpcBlock),\n              chainId,\n              checkpoint: this.createBlockCheckpoint(rpcBlock, chainId),\n            })\n            .onConflict((oc) => oc.column(\"hash\").doNothing())\n            .execute();\n        }\n\n        await this._insertBlockFilterInterval({\n          tx,\n          chainId,\n          blockFilters: [blockFilter],\n          interval,\n        });\n      });\n    });\n  };\n\n  getBlockFilterIntervals = async ({\n    chainId,\n    blockFilter,\n  }: {\n    chainId: number;\n    blockFilter: BlockFilterCriteria;\n  }) => {\n    return this.db.wrap({ method: \"getBlockFilterIntervals\" }, async () => {\n      const fragment = {\n        id: `${chainId}_${blockFilter.interval}_${blockFilter.offset}`,\n        chainId,\n        interval: blockFilter.interval,\n        offset: blockFilter.offset,\n      };\n\n      // First, attempt to merge overlapping and adjacent intervals.\n      await this.db.transaction().execute(async (tx) => {\n        const { id: blockFilterId } = await tx\n          .insertInto(\"blockFilters\")\n          .values(fragment)\n          .onConflict((oc) => oc.doUpdateSet(fragment))\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        const existingIntervalRows = await tx\n          .deleteFrom(\"blockFilterIntervals\")\n          .where(\"blockFilterId\", \"=\", blockFilterId)\n          .returningAll()\n          .execute();\n\n        const mergedIntervals = intervalUnion(\n          existingIntervalRows.map((i) => [\n            Number(decodeToBigInt(i.startBlock)),\n            Number(decodeToBigInt(i.endBlock)),\n          ]),\n        );\n\n        const mergedIntervalRows = mergedIntervals.map(\n          ([startBlock, endBlock]) => ({\n            blockFilterId,\n            startBlock: encodeAsText(startBlock),\n            endBlock: encodeAsText(endBlock),\n          }),\n        );\n\n        if (mergedIntervalRows.length > 0) {\n          await tx\n            .insertInto(\"blockFilterIntervals\")\n            .values(mergedIntervalRows)\n            .execute();\n        }\n      });\n\n      const intervals = await this.db\n        .selectFrom(\"blockFilterIntervals\")\n        .innerJoin(\"blockFilters\", \"blockFilterId\", \"blockFilters.id\")\n        .select([\n          \"blockFilterIntervals.startBlock\",\n          \"blockFilterIntervals.endBlock\",\n        ])\n        .where(\"blockFilterId\", \"=\", fragment.id)\n        .execute();\n\n      return intervals.map(\n        ({ startBlock, endBlock }) =>\n          [Number(startBlock), Number(endBlock)] as [number, number],\n      );\n    });\n  };\n\n  getBlock = async ({\n    chainId,\n    blockNumber,\n  }: {\n    chainId: number;\n    blockNumber: number;\n  }): Promise<boolean> => {\n    const hasBlock = await this.db\n      .selectFrom(\"blocks\")\n      .select(\"hash\")\n      .where(\"number\", \"=\", encodeAsText(blockNumber))\n      .where(\"chainId\", \"=\", chainId)\n      .executeTakeFirst();\n\n    return hasBlock !== undefined;\n  };\n\n  insertTraceFilterInterval = async ({\n    chainId,\n    traceFilter,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    transactionReceipts: rpcTransactionReceipts,\n    traces: rpcTraces,\n    interval,\n  }: {\n    chainId: number;\n    traceFilter: CallTraceFilterCriteria;\n    block: SyncBlock;\n    transactions: SyncTransaction[];\n    transactionReceipts: SyncTransactionReceipt[];\n    traces: SyncCallTrace[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    return this.db.wrap({ method: \"insertTraceFilterInterval\" }, async () => {\n      await this.db.transaction().execute(async (tx) => {\n        await tx\n          .insertInto(\"blocks\")\n          .values({\n            ...rpcToSqliteBlock(rpcBlock),\n            chainId,\n            checkpoint: this.createBlockCheckpoint(rpcBlock, chainId),\n          })\n          .onConflict((oc) => oc.column(\"hash\").doNothing())\n          .execute();\n\n        if (rpcTransactions.length > 0) {\n          const transactions = rpcTransactions.map((transaction) => ({\n            ...rpcToSqliteTransaction(transaction),\n            chainId,\n          }));\n          await tx\n            .insertInto(\"transactions\")\n            .values(transactions)\n            .onConflict((oc) => oc.column(\"hash\").doNothing())\n            .execute();\n        }\n\n        if (rpcTransactionReceipts.length > 0) {\n          const transactionReceipts = rpcTransactionReceipts.map(\n            (rpcTransactionReceipt) => ({\n              ...rpcToSqliteTransactionReceipt(rpcTransactionReceipt),\n              chainId,\n            }),\n          );\n          await tx\n            .insertInto(\"transactionReceipts\")\n            .values(transactionReceipts)\n            .onConflict((oc) => oc.column(\"transactionHash\").doNothing())\n            .execute();\n        }\n\n        // Delete existing traces with the same `transactionHash`. Then, calculate \"callTraces.checkpoint\"\n        // based on the ordering of \"callTraces.traceAddress\" and add all traces to \"callTraces\" table.\n        const traceByTransactionHash: {\n          [transactionHash: Hex]: SyncCallTrace[];\n        } = {};\n        for (const trace of rpcTraces) {\n          if (traceByTransactionHash[trace.transactionHash] === undefined) {\n            traceByTransactionHash[trace.transactionHash] = [];\n          }\n          traceByTransactionHash[trace.transactionHash]!.push(trace);\n        }\n\n        for (const transactionHash of Object.keys(traceByTransactionHash)) {\n          const traces = await tx\n            .deleteFrom(\"callTraces\")\n            .returningAll()\n            .where(\"transactionHash\", \"=\", transactionHash as Hex)\n            .where(\"chainId\", \"=\", chainId)\n            .execute();\n\n          (traces as Omit<InsertableCallTrace, \"checkpoint\">[]).push(\n            ...traceByTransactionHash[transactionHash as Hex]!.map((trace) => ({\n              ...rpcToSqliteTrace(trace),\n              chainId,\n            })),\n          );\n\n          // Use lexographical sort of stringified `traceAddress`.\n          traces.sort((a, b) => {\n            return a.traceAddress < b.traceAddress ? -1 : 1;\n          });\n\n          for (let i = 0; i < traces.length; i++) {\n            const trace = traces[i]!;\n            const checkpoint = encodeCheckpoint({\n              blockTimestamp: hexToNumber(rpcBlock.timestamp),\n              chainId: BigInt(chainId),\n              blockNumber: decodeToBigInt(trace.blockNumber),\n              transactionIndex: BigInt(trace.transactionPosition),\n              eventType: EVENT_TYPES.callTraces,\n              eventIndex: BigInt(i),\n            });\n\n            trace.checkpoint = checkpoint;\n          }\n\n          await tx\n            .insertInto(\"callTraces\")\n            .values(traces)\n            .onConflict((oc) => oc.doNothing())\n            .execute();\n        }\n\n        await this._insertTraceFilterInterval({\n          tx,\n          chainId,\n          traceFilters: [traceFilter],\n          interval,\n        });\n      });\n    });\n  };\n\n  getTraceFilterIntervals = async ({\n    traceFilter,\n    chainId,\n  }: {\n    chainId: number;\n    traceFilter: CallTraceFilterCriteria;\n  }) => {\n    return this.db.wrap({ method: \"getTraceFilterIntervals\" }, async () => {\n      const fragments = buildTraceFragments({ ...traceFilter, chainId });\n\n      for (const fragment of fragments) {\n        await this.db.transaction().execute(async (tx) => {\n          while (true) {\n            const { id: traceFilterId } = await tx\n              .insertInto(\"traceFilters\")\n              .values(fragment)\n              .onConflict((oc) => oc.column(\"id\").doUpdateSet(fragment))\n              .returningAll()\n              .executeTakeFirstOrThrow();\n\n            // This is a trick to add a LIMIT to a DELETE statement\n            const existingIntervals = await tx\n              .deleteFrom(\"traceFilterIntervals\")\n              .where(\n                \"id\",\n                \"in\",\n                tx\n                  .selectFrom(\"traceFilterIntervals\")\n                  .where(\"traceFilterId\", \"=\", traceFilterId)\n                  .select(\"id\")\n                  .limit(this.common.options.syncStoreMaxIntervals),\n              )\n              .returning([\"startBlock\", \"endBlock\"])\n              .execute();\n\n            const mergedIntervals = intervalUnion(\n              existingIntervals.map((i) => [\n                Number(decodeToBigInt(i.startBlock)),\n                Number(decodeToBigInt(i.endBlock)),\n              ]),\n            );\n\n            const mergedIntervalRows = mergedIntervals.map(\n              ([startBlock, endBlock]) => ({\n                traceFilterId,\n                startBlock: encodeAsText(startBlock),\n                endBlock: encodeAsText(endBlock),\n              }),\n            );\n\n            if (mergedIntervalRows.length > 0) {\n              await tx\n                .insertInto(\"traceFilterIntervals\")\n                .values(mergedIntervalRows)\n                .execute();\n            }\n\n            if (\n              mergedIntervalRows.length ===\n              this.common.options.syncStoreMaxIntervals\n            ) {\n              // This occurs when there are too many non-mergeable ranges with the same factoryId. Should be almost impossible.\n              throw new NonRetryableError(\n                `'traceFilterIntervals' table for chain '${chainId}' has reached an unrecoverable level of fragmentation.`,\n              );\n            }\n\n            if (\n              existingIntervals.length !==\n              this.common.options.syncStoreMaxIntervals\n            )\n              break;\n          }\n        });\n      }\n\n      const intervals = await this.db\n        .with(\n          \"traceFilterFragments(fragmentId, fragmentFromAddress, fragmentToAddress)\",\n          () =>\n            sql`( values ${sql.join(\n              fragments.map(\n                (f) =>\n                  sql`( ${sql.val(f.id)}, ${sql.val(f.fromAddress)}, ${sql.val(f.toAddress)} )`,\n              ),\n            )} )`,\n        )\n        .selectFrom(\"traceFilterIntervals\")\n        .innerJoin(\"traceFilters\", \"traceFilterId\", \"traceFilters.id\")\n        .innerJoin(\"traceFilterFragments\", (join) => {\n          return join.on((eb) =>\n            eb.and([\n              eb.or([\n                eb(\"fromAddress\", \"is\", null),\n                eb(\"fragmentFromAddress\", \"=\", sql.ref(\"fromAddress\")),\n              ]),\n              eb.or([\n                eb(\"toAddress\", \"is\", null),\n                eb(\"fragmentToAddress\", \"=\", sql.ref(\"toAddress\")),\n              ]),\n            ]),\n          );\n        })\n        .select([\"fragmentId\", \"startBlock\", \"endBlock\"])\n        .where(\"chainId\", \"=\", chainId)\n        .execute();\n\n      const intervalsByFragmentId = intervals.reduce(\n        (acc, cur) => {\n          const { fragmentId, startBlock, endBlock } = cur;\n          (acc[fragmentId] ||= []).push([Number(startBlock), Number(endBlock)]);\n          return acc;\n        },\n        {} as Record<string, [number, number][]>,\n      );\n\n      const intervalsForEachFragment = fragments.map((f) =>\n        intervalUnion(intervalsByFragmentId[f.id] ?? []),\n      );\n      return intervalIntersectionMany(intervalsForEachFragment);\n    });\n  };\n\n  insertFactoryTraceFilterInterval = async ({\n    chainId,\n    factory,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    transactionReceipts: rpcTransactionReceipts,\n    traces: rpcTraces,\n    interval,\n  }: {\n    chainId: number;\n    factory: FactoryCallTraceFilterCriteria;\n    block: SyncBlock;\n    transactions: SyncTransaction[];\n    transactionReceipts: SyncTransactionReceipt[];\n    traces: SyncCallTrace[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    return this.db.wrap(\n      { method: \"insertFactoryTraceFilterInterval\" },\n      async () => {\n        await this.db.transaction().execute(async (tx) => {\n          await tx\n            .insertInto(\"blocks\")\n            .values({\n              ...rpcToSqliteBlock(rpcBlock),\n              chainId,\n              checkpoint: this.createBlockCheckpoint(rpcBlock, chainId),\n            })\n            .onConflict((oc) => oc.column(\"hash\").doNothing())\n            .execute();\n\n          if (rpcTransactions.length > 0) {\n            const transactions = rpcTransactions.map((rpcTransaction) => ({\n              ...rpcToSqliteTransaction(rpcTransaction),\n              chainId,\n            }));\n            await tx\n              .insertInto(\"transactions\")\n              .values(transactions)\n              .onConflict((oc) => oc.column(\"hash\").doNothing())\n              .execute();\n          }\n\n          if (rpcTransactionReceipts.length > 0) {\n            const transactionReceipts = rpcTransactionReceipts.map(\n              (rpcTransactionReceipt) => ({\n                ...rpcToSqliteTransactionReceipt(rpcTransactionReceipt),\n                chainId,\n              }),\n            );\n            await tx\n              .insertInto(\"transactionReceipts\")\n              .values(transactionReceipts)\n              .onConflict((oc) => oc.column(\"transactionHash\").doNothing())\n              .execute();\n          }\n\n          // Delete existing traces with the same `transactionHash`. Then, calculate \"callTraces.checkpoint\"\n          // based on the ordering of \"callTraces.traceAddress\" and add all traces to \"callTraces\" table.\n          const traceByTransactionHash: {\n            [transactionHash: Hex]: SyncCallTrace[];\n          } = {};\n          for (const trace of rpcTraces) {\n            if (traceByTransactionHash[trace.transactionHash] === undefined) {\n              traceByTransactionHash[trace.transactionHash] = [];\n            }\n            traceByTransactionHash[trace.transactionHash]!.push(trace);\n          }\n\n          for (const transactionHash of Object.keys(traceByTransactionHash)) {\n            const traces = await tx\n              .deleteFrom(\"callTraces\")\n              .returningAll()\n              .where(\"transactionHash\", \"=\", transactionHash as Hex)\n              .where(\"chainId\", \"=\", chainId)\n              .execute();\n\n            (traces as Omit<InsertableCallTrace, \"checkpoint\">[]).push(\n              ...traceByTransactionHash[transactionHash as Hex]!.map(\n                (trace) => ({\n                  ...rpcToSqliteTrace(trace),\n                  chainId,\n                }),\n              ),\n            );\n\n            // Use lexographical sort of stringified `traceAddress`.\n            traces.sort((a, b) => {\n              return a.traceAddress < b.traceAddress ? -1 : 1;\n            });\n\n            for (let i = 0; i < traces.length; i++) {\n              const trace = traces[i]!;\n              const checkpoint = encodeCheckpoint({\n                blockTimestamp: hexToNumber(rpcBlock.timestamp),\n                chainId: BigInt(chainId),\n                blockNumber: decodeToBigInt(trace.blockNumber),\n                transactionIndex: BigInt(trace.transactionPosition),\n                eventType: EVENT_TYPES.callTraces,\n                eventIndex: BigInt(i),\n              });\n\n              trace.checkpoint = checkpoint;\n            }\n\n            await tx\n              .insertInto(\"callTraces\")\n              .values(traces)\n              .onConflict((oc) => oc.column(\"id\").doNothing())\n              .execute();\n          }\n\n          await this._insertFactoryTraceFilterInterval({\n            tx,\n            chainId,\n            factoryTraceFilters: [factory],\n            interval,\n          });\n        });\n      },\n    );\n  };\n\n  getFactoryTraceFilterIntervals = async ({\n    chainId,\n    factory,\n  }: {\n    chainId: number;\n    factory: FactoryCallTraceFilterCriteria;\n  }) => {\n    return this.db.wrap(\n      { method: \"getFactoryTraceFilterIntervals\" },\n      async () => {\n        const fragments = buildFactoryTraceFragments({ ...factory, chainId });\n\n        for (const fragment of fragments) {\n          await this.db.transaction().execute(async (tx) => {\n            while (true) {\n              const { id: factoryId } = await tx\n                .insertInto(\"factoryTraceFilters\")\n                .values(fragment)\n                .onConflict((oc) => oc.doUpdateSet(fragment))\n                .returningAll()\n                .executeTakeFirstOrThrow();\n\n              // This is a trick to add a LIMIT to a DELETE statement\n              const existingIntervals = await tx\n                .deleteFrom(\"factoryTraceFilterIntervals\")\n                .where(\n                  \"id\",\n                  \"in\",\n                  tx\n                    .selectFrom(\"factoryTraceFilterIntervals\")\n                    .where(\"factoryId\", \"=\", factoryId)\n                    .select(\"id\")\n                    .limit(this.common.options.syncStoreMaxIntervals),\n                )\n                .returning([\"startBlock\", \"endBlock\"])\n                .execute();\n\n              const mergedIntervals = intervalUnion(\n                existingIntervals.map((i) => [\n                  Number(decodeToBigInt(i.startBlock)),\n                  Number(decodeToBigInt(i.endBlock)),\n                ]),\n              );\n\n              const mergedIntervalRows = mergedIntervals.map(\n                ([startBlock, endBlock]) => ({\n                  factoryId,\n                  startBlock: encodeAsText(startBlock),\n                  endBlock: encodeAsText(endBlock),\n                }),\n              );\n\n              if (mergedIntervalRows.length > 0) {\n                await tx\n                  .insertInto(\"factoryTraceFilterIntervals\")\n                  .values(mergedIntervalRows)\n                  .execute();\n              }\n\n              if (\n                mergedIntervalRows.length ===\n                this.common.options.syncStoreMaxIntervals\n              ) {\n                // This occurs when there are too many non-mergeable ranges with the same factoryId. Should be almost impossible.\n                throw new NonRetryableError(\n                  `'factoryTraceFilterIntervals' table for chain '${chainId}' has reached an unrecoverable level of fragmentation.`,\n                );\n              }\n\n              if (\n                existingIntervals.length !==\n                this.common.options.syncStoreMaxIntervals\n              )\n                break;\n            }\n          });\n        }\n\n        const intervals = await this.db\n          .with(\n            \"factoryFilterFragments(fragmentId, fragmentAddress, fragmentEventSelector, fragmentChildAddressLocation, fragmentFromAddress)\",\n            () =>\n              sql`( values ${sql.join(\n                fragments.map(\n                  (f) =>\n                    sql`( ${sql.val(f.id)}, ${sql.val(f.address)}, ${sql.val(\n                      f.eventSelector,\n                    )}, ${sql.val(f.childAddressLocation)}, ${sql.val(f.fromAddress)} )`,\n                ),\n              )} )`,\n          )\n          .selectFrom(\"factoryTraceFilterIntervals\")\n          .innerJoin(\n            \"factoryTraceFilters\",\n            \"factoryId\",\n            \"factoryTraceFilters.id\",\n          )\n          .innerJoin(\"factoryFilterFragments\", (join) =>\n            join.on((eb) =>\n              eb.and([\n                eb(\"fragmentAddress\", \"=\", sql.ref(\"address\")),\n                eb(\"fragmentEventSelector\", \"=\", sql.ref(\"eventSelector\")),\n                eb(\n                  \"fragmentChildAddressLocation\",\n                  \"=\",\n                  sql.ref(\"childAddressLocation\"),\n                ),\n                eb.or([\n                  eb(\"fromAddress\", \"is\", null),\n                  eb(\"fragmentFromAddress\", \"=\", sql.ref(\"fromAddress\")),\n                ]),\n              ]),\n            ),\n          )\n          .select([\"fragmentId\", \"startBlock\", \"endBlock\"])\n          .where(\"chainId\", \"=\", chainId)\n          .execute();\n\n        const intervalsByFragmentId = intervals.reduce(\n          (acc, cur) => {\n            const { fragmentId, startBlock, endBlock } = cur;\n            (acc[fragmentId] ||= []).push([\n              Number(startBlock),\n              Number(endBlock),\n            ]);\n            return acc;\n          },\n          {} as Record<string, [number, number][]>,\n        );\n\n        const intervalsForEachFragment = fragments.map((f) =>\n          intervalUnion(intervalsByFragmentId[f.id] ?? []),\n        );\n        return intervalIntersectionMany(intervalsForEachFragment);\n      },\n    );\n  };\n\n  insertRealtimeBlock = async ({\n    chainId,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    transactionReceipts: rpcTransactionReceipts,\n    logs: rpcLogs,\n    traces: rpcTraces,\n  }: {\n    chainId: number;\n    block: SyncBlock;\n    transactions: SyncTransaction[];\n    transactionReceipts: SyncTransactionReceipt[];\n    logs: SyncLog[];\n    traces: SyncCallTrace[];\n  }) => {\n    return this.db.wrap({ method: \"insertRealtimeBlock\" }, async () => {\n      await this.db.transaction().execute(async (tx) => {\n        await tx\n          .insertInto(\"blocks\")\n          .values({\n            ...rpcToSqliteBlock(rpcBlock),\n            chainId,\n            checkpoint: this.createBlockCheckpoint(rpcBlock, chainId),\n          })\n          .onConflict((oc) => oc.column(\"hash\").doNothing())\n          .execute();\n\n        if (rpcTransactions.length > 0) {\n          const transactions = rpcTransactions.map((rpcTransaction) => ({\n            ...rpcToSqliteTransaction(rpcTransaction),\n            chainId,\n          }));\n          await tx\n            .insertInto(\"transactions\")\n            .values(transactions)\n            .onConflict((oc) =>\n              oc.column(\"hash\").doUpdateSet((eb) => ({\n                blockHash: eb.ref(\"excluded.blockHash\"),\n                blockNumber: eb.ref(\"excluded.blockNumber\"),\n                transactionIndex: eb.ref(\"excluded.transactionIndex\"),\n              })),\n            )\n            .execute();\n        }\n\n        if (rpcTransactionReceipts.length > 0) {\n          const transactionReceipts = rpcTransactionReceipts.map(\n            (rpcTransactionReceipt) => ({\n              ...rpcToSqliteTransactionReceipt(rpcTransactionReceipt),\n              chainId,\n            }),\n          );\n          await tx\n            .insertInto(\"transactionReceipts\")\n            .values(transactionReceipts)\n            .onConflict((oc) =>\n              oc.column(\"transactionHash\").doUpdateSet((eb) => ({\n                blockHash: eb.ref(\"excluded.blockHash\"),\n                blockNumber: eb.ref(\"excluded.blockNumber\"),\n                contractAddress: eb.ref(\"excluded.contractAddress\"),\n                cumulativeGasUsed: eb.ref(\"excluded.cumulativeGasUsed\"),\n                effectiveGasPrice: eb.ref(\"excluded.effectiveGasPrice\"),\n                gasUsed: eb.ref(\"excluded.gasUsed\"),\n                logs: eb.ref(\"excluded.logs\"),\n                logsBloom: eb.ref(\"excluded.logsBloom\"),\n                transactionIndex: eb.ref(\"excluded.transactionIndex\"),\n              })),\n            )\n            .execute();\n        }\n\n        if (rpcLogs.length > 0) {\n          const logs = rpcLogs.map((rpcLog) => ({\n            ...rpcToSqliteLog(rpcLog),\n            chainId,\n            checkpoint: this.createLogCheckpoint(rpcLog, rpcBlock, chainId),\n          }));\n          await tx\n            .insertInto(\"logs\")\n            .values(logs)\n            .onConflict((oc) =>\n              oc.column(\"id\").doUpdateSet((eb) => ({\n                checkpoint: eb.ref(\"excluded.checkpoint\"),\n              })),\n            )\n            .execute();\n        }\n\n        if (rpcTraces.length > 0) {\n          const traces = rpcTraces\n            .map((trace, i) => ({\n              ...rpcToSqliteTrace(trace),\n              chainId,\n              checkpoint: encodeCheckpoint({\n                blockTimestamp: hexToNumber(rpcBlock.timestamp),\n                chainId: BigInt(chainId),\n                blockNumber: hexToBigInt(trace.blockNumber),\n                transactionIndex: BigInt(trace.transactionPosition),\n                eventType: EVENT_TYPES.callTraces,\n                eventIndex: BigInt(i),\n              }),\n            }))\n            .sort((a, b) => {\n              if (a.transactionHash < b.transactionHash) return -1;\n              if (a.transactionHash > b.transactionHash) return 1;\n              return a.traceAddress < b.traceAddress ? -1 : 1;\n            });\n\n          await tx\n            .insertInto(\"callTraces\")\n            .values(traces)\n            .onConflict((oc) => oc.column(\"id\").doNothing())\n            .execute();\n        }\n      });\n    });\n  };\n\n  private createLogCheckpoint = (\n    log: SyncLog,\n    block: SyncBlock,\n    chainId: number,\n  ) => {\n    return encodeCheckpoint({\n      blockTimestamp: Number(BigInt(block.timestamp)),\n      chainId: BigInt(chainId),\n      blockNumber: hexToBigInt(block.number),\n      transactionIndex: hexToBigInt(log.transactionIndex),\n      eventType: EVENT_TYPES.logs,\n      eventIndex: hexToBigInt(log.logIndex),\n    });\n  };\n\n  private createBlockCheckpoint = (block: SyncBlock, chainId: number) => {\n    return encodeCheckpoint({\n      blockTimestamp: hexToNumber(block.timestamp),\n      chainId: BigInt(chainId),\n      blockNumber: hexToBigInt(block.number),\n      transactionIndex: maxCheckpoint.transactionIndex,\n      eventType: EVENT_TYPES.blocks,\n      eventIndex: zeroCheckpoint.eventIndex,\n    });\n  };\n\n  insertRealtimeInterval = async ({\n    chainId,\n    logFilters,\n    factoryLogFilters,\n    traceFilters,\n    factoryTraceFilters,\n    blockFilters,\n    interval,\n  }: {\n    chainId: number;\n    logFilters: LogFilterCriteria[];\n    factoryLogFilters: FactoryLogFilterCriteria[];\n    traceFilters: CallTraceFilterCriteria[];\n    factoryTraceFilters: FactoryCallTraceFilterCriteria[];\n    blockFilters: BlockFilterCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    return this.db.wrap({ method: \"insertRealtimeInterval\" }, async () => {\n      await this.db.transaction().execute(async (tx) => {\n        await this._insertLogFilterInterval({\n          tx,\n          chainId,\n          logFilters: [\n            ...logFilters,\n            ...factoryLogFilters.map((f) => ({\n              address: f.address,\n              topics: [f.eventSelector],\n              includeTransactionReceipts: f.includeTransactionReceipts,\n            })),\n            ...factoryTraceFilters.map((f) => ({\n              address: f.address,\n              topics: [f.eventSelector],\n              includeTransactionReceipts: f.includeTransactionReceipts,\n            })),\n          ],\n          interval,\n        });\n\n        await this._insertFactoryLogFilterInterval({\n          tx,\n          chainId,\n          factoryLogFilters,\n          interval,\n        });\n\n        await this._insertBlockFilterInterval({\n          tx,\n          chainId,\n          blockFilters,\n          interval,\n        });\n\n        await this._insertTraceFilterInterval({\n          tx,\n          chainId,\n          traceFilters,\n          interval,\n        });\n\n        await this._insertFactoryTraceFilterInterval({\n          tx,\n          chainId,\n          factoryTraceFilters,\n          interval,\n        });\n      });\n    });\n  };\n\n  deleteRealtimeData = async ({\n    chainId,\n    fromBlock: fromBlock_,\n  }: {\n    chainId: number;\n    fromBlock: bigint;\n  }) => {\n    return this.db.wrap({ method: \"deleteRealtimeData\" }, async () => {\n      await this.db.transaction().execute(async (tx) => {\n        const fromBlock = encodeAsText(fromBlock_);\n\n        await tx\n          .deleteFrom(\"logs\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"blockNumber\", \">\", fromBlock)\n          .execute();\n        await tx\n          .deleteFrom(\"blocks\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"number\", \">\", fromBlock)\n          .execute();\n        await tx\n          .deleteFrom(\"rpcRequestResults\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"blockNumber\", \">\", fromBlock)\n          .execute();\n        await tx\n          .deleteFrom(\"callTraces\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"blockNumber\", \">\", fromBlock)\n          .execute();\n      });\n    });\n  };\n\n  /** SYNC HELPER METHODS */\n\n  private _insertLogFilterInterval = async ({\n    tx,\n    chainId,\n    logFilters,\n    interval: { startBlock, endBlock },\n  }: {\n    tx: KyselyTransaction<SyncStoreTables>;\n    chainId: number;\n    logFilters: LogFilterCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const logFilterFragments = logFilters.flatMap((logFilter) =>\n      buildLogFilterFragments({ ...logFilter, chainId }),\n    );\n\n    await Promise.all(\n      logFilterFragments.map(async (logFilterFragment) => {\n        const { id: logFilterId } = await tx\n          .insertInto(\"logFilters\")\n          .values(logFilterFragment)\n          .onConflict((oc) => oc.doUpdateSet(logFilterFragment))\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        await tx\n          .insertInto(\"logFilterIntervals\")\n          .values({\n            logFilterId,\n            startBlock: encodeAsText(startBlock),\n            endBlock: encodeAsText(endBlock),\n          })\n          .execute();\n      }),\n    );\n  };\n\n  private _insertFactoryLogFilterInterval = async ({\n    tx,\n    chainId,\n    factoryLogFilters,\n    interval: { startBlock, endBlock },\n  }: {\n    tx: KyselyTransaction<SyncStoreTables>;\n    chainId: number;\n    factoryLogFilters: FactoryLogFilterCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const factoryFragments = factoryLogFilters.flatMap((factory) =>\n      buildFactoryLogFragments({ ...factory, chainId }),\n    );\n\n    await Promise.all(\n      factoryFragments.map(async (fragment) => {\n        const { id: factoryId } = await tx\n          .insertInto(\"factoryLogFilters\")\n          .values(fragment)\n          .onConflict((oc) => oc.doUpdateSet(fragment))\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        await tx\n          .insertInto(\"factoryLogFilterIntervals\")\n          .values({\n            factoryId,\n            startBlock: encodeAsText(startBlock),\n            endBlock: encodeAsText(endBlock),\n          })\n          .execute();\n      }),\n    );\n  };\n\n  private _insertBlockFilterInterval = async ({\n    tx,\n    chainId,\n    blockFilters,\n    interval: { startBlock, endBlock },\n  }: {\n    tx: KyselyTransaction<SyncStoreTables>;\n    chainId: number;\n    blockFilters: BlockFilterCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const blockFilterFragments = blockFilters.flatMap((blockFilter) => {\n      return {\n        id: `${chainId}_${blockFilter.interval}_${blockFilter.offset}`,\n        chainId,\n        interval: blockFilter.interval,\n        offset: blockFilter.offset,\n      };\n    });\n\n    await Promise.all(\n      blockFilterFragments.map(async (blockFilterFragment) => {\n        const { id: blockFilterId } = await tx\n          .insertInto(\"blockFilters\")\n          .values(blockFilterFragment)\n          .onConflict((oc) => oc.doUpdateSet(blockFilterFragment))\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        await tx\n          .insertInto(\"blockFilterIntervals\")\n          .values({\n            blockFilterId,\n            startBlock: encodeAsText(startBlock),\n            endBlock: encodeAsText(endBlock),\n          })\n          .execute();\n      }),\n    );\n  };\n\n  private _insertTraceFilterInterval = async ({\n    tx,\n    chainId,\n    traceFilters,\n    interval: { startBlock, endBlock },\n  }: {\n    tx: KyselyTransaction<SyncStoreTables>;\n    chainId: number;\n    traceFilters: CallTraceFilterCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const traceFilterFragments = traceFilters.flatMap((traceFilter) =>\n      buildTraceFragments({ ...traceFilter, chainId }),\n    );\n\n    await Promise.all(\n      traceFilterFragments.map(async (traceFilterFragment) => {\n        const { id: traceFilterId } = await tx\n          .insertInto(\"traceFilters\")\n          .values(traceFilterFragment)\n          .onConflict((oc) => oc.column(\"id\").doUpdateSet(traceFilterFragment))\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        await tx\n          .insertInto(\"traceFilterIntervals\")\n          .values({\n            traceFilterId,\n            startBlock: encodeAsText(startBlock),\n            endBlock: encodeAsText(endBlock),\n          })\n          .execute();\n      }),\n    );\n  };\n\n  private _insertFactoryTraceFilterInterval = async ({\n    tx,\n    chainId,\n    factoryTraceFilters,\n    interval: { startBlock, endBlock },\n  }: {\n    tx: KyselyTransaction<SyncStoreTables>;\n    chainId: number;\n    factoryTraceFilters: FactoryCallTraceFilterCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const factoryFragments = factoryTraceFilters.flatMap((factory) =>\n      buildFactoryTraceFragments({ ...factory, chainId }),\n    );\n\n    await Promise.all(\n      factoryFragments.map(async (fragment) => {\n        const { id: factoryId } = await tx\n          .insertInto(\"factoryTraceFilters\")\n          .values(fragment)\n          .onConflict((oc) => oc.column(\"id\").doUpdateSet(fragment))\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        await tx\n          .insertInto(\"factoryTraceFilterIntervals\")\n          .values({\n            factoryId,\n            startBlock: encodeAsText(startBlock),\n            endBlock: encodeAsText(endBlock),\n          })\n          .execute();\n      }),\n    );\n  };\n\n  /** CONTRACT READS */\n\n  insertRpcRequestResult = async ({\n    blockNumber,\n    chainId,\n    request,\n    result,\n  }: {\n    blockNumber: bigint;\n    chainId: number;\n    request: string;\n    result: string;\n  }) => {\n    return this.db.wrap({ method: \"insertRpcRequestResult\" }, async () => {\n      await this.db\n        .insertInto(\"rpcRequestResults\")\n        .values({\n          request,\n          blockNumber: encodeAsText(blockNumber),\n          chainId,\n          result,\n        })\n        .onConflict((oc) => oc.doUpdateSet({ result }))\n        .execute();\n    });\n  };\n\n  getRpcRequestResult = async ({\n    blockNumber,\n    chainId,\n    request,\n  }: {\n    blockNumber: bigint;\n    chainId: number;\n    request: string;\n  }) => {\n    return this.db.wrap({ method: \"getRpcRequestResult\" }, async () => {\n      const rpcRequestResult = await this.db\n        .selectFrom(\"rpcRequestResults\")\n        .selectAll()\n        .where(\"blockNumber\", \"=\", encodeAsText(blockNumber))\n        .where(\"chainId\", \"=\", chainId)\n        .where(\"request\", \"=\", request)\n        .executeTakeFirst();\n\n      return rpcRequestResult\n        ? {\n            ...rpcRequestResult,\n            blockNumber: decodeToBigInt(rpcRequestResult.blockNumber),\n          }\n        : null;\n    });\n  };\n\n  async *getEvents({\n    sources,\n    fromCheckpoint,\n    toCheckpoint,\n  }: {\n    sources: EventSource[];\n    fromCheckpoint: Checkpoint;\n    toCheckpoint: Checkpoint;\n  }) {\n    let fromCursor = encodeCheckpoint(fromCheckpoint);\n    let toCursor = encodeCheckpoint(toCheckpoint);\n    const maxToCursor = toCursor;\n\n    const sourcesById = sources.reduce<{\n      [sourceId: string]: (typeof sources)[number];\n    }>((acc, cur) => {\n      acc[cur.id] = cur;\n      return acc;\n    }, {});\n\n    // We can assume that source won't be empty.\n    const logSources = sources.filter(\n      (s): s is LogSource | FactoryLogSource =>\n        sourceIsLog(s) || sourceIsFactoryLog(s),\n    );\n    const callTraceSources = sources.filter(\n      (s): s is CallTraceSource | FactoryCallTraceSource =>\n        sourceIsCallTrace(s) || sourceIsFactoryCallTrace(s),\n    );\n    const blockSources = sources.filter(sourceIsBlock);\n\n    const shouldJoinLogs = logSources.length !== 0;\n    const shouldJoinTransactions =\n      logSources.length !== 0 || callTraceSources.length !== 0;\n    const shouldJoinTraces = callTraceSources.length !== 0;\n    const shouldJoinReceipts =\n      logSources.some((source) => source.criteria.includeTransactionReceipts) ||\n      callTraceSources.some(\n        (source) => source.criteria.includeTransactionReceipts,\n      );\n\n    while (true) {\n      const estimatedToCursor = encodeCheckpoint({\n        ...zeroCheckpoint,\n        blockTimestamp: Math.min(\n          decodeCheckpoint(fromCursor).blockTimestamp + this.seconds,\n          maxCheckpoint.blockTimestamp,\n        ),\n      });\n      toCursor =\n        estimatedToCursor > maxToCursor ? maxToCursor : estimatedToCursor;\n\n      const events = await this.db.wrap({ method: \"getEvents\" }, async () => {\n        // Query a batch of logs.\n        const requestedLogs = await this.db\n          .with(\n            \"log_sources(source_id)\",\n            () =>\n              sql`( values ${\n                logSources.length === 0\n                  ? sql`( null )`\n                  : sql.join(\n                      logSources.map(\n                        (source) => sql`( ${sql.val(source.id)} )`,\n                      ),\n                    )\n              } )`,\n          )\n          .with(\n            \"block_sources(source_id)\",\n            () =>\n              sql`( values ${\n                blockSources.length === 0\n                  ? sql`( null )`\n                  : sql.join(\n                      blockSources.map(\n                        (source) => sql`( ${sql.val(source.id)} )`,\n                      ),\n                    )\n              } )`,\n          )\n          .with(\n            \"call_traces_sources(source_id)\",\n            () =>\n              sql`( values ${\n                callTraceSources.length === 0\n                  ? sql`( null )`\n                  : sql.join(\n                      callTraceSources.map(\n                        (source) => sql`( ${sql.val(source.id)} )`,\n                      ),\n                    )\n              } )`,\n          )\n          .with(\"events\", (db) =>\n            db\n              .selectFrom(\"logs\")\n              .innerJoin(\"log_sources\", (join) => join.onTrue())\n              .where((eb) => {\n                const logFilterCmprs = sources\n                  .filter(sourceIsLog)\n                  .map((logFilter) => {\n                    const exprs = this.buildLogFilterCmprs({ eb, logFilter });\n                    exprs.push(eb(\"source_id\", \"=\", logFilter.id));\n                    return eb.and(exprs);\n                  });\n\n                const factoryCmprs = sources\n                  .filter(sourceIsFactoryLog)\n                  .map((factory) => {\n                    const exprs = this.buildFactoryLogFilterCmprs({\n                      eb,\n                      factory,\n                    });\n                    exprs.push(eb(\"source_id\", \"=\", factory.id));\n                    return eb.and(exprs);\n                  });\n\n                return eb.or([...logFilterCmprs, ...factoryCmprs]);\n              })\n              .select([\n                \"source_id\",\n                \"checkpoint\",\n                \"blockHash\",\n                \"transactionHash\",\n\n                \"logs.id as log_id\",\n                sql`null`.as(\"callTrace_id\"),\n              ])\n              .unionAll(\n                // @ts-ignore\n                db\n                  .selectFrom(\"blocks\")\n                  .innerJoin(\"block_sources\", (join) => join.onTrue())\n                  .where((eb) => {\n                    const exprs = [];\n                    const blockFilters = sources.filter(sourceIsBlock);\n                    for (const blockFilter of blockFilters) {\n                      exprs.push(\n                        eb.and([\n                          eb(\"chainId\", \"=\", blockFilter.chainId),\n                          eb(\n                            \"number\",\n                            \">=\",\n                            encodeAsText(blockFilter.startBlock),\n                          ),\n                          ...(blockFilter.endBlock !== undefined\n                            ? [\n                                eb(\n                                  \"number\",\n                                  \"<=\",\n                                  encodeAsText(blockFilter.endBlock),\n                                ),\n                              ]\n                            : []),\n                          sql`(number - ${blockFilter.criteria.offset}) % ${blockFilter.criteria.interval} = 0`,\n                          eb(\"source_id\", \"=\", blockFilter.id),\n                        ]),\n                      );\n                    }\n                    return eb.or(exprs);\n                  })\n                  .select([\n                    \"block_sources.source_id\",\n                    \"checkpoint\",\n                    \"hash as blockHash\",\n                    sql`null`.as(\"transactionHash\"),\n\n                    sql`null`.as(\"log_id\"),\n                    sql`null`.as(\"callTrace_id\"),\n                  ]),\n              )\n              .unionAll(\n                // @ts-ignore\n                db\n                  .selectFrom(\"callTraces\")\n                  .innerJoin(\"call_traces_sources\", (join) => join.onTrue())\n                  .where((eb) => {\n                    const traceFilterCmprs = sources\n                      .filter(sourceIsCallTrace)\n                      .map((callTraceSource) => {\n                        const exprs = this.buildTraceFilterCmprs({\n                          eb,\n                          callTraceSource,\n                        });\n                        exprs.push(eb(\"source_id\", \"=\", callTraceSource.id));\n                        return eb.and(exprs);\n                      });\n                    const factoryTraceFilterCmprs = sources\n                      .filter(sourceIsFactoryCallTrace)\n                      .map((factory) => {\n                        const exprs = this.buildFactoryTraceFilterCmprs({\n                          eb,\n                          factory,\n                        });\n                        exprs.push(eb(\"source_id\", \"=\", factory.id));\n                        return eb.and(exprs);\n                      });\n\n                    return eb.or([\n                      ...traceFilterCmprs,\n                      ...factoryTraceFilterCmprs,\n                    ]);\n                  })\n                  .select([\n                    \"source_id\",\n                    \"checkpoint\",\n                    \"blockHash\",\n                    \"transactionHash\",\n\n                    sql`null`.as(\"log_id\"),\n                    \"callTraces.id as callTrace_id\",\n                  ]),\n              ),\n          )\n          .selectFrom(\"events\")\n          .innerJoin(\"blocks\", \"blocks.hash\", \"events.blockHash\")\n          .select([\n            \"events.source_id\",\n            \"events.checkpoint\",\n\n            \"blocks.baseFeePerGas as block_baseFeePerGas\",\n            \"blocks.difficulty as block_difficulty\",\n            \"blocks.extraData as block_extraData\",\n            \"blocks.gasLimit as block_gasLimit\",\n            \"blocks.gasUsed as block_gasUsed\",\n            \"blocks.hash as block_hash\",\n            \"blocks.logsBloom as block_logsBloom\",\n            \"blocks.miner as block_miner\",\n            \"blocks.mixHash as block_mixHash\",\n            \"blocks.nonce as block_nonce\",\n            \"blocks.number as block_number\",\n            \"blocks.parentHash as block_parentHash\",\n            \"blocks.receiptsRoot as block_receiptsRoot\",\n            \"blocks.sha3Uncles as block_sha3Uncles\",\n            \"blocks.size as block_size\",\n            \"blocks.stateRoot as block_stateRoot\",\n            \"blocks.timestamp as block_timestamp\",\n            \"blocks.totalDifficulty as block_totalDifficulty\",\n            \"blocks.transactionsRoot as block_transactionsRoot\",\n          ])\n          .$if(shouldJoinLogs, (qb) =>\n            qb\n              .leftJoin(\"logs\", \"logs.id\", \"events.log_id\")\n              .select([\n                \"logs.address as log_address\",\n                \"logs.blockHash as log_blockHash\",\n                \"logs.blockNumber as log_blockNumber\",\n                \"logs.chainId as log_chainId\",\n                \"logs.data as log_data\",\n                \"logs.id as log_id\",\n                \"logs.logIndex as log_logIndex\",\n                \"logs.topic0 as log_topic0\",\n                \"logs.topic1 as log_topic1\",\n                \"logs.topic2 as log_topic2\",\n                \"logs.topic3 as log_topic3\",\n                \"logs.transactionHash as log_transactionHash\",\n                \"logs.transactionIndex as log_transactionIndex\",\n              ]),\n          )\n          .$if(shouldJoinTransactions, (qb) =>\n            qb\n              .leftJoin(\n                \"transactions\",\n                \"transactions.hash\",\n                \"events.transactionHash\",\n              )\n              .select([\n                \"transactions.accessList as tx_accessList\",\n                \"transactions.blockHash as tx_blockHash\",\n                \"transactions.blockNumber as tx_blockNumber\",\n                \"transactions.from as tx_from\",\n                \"transactions.gas as tx_gas\",\n                \"transactions.gasPrice as tx_gasPrice\",\n                \"transactions.hash as tx_hash\",\n                \"transactions.input as tx_input\",\n                \"transactions.maxFeePerGas as tx_maxFeePerGas\",\n                \"transactions.maxPriorityFeePerGas as tx_maxPriorityFeePerGas\",\n                \"transactions.nonce as tx_nonce\",\n                \"transactions.r as tx_r\",\n                \"transactions.s as tx_s\",\n                \"transactions.to as tx_to\",\n                \"transactions.transactionIndex as tx_transactionIndex\",\n                \"transactions.type as tx_type\",\n                \"transactions.value as tx_value\",\n                \"transactions.v as tx_v\",\n              ]),\n          )\n          .$if(shouldJoinTraces, (qb) =>\n            qb\n              .leftJoin(\"callTraces\", \"callTraces.id\", \"events.callTrace_id\")\n              .select([\n                \"callTraces.id as callTrace_id\",\n                \"callTraces.callType as callTrace_callType\",\n                \"callTraces.from as callTrace_from\",\n                \"callTraces.gas as callTrace_gas\",\n                \"callTraces.input as callTrace_input\",\n                \"callTraces.to as callTrace_to\",\n                \"callTraces.value as callTrace_value\",\n                \"callTraces.blockHash as callTrace_blockHash\",\n                \"callTraces.blockNumber as callTrace_blockNumber\",\n                \"callTraces.gasUsed as callTrace_gasUsed\",\n                \"callTraces.output as callTrace_output\",\n                \"callTraces.subtraces as callTrace_subtraces\",\n                \"callTraces.traceAddress as callTrace_traceAddress\",\n                \"callTraces.transactionHash as callTrace_transactionHash\",\n                \"callTraces.transactionPosition as callTrace_transactionPosition\",\n                \"callTraces.chainId as callTrace_chainId\",\n                \"callTraces.checkpoint as callTrace_checkpoint\",\n              ]),\n          )\n          .$if(shouldJoinReceipts, (qb) =>\n            qb\n              .leftJoin(\n                \"transactionReceipts\",\n                \"transactionReceipts.transactionHash\",\n                \"events.transactionHash\",\n              )\n              .select([\n                \"transactionReceipts.blockHash as txr_blockHash\",\n                \"transactionReceipts.blockNumber as txr_blockNumber\",\n                \"transactionReceipts.contractAddress as txr_contractAddress\",\n                \"transactionReceipts.cumulativeGasUsed as txr_cumulativeGasUsed\",\n                \"transactionReceipts.effectiveGasPrice as txr_effectiveGasPrice\",\n                \"transactionReceipts.from as txr_from\",\n                \"transactionReceipts.gasUsed as txr_gasUsed\",\n                \"transactionReceipts.logs as txr_logs\",\n                \"transactionReceipts.logsBloom as txr_logsBloom\",\n                \"transactionReceipts.status as txr_status\",\n                \"transactionReceipts.to as txr_to\",\n                \"transactionReceipts.transactionHash as txr_transactionHash\",\n                \"transactionReceipts.transactionIndex as txr_transactionIndex\",\n                \"transactionReceipts.type as txr_type\",\n              ]),\n          )\n          .where(\"events.checkpoint\", \">\", fromCursor)\n          .where(\"events.checkpoint\", \"<=\", toCursor)\n          .orderBy(\"events.checkpoint\", \"asc\")\n          .limit(this.common.options.syncEventsQuerySize)\n          .execute();\n\n        return requestedLogs.map((_row) => {\n          // Without this cast, the block_ and tx_ fields are all nullable\n          // which makes this very annoying. Should probably add a runtime check\n          // that those fields are indeed present before continuing here.\n          const row = _row as NonNull<(typeof requestedLogs)[number]>;\n\n          const source = sourcesById[row.source_id]!;\n\n          const shouldIncludeLog =\n            sourceIsLog(source) || sourceIsFactoryLog(source);\n          const shouldIncludeTransaction =\n            sourceIsLog(source) ||\n            sourceIsFactoryLog(source) ||\n            sourceIsCallTrace(source) ||\n            sourceIsFactoryCallTrace(source);\n          const shouldIncludeTrace =\n            sourceIsCallTrace(source) || sourceIsFactoryCallTrace(source);\n          const shouldIncludeTransactionReceipt =\n            (sourceIsLog(source) &&\n              source.criteria.includeTransactionReceipts) ||\n            (sourceIsFactoryLog(source) &&\n              source.criteria.includeTransactionReceipts);\n          return {\n            chainId: source.chainId,\n            sourceId: row.source_id,\n            encodedCheckpoint: row.checkpoint,\n            log: shouldIncludeLog\n              ? {\n                  address: checksumAddress(row.log_address),\n                  blockHash: row.log_blockHash,\n                  blockNumber: decodeToBigInt(row.log_blockNumber),\n                  data: row.log_data,\n                  id: row.log_id as Log[\"id\"],\n                  logIndex: Number(row.log_logIndex),\n                  removed: false,\n                  topics: [\n                    row.log_topic0,\n                    row.log_topic1,\n                    row.log_topic2,\n                    row.log_topic3,\n                  ].filter((t): t is Hex => t !== null) as [Hex, ...Hex[]] | [],\n                  transactionHash: row.log_transactionHash,\n                  transactionIndex: Number(row.log_transactionIndex),\n                }\n              : undefined,\n            block: {\n              baseFeePerGas: row.block_baseFeePerGas\n                ? decodeToBigInt(row.block_baseFeePerGas)\n                : null,\n              difficulty: decodeToBigInt(row.block_difficulty),\n              extraData: row.block_extraData,\n              gasLimit: decodeToBigInt(row.block_gasLimit),\n              gasUsed: decodeToBigInt(row.block_gasUsed),\n              hash: row.block_hash,\n              logsBloom: row.block_logsBloom,\n              miner: checksumAddress(row.block_miner),\n              mixHash: row.block_mixHash,\n              nonce: row.block_nonce,\n              number: decodeToBigInt(row.block_number),\n              parentHash: row.block_parentHash,\n              receiptsRoot: row.block_receiptsRoot,\n              sha3Uncles: row.block_sha3Uncles,\n              size: decodeToBigInt(row.block_size),\n              stateRoot: row.block_stateRoot,\n              timestamp: decodeToBigInt(row.block_timestamp),\n              totalDifficulty: row.block_totalDifficulty\n                ? decodeToBigInt(row.block_totalDifficulty)\n                : null,\n              transactionsRoot: row.block_transactionsRoot,\n            },\n            transaction: shouldIncludeTransaction\n              ? {\n                  blockHash: row.tx_blockHash,\n                  blockNumber: decodeToBigInt(row.tx_blockNumber),\n                  from: checksumAddress(row.tx_from),\n                  gas: decodeToBigInt(row.tx_gas),\n                  hash: row.tx_hash,\n                  input: row.tx_input,\n                  nonce: Number(row.tx_nonce),\n                  r: row.tx_r,\n                  s: row.tx_s,\n                  to: row.tx_to ? checksumAddress(row.tx_to) : row.tx_to,\n                  transactionIndex: Number(row.tx_transactionIndex),\n                  value: decodeToBigInt(row.tx_value),\n                  v: row.tx_v ? decodeToBigInt(row.tx_v) : null,\n                  ...(row.tx_type === \"0x0\"\n                    ? {\n                        type: \"legacy\",\n                        gasPrice: decodeToBigInt(row.tx_gasPrice),\n                      }\n                    : row.tx_type === \"0x1\"\n                      ? {\n                          type: \"eip2930\",\n                          gasPrice: decodeToBigInt(row.tx_gasPrice),\n                          accessList: JSON.parse(row.tx_accessList),\n                        }\n                      : row.tx_type === \"0x2\"\n                        ? {\n                            type: \"eip1559\",\n                            maxFeePerGas: decodeToBigInt(row.tx_maxFeePerGas),\n                            maxPriorityFeePerGas: decodeToBigInt(\n                              row.tx_maxPriorityFeePerGas,\n                            ),\n                          }\n                        : row.tx_type === \"0x7e\"\n                          ? {\n                              type: \"deposit\",\n                              maxFeePerGas: row.tx_maxFeePerGas\n                                ? decodeToBigInt(row.tx_maxFeePerGas)\n                                : undefined,\n                              maxPriorityFeePerGas: row.tx_maxPriorityFeePerGas\n                                ? decodeToBigInt(row.tx_maxPriorityFeePerGas)\n                                : undefined,\n                            }\n                          : {\n                              type: row.tx_type,\n                            }),\n                }\n              : undefined,\n            trace: shouldIncludeTrace\n              ? {\n                  id: row.callTrace_id,\n                  from: checksumAddress(row.callTrace_from),\n                  to: checksumAddress(row.callTrace_to),\n                  gas: decodeToBigInt(row.callTrace_gas),\n                  value: decodeToBigInt(row.callTrace_value),\n                  input: row.callTrace_input,\n                  output: row.callTrace_output,\n                  gasUsed: decodeToBigInt(row.callTrace_gasUsed),\n                  subtraces: row.callTrace_subtraces,\n                  traceAddress: JSON.parse(row.callTrace_traceAddress),\n                  blockHash: row.callTrace_blockHash,\n                  blockNumber: decodeToBigInt(row.callTrace_blockNumber),\n                  transactionHash: row.callTrace_transactionHash,\n                  transactionIndex: row.callTrace_transactionPosition,\n                  callType: row.callTrace_callType as CallTrace[\"callType\"],\n                }\n              : undefined,\n            transactionReceipt: shouldIncludeTransactionReceipt\n              ? {\n                  blockHash: row.txr_blockHash,\n                  blockNumber: decodeToBigInt(row.txr_blockNumber),\n                  contractAddress: row.txr_contractAddress\n                    ? checksumAddress(row.txr_contractAddress)\n                    : null,\n                  cumulativeGasUsed: decodeToBigInt(row.txr_cumulativeGasUsed),\n                  effectiveGasPrice: decodeToBigInt(row.txr_effectiveGasPrice),\n                  from: checksumAddress(row.txr_from),\n                  gasUsed: decodeToBigInt(row.txr_gasUsed),\n                  logs: JSON.parse(row.txr_logs).map((log: SyncLog) => ({\n                    address: checksumAddress(log.address),\n                    blockHash: log.blockHash,\n                    blockNumber: hexToBigInt(log.blockNumber),\n                    data: log.data,\n                    logIndex: hexToNumber(log.logIndex),\n                    removed: false,\n                    topics: [\n                      log.topics[0] ?? null,\n                      log.topics[1] ?? null,\n                      log.topics[2] ?? null,\n                      log.topics[3] ?? null,\n                    ].filter((t): t is Hex => t !== null) as\n                      | [Hex, ...Hex[]]\n                      | [],\n                    transactionHash: log.transactionHash,\n                    transactionIndex: hexToNumber(log.transactionIndex),\n                  })),\n                  logsBloom: row.txr_logsBloom,\n                  status:\n                    row.txr_status === \"0x1\"\n                      ? \"success\"\n                      : row.txr_status === \"0x0\"\n                        ? \"reverted\"\n                        : (row.txr_status as TransactionReceipt[\"status\"]),\n                  to: row.txr_to ? checksumAddress(row.txr_to) : null,\n                  transactionHash: row.txr_transactionHash,\n                  transactionIndex: Number(row.txr_transactionIndex),\n                  type:\n                    row.txr_type === \"0x0\"\n                      ? \"legacy\"\n                      : row.txr_type === \"0x1\"\n                        ? \"eip2930\"\n                        : row.tx_type === \"0x2\"\n                          ? \"eip1559\"\n                          : row.tx_type === \"0x7e\"\n                            ? \"deposit\"\n                            : row.tx_type,\n                }\n              : undefined,\n          } satisfies RawEvent;\n        });\n      });\n\n      // set fromCursor + seconds\n      if (events.length === 0) {\n        this.seconds = Math.round(this.seconds * 2);\n        fromCursor = toCursor;\n      } else if (events.length === this.common.options.syncEventsQuerySize) {\n        this.seconds = Math.round(this.seconds / 2);\n        fromCursor = events[events.length - 1]!.encodedCheckpoint;\n      } else {\n        this.seconds = Math.round(\n          Math.min(\n            (this.seconds / events.length) *\n              this.common.options.syncEventsQuerySize *\n              0.9,\n            this.seconds * 2,\n          ),\n        );\n        fromCursor = toCursor;\n      }\n\n      if (events.length > 0) yield events;\n\n      // exit condition\n      if (\n        events.length !== this.common.options.syncEventsQuerySize &&\n        toCursor === maxToCursor\n      ) {\n        break;\n      }\n    }\n  }\n\n  private buildLogFilterCmprs = ({\n    eb,\n    logFilter,\n  }: {\n    eb: ExpressionBuilder<any, any>;\n    logFilter: LogSource;\n  }) => {\n    const exprs = [];\n\n    exprs.push(eb(\"logs.chainId\", \"=\", logFilter.chainId));\n\n    if (logFilter.criteria.address) {\n      // If it's an array of length 1, collapse it.\n      const address =\n        Array.isArray(logFilter.criteria.address) &&\n        logFilter.criteria.address.length === 1\n          ? logFilter.criteria.address[0]\n          : logFilter.criteria.address;\n      if (Array.isArray(address)) {\n        exprs.push(eb.or(address.map((a) => eb(\"logs.address\", \"=\", a))));\n      } else {\n        exprs.push(eb(\"logs.address\", \"=\", address));\n      }\n    }\n\n    if (logFilter.criteria.topics) {\n      for (const idx_ of range(0, 4)) {\n        const idx = idx_ as 0 | 1 | 2 | 3;\n        // If it's an array of length 1, collapse it.\n        const raw = logFilter.criteria.topics[idx] ?? null;\n        if (raw === null) continue;\n        const topic = Array.isArray(raw) && raw.length === 1 ? raw[0] : raw;\n        if (Array.isArray(topic)) {\n          exprs.push(eb.or(topic.map((a) => eb(`logs.topic${idx}`, \"=\", a))));\n        } else {\n          exprs.push(eb(`logs.topic${idx}`, \"=\", topic));\n        }\n      }\n    }\n\n    if (logFilter.startBlock !== undefined && logFilter.startBlock !== 0)\n      exprs.push(\n        eb(\"logs.blockNumber\", \">=\", encodeAsText(logFilter.startBlock)),\n      );\n    if (logFilter.endBlock)\n      exprs.push(\n        eb(\"logs.blockNumber\", \"<=\", encodeAsText(logFilter.endBlock)),\n      );\n\n    return exprs;\n  };\n\n  private buildFactoryLogFilterCmprs = ({\n    eb,\n    factory,\n  }: {\n    eb: ExpressionBuilder<any, any>;\n    factory: FactoryLogSource;\n  }) => {\n    const exprs = [];\n\n    exprs.push(eb(\"logs.chainId\", \"=\", factory.chainId));\n\n    const selectChildAddressExpression =\n      buildFactoryChildAddressSelectExpression({\n        childAddressLocation: factory.criteria.childAddressLocation,\n      });\n\n    exprs.push(\n      eb(\n        \"logs.address\",\n        \"in\",\n        eb\n          .selectFrom(\"logs\")\n          .select(selectChildAddressExpression.as(\"childAddress\"))\n          .where(\"chainId\", \"=\", factory.chainId)\n          .where(\"address\", \"=\", factory.criteria.address)\n          .where(\"topic0\", \"=\", factory.criteria.eventSelector),\n      ),\n    );\n\n    if (factory.criteria.topics) {\n      for (const idx_ of range(0, 4)) {\n        const idx = idx_ as 0 | 1 | 2 | 3;\n        // If it's an array of length 1, collapse it.\n        const raw = factory.criteria.topics[idx] ?? null;\n        if (raw === null) continue;\n        const topic = Array.isArray(raw) && raw.length === 1 ? raw[0] : raw;\n        if (Array.isArray(topic)) {\n          exprs.push(eb.or(topic.map((a) => eb(`logs.topic${idx}`, \"=\", a))));\n        } else {\n          exprs.push(eb(`logs.topic${idx}`, \"=\", topic));\n        }\n      }\n    }\n\n    if (factory.startBlock !== undefined && factory.startBlock !== 0)\n      exprs.push(\n        eb(\"logs.blockNumber\", \">=\", encodeAsText(factory.startBlock)),\n      );\n    if (factory.endBlock)\n      exprs.push(eb(\"logs.blockNumber\", \"<=\", encodeAsText(factory.endBlock)));\n\n    return exprs;\n  };\n\n  private buildTraceFilterCmprs = ({\n    eb,\n    callTraceSource,\n  }: {\n    eb: ExpressionBuilder<any, any>;\n    callTraceSource: CallTraceSource;\n  }) => {\n    const exprs = [];\n\n    exprs.push(eb(\"callTraces.chainId\", \"=\", callTraceSource.chainId));\n\n    if (callTraceSource.criteria.fromAddress) {\n      // If it's an array of length 1, collapse it.\n      const fromAddress =\n        Array.isArray(callTraceSource.criteria.fromAddress) &&\n        callTraceSource.criteria.fromAddress.length === 1\n          ? callTraceSource.criteria.fromAddress[0]\n          : callTraceSource.criteria.fromAddress;\n      if (Array.isArray(fromAddress)) {\n        exprs.push(\n          eb.or(fromAddress.map((a) => eb(\"callTraces.from\", \"=\", a))),\n        );\n      } else {\n        exprs.push(eb(\"callTraces.from\", \"=\", fromAddress));\n      }\n    }\n\n    if (callTraceSource.criteria.toAddress) {\n      // If it's an array of length 1, collapse it.\n      const toAddress =\n        Array.isArray(callTraceSource.criteria.toAddress) &&\n        callTraceSource.criteria.toAddress.length === 1\n          ? callTraceSource.criteria.toAddress[0]\n          : callTraceSource.criteria.toAddress;\n      if (Array.isArray(toAddress)) {\n        exprs.push(eb.or(toAddress.map((a) => eb(\"callTraces.to\", \"=\", a))));\n      } else {\n        exprs.push(eb(\"callTraces.to\", \"=\", toAddress));\n      }\n    }\n\n    // Filter based on function selectors\n    exprs.push(\n      eb.or(\n        callTraceSource.criteria.functionSelectors.map((fs) =>\n          eb(\"callTraces.functionSelector\", \"=\", fs),\n        ),\n      ),\n    );\n\n    // Filter out callTraces with error\n    exprs.push(\n      sql`${sql.ref(\"callTraces.error\")} IS NULL` as OperandExpression<SqlBool>,\n    );\n\n    if (\n      callTraceSource.startBlock !== undefined &&\n      callTraceSource.startBlock !== 0\n    )\n      exprs.push(\n        eb(\n          \"callTraces.blockNumber\",\n          \">=\",\n          encodeAsText(callTraceSource.startBlock),\n        ),\n      );\n    if (callTraceSource.endBlock)\n      exprs.push(\n        eb(\n          \"callTraces.blockNumber\",\n          \"<=\",\n          encodeAsText(callTraceSource.endBlock),\n        ),\n      );\n\n    return exprs;\n  };\n\n  private buildFactoryTraceFilterCmprs = ({\n    eb,\n    factory,\n  }: {\n    eb: ExpressionBuilder<any, any>;\n    factory: FactoryCallTraceSource;\n  }) => {\n    const exprs = [];\n\n    exprs.push(eb(\"callTraces.chainId\", \"=\", factory.chainId));\n\n    const selectChildAddressExpression =\n      buildFactoryChildAddressSelectExpression({\n        childAddressLocation: factory.criteria.childAddressLocation,\n      });\n\n    exprs.push(\n      eb(\n        \"callTraces.to\",\n        \"in\",\n        eb\n          .selectFrom(\"logs\")\n          .select(selectChildAddressExpression.as(\"childAddress\"))\n          .where(\"chainId\", \"=\", factory.chainId)\n          .where(\"address\", \"=\", factory.criteria.address)\n          .where(\"topic0\", \"=\", factory.criteria.eventSelector),\n      ),\n    );\n\n    if (factory.criteria.fromAddress) {\n      // If it's an array of length 1, collapse it.\n      const fromAddress =\n        Array.isArray(factory.criteria.fromAddress) &&\n        factory.criteria.fromAddress.length === 1\n          ? factory.criteria.fromAddress[0]\n          : factory.criteria.fromAddress;\n      if (Array.isArray(fromAddress)) {\n        exprs.push(\n          eb.or(fromAddress.map((a) => eb(\"callTraces.from\", \"=\", a))),\n        );\n      } else {\n        exprs.push(eb(\"callTraces.from\", \"=\", fromAddress));\n      }\n    }\n\n    // Filter based on function selectors\n    exprs.push(\n      eb.or(\n        factory.criteria.functionSelectors.map((fs) =>\n          eb(\"callTraces.functionSelector\", \"=\", fs),\n        ),\n      ),\n    );\n\n    // Filter out callTraces with error\n    exprs.push(\n      sql`${sql.ref(\"callTraces.error\")} IS NULL` as OperandExpression<SqlBool>,\n    );\n\n    if (factory.startBlock !== undefined && factory.startBlock !== 0)\n      exprs.push(\n        eb(\"callTraces.blockNumber\", \">=\", encodeAsText(factory.startBlock)),\n      );\n    if (factory.endBlock)\n      exprs.push(\n        eb(\"callTraces.blockNumber\", \"<=\", encodeAsText(factory.endBlock)),\n      );\n\n    return exprs;\n  };\n\n  async pruneByChainId({ chainId, block }: { chainId: number; block: number }) {\n    await this.db.wrap({ method: \"pruneByChainId\" }, () =>\n      this.db.transaction().execute(async (tx) => {\n        await tx\n          .with(\"deleteLogFilter(logFilterId)\", (qb) =>\n            qb\n              .selectFrom(\"logFilterIntervals\")\n              .innerJoin(\"logFilters\", \"logFilterId\", \"logFilters.id\")\n              .select(\"logFilterId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \">=\", encodeAsText(block)),\n          )\n          .deleteFrom(\"logFilterIntervals\")\n          .where(\n            \"logFilterId\",\n            \"in\",\n            sql`(SELECT \"logFilterId\" FROM ${sql.table(\"deleteLogFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .with(\"updateLogFilter(logFilterId)\", (qb) =>\n            qb\n              .selectFrom(\"logFilterIntervals\")\n              .innerJoin(\"logFilters\", \"logFilterId\", \"logFilters.id\")\n              .select(\"logFilterId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \"<\", encodeAsText(block))\n              .where(\"endBlock\", \">\", encodeAsText(block)),\n          )\n          .updateTable(\"logFilterIntervals\")\n          .set({\n            endBlock: encodeAsText(block),\n          })\n          .where(\n            \"logFilterId\",\n            \"in\",\n            sql`(SELECT \"logFilterId\" FROM ${sql.table(\"updateLogFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .with(\"deleteFactoryLogFilter(factoryId)\", (qb) =>\n            qb\n              .selectFrom(\"factoryLogFilterIntervals\")\n              .innerJoin(\n                \"factoryLogFilters\",\n                \"factoryId\",\n                \"factoryLogFilters.id\",\n              )\n\n              .select(\"factoryId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \">=\", encodeAsText(block)),\n          )\n          .deleteFrom(\"factoryLogFilterIntervals\")\n          .where(\n            \"factoryId\",\n            \"in\",\n            sql`(SELECT \"factoryId\" FROM ${sql.table(\"deleteFactoryLogFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .with(\"updateFactoryLogFilter(factoryId)\", (qb) =>\n            qb\n              .selectFrom(\"factoryLogFilterIntervals\")\n              .innerJoin(\n                \"factoryLogFilters\",\n                \"factoryId\",\n                \"factoryLogFilters.id\",\n              )\n\n              .select(\"factoryId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \"<\", encodeAsText(block))\n              .where(\"endBlock\", \">\", encodeAsText(block)),\n          )\n          .updateTable(\"factoryLogFilterIntervals\")\n          .set({\n            endBlock: encodeAsText(block),\n          })\n          .where(\n            \"factoryId\",\n            \"in\",\n            sql`(SELECT \"factoryId\" FROM ${sql.table(\"updateFactoryLogFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .with(\"deleteTraceFilter(traceFilterId)\", (qb) =>\n            qb\n              .selectFrom(\"traceFilterIntervals\")\n              .innerJoin(\"traceFilters\", \"traceFilterId\", \"traceFilters.id\")\n              .select(\"traceFilterId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \">=\", encodeAsText(block)),\n          )\n          .deleteFrom(\"traceFilterIntervals\")\n          .where(\n            \"traceFilterId\",\n            \"in\",\n            sql`(SELECT \"traceFilterId\" FROM ${sql.table(\"deleteTraceFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .with(\"updateTraceFilter(traceFilterId)\", (qb) =>\n            qb\n              .selectFrom(\"traceFilterIntervals\")\n              .innerJoin(\"traceFilters\", \"traceFilterId\", \"traceFilters.id\")\n              .select(\"traceFilterId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \"<\", encodeAsText(block))\n              .where(\"endBlock\", \">\", encodeAsText(block)),\n          )\n          .updateTable(\"traceFilterIntervals\")\n          .set({\n            endBlock: encodeAsText(block),\n          })\n          .where(\n            \"traceFilterId\",\n            \"in\",\n            sql`(SELECT \"traceFilterId\" FROM ${sql.table(\"updateTraceFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .with(\"deleteFactoryTraceFilter(factoryId)\", (qb) =>\n            qb\n              .selectFrom(\"factoryTraceFilterIntervals\")\n              .innerJoin(\n                \"factoryTraceFilters\",\n                \"factoryId\",\n                \"factoryTraceFilters.id\",\n              )\n              .select(\"factoryId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \">=\", encodeAsText(block)),\n          )\n          .deleteFrom(\"factoryTraceFilterIntervals\")\n          .where(\n            \"factoryId\",\n            \"in\",\n            sql`(SELECT \"factoryId\" FROM ${sql.table(\"deleteFactoryTraceFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .with(\"updateFactoryTraceFilter(factoryId)\", (qb) =>\n            qb\n              .selectFrom(\"factoryTraceFilterIntervals\")\n              .innerJoin(\n                \"factoryTraceFilters\",\n                \"factoryId\",\n                \"factoryTraceFilters.id\",\n              )\n\n              .select(\"factoryId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \"<\", encodeAsText(block))\n              .where(\"endBlock\", \">\", encodeAsText(block)),\n          )\n          .updateTable(\"factoryTraceFilterIntervals\")\n          .set({\n            endBlock: encodeAsText(block),\n          })\n          .where(\n            \"factoryId\",\n            \"in\",\n            sql`(SELECT \"factoryId\" FROM ${sql.table(\"updateFactoryTraceFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .with(\"deleteBlockFilter(blockFilterId)\", (qb) =>\n            qb\n              .selectFrom(\"blockFilterIntervals\")\n              .innerJoin(\"blockFilters\", \"blockFilterId\", \"blockFilters.id\")\n              .select(\"blockFilterId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \">=\", encodeAsText(block)),\n          )\n          .deleteFrom(\"blockFilterIntervals\")\n          .where(\n            \"blockFilterId\",\n            \"in\",\n            sql`(SELECT \"blockFilterId\" FROM ${sql.table(\"deleteBlockFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .with(\"updateBlockFilter(blockFilterId)\", (qb) =>\n            qb\n              .selectFrom(\"blockFilterIntervals\")\n              .innerJoin(\"blockFilters\", \"blockFilterId\", \"blockFilters.id\")\n              .select(\"blockFilterId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \"<\", encodeAsText(block))\n              .where(\"endBlock\", \">\", encodeAsText(block)),\n          )\n          .updateTable(\"blockFilterIntervals\")\n          .set({\n            endBlock: encodeAsText(block),\n          })\n          .where(\n            \"blockFilterId\",\n            \"in\",\n            sql`(SELECT \"blockFilterId\" FROM ${sql.table(\"updateBlockFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .deleteFrom(\"logs\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"blockNumber\", \">=\", encodeAsText(block))\n          .execute();\n        await tx\n          .deleteFrom(\"blocks\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"number\", \">=\", encodeAsText(block))\n          .execute();\n        await tx\n          .deleteFrom(\"rpcRequestResults\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"blockNumber\", \">=\", encodeAsText(block))\n          .execute();\n        await tx\n          .deleteFrom(\"callTraces\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"blockNumber\", \">=\", encodeAsText(block))\n          .execute();\n        await tx\n          .deleteFrom(\"transactions\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"blockNumber\", \">=\", encodeAsText(block))\n          .execute();\n        await tx\n          .deleteFrom(\"transactionReceipts\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"blockNumber\", \">=\", encodeAsText(block))\n          .execute();\n      }),\n    );\n  }\n}\n\nfunction buildFactoryChildAddressSelectExpression({\n  childAddressLocation,\n}: {\n  childAddressLocation: FactoryLogFilterCriteria[\"childAddressLocation\"];\n}) {\n  if (childAddressLocation.startsWith(\"offset\")) {\n    const childAddressOffset = Number(childAddressLocation.substring(6));\n    const start = 2 + 12 * 2 + childAddressOffset * 2 + 1;\n    const length = 20 * 2;\n    return sql<Hex>`'0x' || substring(data, ${start}, ${length})`;\n  } else {\n    const start = 2 + 12 * 2 + 1;\n    const length = 20 * 2;\n    return sql<Hex>`'0x' || substring(${sql.ref(childAddressLocation)}, ${start}, ${length})`;\n  }\n}\n","import type { SyncCallTrace } from \"@/sync/index.js\";\nimport { encodeAsText } from \"@/utils/encoding.js\";\nimport { toLowerCase } from \"@/utils/lowercase.js\";\nimport type { Generated, Insertable } from \"kysely\";\nimport type { Address, Hash, Hex, RpcTransactionReceipt } from \"viem\";\nimport {\n  type RpcBlock,\n  type RpcLog,\n  type RpcTransaction,\n  hexToNumber,\n} from \"viem\";\n\nexport type BigIntText = string;\n\ntype BlocksTable = {\n  baseFeePerGas: BigIntText | null;\n  difficulty: BigIntText;\n  extraData: Hex;\n  gasLimit: BigIntText;\n  gasUsed: BigIntText;\n  hash: Hash;\n  logsBloom: Hex;\n  miner: Address;\n  mixHash: Hash | null;\n  nonce: Hex | null;\n  number: BigIntText;\n  parentHash: Hash;\n  receiptsRoot: Hex;\n  sha3Uncles: Hash | null;\n  size: BigIntText;\n  stateRoot: Hash;\n  timestamp: BigIntText;\n  totalDifficulty: BigIntText | null;\n  transactionsRoot: Hash;\n\n  chainId: number;\n  checkpoint: string;\n};\n\nexport type InsertableBlock = Insertable<BlocksTable>;\n\nexport function rpcToSqliteBlock(\n  block: RpcBlock,\n): Omit<InsertableBlock, \"chainId\" | \"checkpoint\"> {\n  return {\n    baseFeePerGas: block.baseFeePerGas\n      ? encodeAsText(block.baseFeePerGas)\n      : null,\n    difficulty: encodeAsText(block.difficulty),\n    extraData: block.extraData,\n    gasLimit: encodeAsText(block.gasLimit),\n    gasUsed: encodeAsText(block.gasUsed),\n    hash: block.hash!,\n    logsBloom: block.logsBloom!,\n    miner: toLowerCase(block.miner),\n    mixHash: block.mixHash ?? null,\n    nonce: block.nonce ?? null,\n    number: encodeAsText(block.number!),\n    parentHash: block.parentHash,\n    receiptsRoot: block.receiptsRoot,\n    sha3Uncles: block.sha3Uncles ?? null,\n    size: encodeAsText(block.size),\n    stateRoot: block.stateRoot,\n    timestamp: encodeAsText(block.timestamp),\n    totalDifficulty: block.totalDifficulty\n      ? encodeAsText(block.totalDifficulty)\n      : null,\n    transactionsRoot: block.transactionsRoot,\n  };\n}\n\ntype TransactionsTable = {\n  blockHash: Hash;\n  blockNumber: BigIntText;\n  from: Address;\n  gas: BigIntText;\n  hash: Hash;\n  input: Hex;\n  nonce: number;\n  r: Hex | null;\n  s: Hex | null;\n  to: Address | null;\n  transactionIndex: number;\n  v: BigIntText | null;\n  value: BigIntText;\n\n  type: Hex;\n  gasPrice: BigIntText | null;\n  maxFeePerGas: BigIntText | null;\n  maxPriorityFeePerGas: BigIntText | null;\n  accessList: string | null;\n\n  chainId: number;\n};\n\nexport type InsertableTransaction = Insertable<TransactionsTable>;\n\nexport function rpcToSqliteTransaction(\n  transaction: RpcTransaction,\n): Omit<InsertableTransaction, \"chainId\"> {\n  return {\n    accessList: transaction.accessList\n      ? JSON.stringify(transaction.accessList)\n      : undefined,\n    blockHash: transaction.blockHash!,\n    blockNumber: encodeAsText(transaction.blockNumber!),\n    from: toLowerCase(transaction.from),\n    gas: encodeAsText(transaction.gas),\n    gasPrice: transaction.gasPrice ? encodeAsText(transaction.gasPrice) : null,\n    hash: transaction.hash,\n    input: transaction.input,\n    maxFeePerGas: transaction.maxFeePerGas\n      ? encodeAsText(transaction.maxFeePerGas)\n      : null,\n    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas\n      ? encodeAsText(transaction.maxPriorityFeePerGas)\n      : null,\n    nonce: hexToNumber(transaction.nonce),\n    r: transaction.r ?? null,\n    s: transaction.s ?? null,\n    to: transaction.to ? toLowerCase(transaction.to) : null,\n    transactionIndex: Number(transaction.transactionIndex),\n    type: transaction.type ?? \"0x0\",\n    value: encodeAsText(transaction.value),\n    v: transaction.v ? encodeAsText(transaction.v) : null,\n  };\n}\n\ntype TransactionReceiptsTable = {\n  blockHash: Hash;\n  blockNumber: BigIntText;\n  contractAddress: Address | null;\n  cumulativeGasUsed: BigIntText;\n  effectiveGasPrice: BigIntText;\n  from: Address;\n  gasUsed: BigIntText;\n  logs: string;\n  logsBloom: Hex;\n  status: Hex;\n  to: Address | null;\n  transactionHash: Hash;\n  transactionIndex: number;\n  type: Hex;\n\n  chainId: number;\n};\n\nexport type InsertableTransactionReceipts =\n  Insertable<TransactionReceiptsTable>;\n\nexport function rpcToSqliteTransactionReceipt(\n  transactionReceipt: RpcTransactionReceipt,\n): Omit<TransactionReceiptsTable, \"chainId\"> {\n  return {\n    blockHash: transactionReceipt.blockHash,\n    blockNumber: encodeAsText(transactionReceipt.blockNumber),\n    contractAddress: transactionReceipt.contractAddress\n      ? toLowerCase(transactionReceipt.contractAddress)\n      : null,\n    cumulativeGasUsed: encodeAsText(transactionReceipt.cumulativeGasUsed),\n    effectiveGasPrice: encodeAsText(transactionReceipt.effectiveGasPrice),\n    from: toLowerCase(transactionReceipt.from),\n    gasUsed: encodeAsText(transactionReceipt.gasUsed),\n    logs: JSON.stringify(transactionReceipt.logs),\n    logsBloom: transactionReceipt.logsBloom,\n    status: transactionReceipt.status,\n    to: transactionReceipt.to ? toLowerCase(transactionReceipt.to) : null,\n    transactionHash: transactionReceipt.transactionHash,\n    transactionIndex: Number(transactionReceipt.transactionIndex),\n    type: transactionReceipt.type as Hex,\n  };\n}\n\ntype LogsTable = {\n  id: string;\n  address: Address;\n  blockHash: Hash;\n  blockNumber: BigIntText;\n  data: Hex;\n  logIndex: number;\n  transactionHash: Hash;\n  transactionIndex: number;\n\n  topic0: Hex | null;\n  topic1: Hex | null;\n  topic2: Hex | null;\n  topic3: Hex | null;\n\n  chainId: number;\n  checkpoint?: string;\n};\n\nexport type InsertableLog = Insertable<LogsTable>;\n\nexport function rpcToSqliteLog(log: RpcLog): Omit<InsertableLog, \"chainId\"> {\n  return {\n    address: toLowerCase(log.address),\n    blockHash: log.blockHash!,\n    blockNumber: encodeAsText(log.blockNumber!),\n    data: log.data,\n    id: `${log.blockHash}-${log.logIndex}`,\n    logIndex: Number(log.logIndex!),\n    topic0: log.topics[0] ? log.topics[0] : null,\n    topic1: log.topics[1] ? log.topics[1] : null,\n    topic2: log.topics[2] ? log.topics[2] : null,\n    topic3: log.topics[3] ? log.topics[3] : null,\n    transactionHash: log.transactionHash!,\n    transactionIndex: Number(log.transactionIndex!),\n  };\n}\n\ntype CallTracesTable = {\n  id: string;\n  callType: string;\n  from: Address;\n  gas: BigIntText;\n  input: Hex;\n  to: Address;\n  value: BigIntText;\n  blockHash: Hex;\n  blockNumber: BigIntText;\n  error: string | null;\n  gasUsed: BigIntText | null;\n  output: Hex | null;\n  subtraces: number;\n  traceAddress: string;\n  transactionHash: Hex;\n  transactionPosition: number;\n  functionSelector: Hex;\n  chainId: number;\n  checkpoint: string;\n};\n\nexport type InsertableCallTrace = Insertable<CallTracesTable>;\n\nexport function rpcToSqliteTrace(\n  trace: SyncCallTrace,\n): Omit<InsertableCallTrace, \"chainId\" | \"checkpoint\"> {\n  return {\n    id: `${trace.transactionHash}-${JSON.stringify(trace.traceAddress)}`,\n    callType: trace.action.callType,\n    from: toLowerCase(trace.action.from),\n    gas: encodeAsText(trace.action.gas),\n    input: trace.action.input,\n    to: toLowerCase(trace.action.to),\n    value: encodeAsText(trace.action.value),\n    blockHash: trace.blockHash,\n    blockNumber: encodeAsText(trace.blockNumber),\n    error: trace.error ?? null,\n    gasUsed: trace.result ? encodeAsText(trace.result.gasUsed) : null,\n    output: trace.result ? trace.result.output : null,\n    subtraces: trace.subtraces,\n    traceAddress: JSON.stringify(trace.traceAddress),\n    transactionHash: trace.transactionHash,\n    transactionPosition: trace.transactionPosition,\n    functionSelector: trace.action.input.slice(0, 10).toLowerCase() as Hex,\n  };\n}\n\ntype RpcRequestResultsTable = {\n  blockNumber: BigIntText;\n  chainId: number;\n  result: string;\n  request: string;\n};\n\ntype LogFiltersTable = {\n  id: string;\n  chainId: number;\n  address: Hex | null;\n  topic0: Hex | null;\n  topic1: Hex | null;\n  topic2: Hex | null;\n  topic3: Hex | null;\n  includeTransactionReceipts: 0 | 1;\n};\n\ntype LogFilterIntervalsTable = {\n  id: Generated<number>;\n  logFilterId: string;\n  startBlock: BigIntText;\n  endBlock: BigIntText;\n};\n\ntype FactoryLogFiltersTable = {\n  id: string;\n  chainId: number;\n  address: Hex;\n  eventSelector: Hex;\n  childAddressLocation: `topic${1 | 2 | 3}` | `offset${number}`;\n  topic0: Hex | null;\n  topic1: Hex | null;\n  topic2: Hex | null;\n  topic3: Hex | null;\n  includeTransactionReceipts: 0 | 1;\n};\n\ntype FactoryLogFilterIntervalsTable = {\n  id: Generated<number>;\n  factoryId: string;\n  startBlock: BigIntText;\n  endBlock: BigIntText;\n};\n\ntype TraceFiltersTable = {\n  id: string;\n  chainId: number;\n  fromAddress: Address | null;\n  toAddress: Address | null;\n};\n\ntype TraceFilterIntervalsTable = {\n  id: Generated<number>;\n  traceFilterId: string;\n  startBlock: BigIntText;\n  endBlock: BigIntText;\n};\n\ntype FactoryTraceFiltersTable = {\n  id: string;\n  chainId: number;\n  address: Hex;\n  eventSelector: Hex;\n  childAddressLocation: `topic${1 | 2 | 3}` | `offset${number}`;\n  fromAddress: Address | null;\n};\n\ntype FactoryTraceFilterIntervalsTable = {\n  id: Generated<number>;\n  factoryId: string;\n  startBlock: BigIntText;\n  endBlock: BigIntText;\n};\n\ntype BlockFiltersTable = {\n  id: string;\n  chainId: number;\n  interval: number;\n  offset: number;\n};\n\ntype BlockFilterIntervalsTable = {\n  id: Generated<number>;\n  blockFilterId: string;\n  startBlock: BigIntText;\n  endBlock: BigIntText;\n};\n\nexport type SyncStoreTables = {\n  blocks: BlocksTable;\n  transactions: TransactionsTable;\n  transactionReceipts: TransactionReceiptsTable;\n  logs: LogsTable;\n  callTraces: CallTracesTable;\n  rpcRequestResults: RpcRequestResultsTable;\n\n  logFilters: LogFiltersTable;\n  logFilterIntervals: LogFilterIntervalsTable;\n  factoryLogFilters: FactoryLogFiltersTable;\n  factoryLogFilterIntervals: FactoryLogFilterIntervalsTable;\n  traceFilters: TraceFiltersTable;\n  traceFilterIntervals: TraceFilterIntervalsTable;\n  factoryTraceFilters: FactoryTraceFiltersTable;\n  factoryTraceFilterIntervals: FactoryTraceFilterIntervalsTable;\n  blockFilters: BlockFiltersTable;\n  blockFilterIntervals: BlockFilterIntervalsTable;\n};\n","import type { RawEvent } from \"@/sync-store/store.js\";\nimport type {\n  Block,\n  CallTrace,\n  Log,\n  Transaction,\n  TransactionReceipt,\n} from \"@/types/eth.js\";\nimport { never } from \"@/utils/never.js\";\nimport {\n  type Hex,\n  decodeEventLog,\n  decodeFunctionData,\n  decodeFunctionResult,\n} from \"viem\";\nimport type { Service } from \"./service.js\";\n\nexport type SetupEvent = {\n  type: \"setup\";\n  chainId: number;\n  contractName: string;\n  startBlock: bigint;\n  encodedCheckpoint: string;\n};\n\nexport type LogEvent = {\n  type: \"log\";\n  chainId: number;\n  contractName: string;\n  logEventName: string;\n  event: {\n    args: any;\n    log: Log;\n    block: Block;\n    transaction: Transaction;\n    transactionReceipt?: TransactionReceipt;\n  };\n  encodedCheckpoint: string;\n};\n\nexport type BlockEvent = {\n  type: \"block\";\n  chainId: number;\n  sourceName: string;\n  event: {\n    block: Block;\n  };\n  encodedCheckpoint: string;\n};\n\nexport type CallTraceEvent = {\n  type: \"callTrace\";\n  chainId: number;\n  contractName: string;\n  functionName: string;\n  event: {\n    args: any;\n    result: any;\n    trace: CallTrace;\n    block: Block;\n    transaction: Transaction;\n    transactionReceipt?: TransactionReceipt;\n  };\n  encodedCheckpoint: string;\n};\n\nexport type Event = LogEvent | BlockEvent | CallTraceEvent;\n\nexport const decodeEvents = (\n  { common, sourceById }: Pick<Service, \"sourceById\" | \"common\">,\n  rawEvents: RawEvent[],\n): Event[] => {\n  const events: Event[] = [];\n\n  for (const event of rawEvents) {\n    const source = sourceById[event.sourceId]!;\n\n    switch (source.type) {\n      case \"block\": {\n        events.push({\n          type: \"block\",\n          chainId: event.chainId,\n          sourceName: source.sourceName,\n          event: {\n            block: event.block,\n          },\n          encodedCheckpoint: event.encodedCheckpoint,\n        });\n        break;\n      }\n\n      case \"callTrace\":\n      case \"factoryCallTrace\": {\n        try {\n          const abi = source.abi;\n\n          const data = decodeFunctionData({\n            abi,\n            data: event.trace!.input,\n          });\n\n          const result = decodeFunctionResult({\n            abi,\n            data: event.trace!.output,\n            functionName: data.functionName,\n          });\n\n          const selector = event.trace!.input.slice(0, 10) as Hex;\n\n          if (source.abiFunctions.bySelector[selector] === undefined) {\n            throw new Error();\n          }\n\n          const functionName =\n            source.abiFunctions.bySelector[selector]!.safeName;\n\n          events.push({\n            type: \"callTrace\",\n            chainId: event.chainId,\n            contractName: source.contractName,\n            functionName,\n            event: {\n              args: data.args,\n              result,\n              trace: event.trace!,\n              block: event.block,\n              transaction: event.transaction!,\n              transactionReceipt: event.transactionReceipt,\n            },\n            encodedCheckpoint: event.encodedCheckpoint,\n          });\n        } catch (err) {\n          common.logger.debug({\n            service: \"app\",\n            msg: `Unable to decode trace, skipping it. id: ${event.trace?.id}, input: ${event.trace?.input}, output: ${event.trace?.output}`,\n          });\n        }\n        break;\n      }\n\n      case \"log\":\n      case \"factoryLog\": {\n        try {\n          const abi = source.abi;\n\n          const decodedLog = decodeEventLog({\n            abi,\n            data: event.log!.data,\n            topics: event.log!.topics,\n          });\n\n          if (\n            event.log!.topics[0] === undefined ||\n            source.abiEvents.bySelector[event.log!.topics[0]] === undefined\n          ) {\n            throw new Error();\n          }\n\n          const logEventName =\n            source.abiEvents.bySelector[event.log!.topics[0]]!.safeName;\n\n          events.push({\n            type: \"log\",\n            chainId: event.chainId,\n            contractName: source.contractName,\n            logEventName,\n            event: {\n              args: decodedLog.args,\n              log: event.log!,\n              block: event.block,\n              transaction: event.transaction!,\n              transactionReceipt: event.transactionReceipt,\n            },\n            encodedCheckpoint: event.encodedCheckpoint,\n          });\n        } catch (err) {\n          // TODO(kyle) Because we are strictly setting all `topics` now, this should be a bigger error.\n          common.logger.debug({\n            service: \"app\",\n            msg: `Unable to decode log, skipping it. id: ${event.log?.id}, data: ${event.log?.data}, topics: ${event.log?.topics}`,\n          });\n        }\n        break;\n      }\n\n      default:\n        never(source);\n    }\n  }\n\n  return events;\n};\n","import type { Common } from \"@/common/common.js\";\nimport type { Network } from \"@/config/networks.js\";\nimport { type Extend, extend } from \"@/utils/extend.js\";\nimport { toLowerCase } from \"@/utils/lowercase.js\";\nimport type { RequestQueue } from \"@/utils/requestQueue.js\";\nimport {\n  type Address,\n  BlockNotFoundError,\n  type BlockTag,\n  type Hash,\n  type Hex,\n  type Log,\n  type LogTopic,\n  type RpcBlock,\n  type RpcTransaction,\n  type RpcTransactionReceipt,\n  TransactionReceiptNotFoundError,\n  numberToHex,\n} from \"viem\";\nimport {\n  type Service,\n  create,\n  getCachedTransport,\n  getHistoricalCheckpoint,\n  getStatusBlocks,\n  kill,\n  startHistorical,\n  startRealtime,\n} from \"./service.js\";\n\nconst methods = {\n  startHistorical,\n  getHistoricalCheckpoint,\n  getStatusBlocks,\n  startRealtime,\n  getCachedTransport,\n  kill,\n};\n\nexport const createSyncService = extend(create, methods);\n\nexport type SyncService = Extend<Service, typeof methods>;\n\nexport type BaseSyncService = {\n  common: Common;\n  requestQueue: RequestQueue;\n  network: Network;\n};\n\nexport type SyncBlock = RpcBlock<Exclude<BlockTag, \"pending\">, true>;\nexport type SyncLog = Log<Hex, Hex, false>;\nexport type SyncTransaction = RpcTransaction;\nexport type SyncTransactionReceipt = RpcTransactionReceipt;\nexport type SyncTrace =\n  | SyncCallTrace\n  | SyncCreateTrace\n  | SyncRewardTrace\n  | SyncSuicideTrace;\nexport type SyncCallTrace = {\n  action: {\n    callType: \"call\" | \"delegatecall\" | \"staticcall\";\n    from: Address;\n    gas: Hex;\n    input: Hex;\n    to: Address;\n    value: Hex;\n  };\n  blockHash: Hex;\n  blockNumber: Hex;\n  error?: string;\n  result: {\n    gasUsed: Hex;\n    output: Hex;\n  } | null;\n  subtraces: number;\n  traceAddress: number[];\n  transactionHash: Hex;\n  transactionPosition: number;\n  type: \"call\";\n};\nexport type SyncCreateTrace = {\n  action: {\n    from: Address;\n    gas: Hex;\n    init: Hex;\n    value: Hex;\n  };\n  blockHash: Hex;\n  blockNumber: Hex;\n  result: {\n    address: Address;\n    code: Hex;\n    gasUsed: Hex;\n  } | null;\n  subtraces: number;\n  traceAddress: number[];\n  transactionHash: Hex;\n  transactionPosition: number;\n  type: \"create\";\n};\nexport type SyncSuicideTrace = {\n  action: {\n    address: Address;\n    refundAddress: Address;\n    balance: Hex;\n  };\n  blockHash: Hex;\n  blockNumber: Hex;\n  result: null;\n  subtraces: number;\n  traceAddress: number[];\n  transactionHash: Hex;\n  transactionPosition: number;\n  type: \"suicide\";\n};\nexport type SyncRewardTrace = {\n  action: {\n    author: Address;\n    rewardType: \"block\" | \"uncle\";\n    value: Hex;\n  };\n  blockHash: Hex;\n  blockNumber: Hex;\n  result: null;\n  subtraces: number;\n  traceAddress: number[];\n  type: \"reward\";\n};\n\n/**\n * Helper function for \"eth_getBlockByNumber\" request.\n */\nexport const _eth_getBlockByNumber = (\n  { requestQueue }: Pick<BaseSyncService, \"requestQueue\">,\n  {\n    blockNumber,\n    blockTag,\n  }:\n    | { blockNumber: Hex | number; blockTag?: never }\n    | { blockNumber?: never; blockTag: \"latest\" },\n): Promise<SyncBlock> =>\n  requestQueue\n    .request({\n      method: \"eth_getBlockByNumber\",\n      params: [\n        typeof blockNumber === \"number\"\n          ? numberToHex(blockNumber)\n          : blockNumber ?? blockTag,\n        true,\n      ],\n    })\n    .then((_block) => {\n      if (!_block)\n        throw new BlockNotFoundError({\n          blockNumber: (blockNumber ?? blockTag) as any,\n        });\n      return _block as SyncBlock;\n    });\n\n/**\n * Helper function for \"eth_getBlockByNumber\" request.\n */\nexport const _eth_getBlockByHash = (\n  { requestQueue }: Pick<BaseSyncService, \"requestQueue\">,\n  { blockHash }: { blockHash: Hex },\n): Promise<SyncBlock> =>\n  requestQueue\n    .request({\n      method: \"eth_getBlockByHash\",\n      params: [blockHash, true],\n    })\n    .then((_block) => {\n      if (!_block)\n        throw new BlockNotFoundError({\n          blockHash,\n        });\n      return _block as SyncBlock;\n    });\n\n/**\n * Helper function for \"eth_getLogs\" rpc request.\n * Handles different error types and retries the request if applicable.\n */\nexport const _eth_getLogs = async (\n  { requestQueue }: Pick<BaseSyncService, \"requestQueue\">,\n  params: {\n    address?: Address | Address[];\n    topics?: LogTopic[];\n  } & (\n    | { fromBlock: Hex | number; toBlock: Hex | number }\n    | { blockHash: Hash }\n  ),\n): Promise<SyncLog[]> => {\n  if (\"blockHash\" in params) {\n    return requestQueue\n      .request({\n        method: \"eth_getLogs\",\n        params: [\n          {\n            blockHash: params.blockHash,\n\n            topics: params.topics,\n            address: params.address\n              ? Array.isArray(params.address)\n                ? params.address.map((a) => toLowerCase(a))\n                : toLowerCase(params.address)\n              : undefined,\n          },\n        ],\n      })\n      .then((l) => l as SyncLog[]);\n  }\n\n  return requestQueue\n    .request({\n      method: \"eth_getLogs\",\n      params: [\n        {\n          fromBlock:\n            typeof params.fromBlock === \"number\"\n              ? numberToHex(params.fromBlock)\n              : params.fromBlock,\n          toBlock:\n            typeof params.toBlock === \"number\"\n              ? numberToHex(params.toBlock)\n              : params.toBlock,\n\n          topics: params.topics,\n          address: params.address\n            ? Array.isArray(params.address)\n              ? params.address.map((a) => toLowerCase(a))\n              : toLowerCase(params.address)\n            : undefined,\n        },\n      ],\n    })\n    .then((l) => l as SyncLog[]);\n};\n\n/**\n * Helper function for \"eth_getTransactionReceipt\" request.\n */\nexport const _eth_getTransactionReceipt = (\n  { requestQueue }: Pick<BaseSyncService, \"requestQueue\">,\n  { hash }: { hash: Hex },\n): Promise<SyncTransactionReceipt> =>\n  requestQueue\n    .request({\n      method: \"eth_getTransactionReceipt\",\n      params: [hash],\n    })\n    .then((receipt) => {\n      if (!receipt)\n        throw new TransactionReceiptNotFoundError({\n          hash,\n        });\n      return receipt as SyncTransactionReceipt;\n    });\n\n/**\n * Helper function for \"trace_filter\" request.\n *\n * Note: No strict typing is available.\n */\nexport const _trace_filter = (\n  { requestQueue }: Pick<BaseSyncService, \"requestQueue\">,\n  params: {\n    fromBlock: Hex | number;\n    toBlock: Hex | number;\n    fromAddress?: Address[];\n    toAddress?: Address[];\n  },\n): Promise<SyncTrace[]> =>\n  requestQueue\n    .request({\n      method: \"trace_filter\",\n      params: [\n        {\n          fromBlock:\n            typeof params.fromBlock === \"number\"\n              ? numberToHex(params.fromBlock)\n              : params.fromBlock,\n          toBlock:\n            typeof params.toBlock === \"number\"\n              ? numberToHex(params.toBlock)\n              : params.toBlock,\n          fromAddress: params.fromAddress\n            ? params.fromAddress.map((a) => toLowerCase(a))\n            : undefined,\n          toAddress: params.toAddress\n            ? params.toAddress.map((a) => toLowerCase(a))\n            : undefined,\n        },\n      ],\n    } as any)\n    .then((traces) => traces as unknown as SyncTrace[]);\n\n/**\n * Helper function for \"trace_block\" request.\n *\n * Note: No strict typing is available.\n */\nexport const _trace_block = (\n  { requestQueue }: Pick<BaseSyncService, \"requestQueue\">,\n  params: {\n    blockNumber: Hex | number;\n  },\n): Promise<SyncTrace[]> =>\n  requestQueue\n    .request({\n      method: \"trace_block\",\n      params: [\n        typeof params.blockNumber === \"number\"\n          ? numberToHex(params.blockNumber)\n          : params.blockNumber,\n      ],\n    } as any)\n    .then((traces) => traces as unknown as SyncTrace[]);\n","import type { Prettify } from \"@/types/utils.js\";\nimport type { DefaultAddOptions, Options, Queue as TPQueue } from \"p-queue\";\nimport PQueue from \"p-queue\";\n\ntype TaskOptions = { priority?: number };\n\nexport type Queue<TTask> = PQueue & {\n  addTask: (task: TTask, options?: TaskOptions) => Promise<void>;\n};\n\ntype QueueOptions = Prettify<\n  Options<TPQueue<() => Promise<unknown>, DefaultAddOptions>, DefaultAddOptions>\n>;\n\nexport type Worker<TTask, TReturn = void> = (arg: {\n  task: TTask;\n  queue: Queue<TTask>;\n}) => Promise<TReturn>;\n\ntype OnError<TTask> = (arg: {\n  error: Error;\n  task: TTask;\n  queue: Queue<TTask>;\n}) => unknown;\n\n/**\n * Creates a Queue object that has a number of features tailored\n * to Ponder's indexing engine, including:\n * - A shared context object accessible by all tasks\n * - An onError callback that is called _within_ the failed task scope,\n *   allowing the user to retry/add more tasks without the queue going idle.\n */\nexport function createQueue<TTask, TReturn = void>({\n  worker,\n  options,\n  onError,\n  onIdle,\n}: {\n  worker: Worker<TTask, TReturn>;\n  options?: QueueOptions;\n  onError?: OnError<TTask>;\n  onIdle?: () => unknown;\n}): Queue<TTask> {\n  const queue = new PQueue(options) as Queue<TTask>;\n\n  if (onIdle) {\n    queue.on(\"idle\", () => onIdle());\n  }\n\n  queue.addTask = async (task, taskOptions) => {\n    const priority = taskOptions?.priority ?? 0;\n\n    try {\n      await queue.add(\n        () => {\n          return worker({\n            task,\n            queue,\n          });\n        },\n        {\n          priority,\n        },\n      );\n    } catch (error_: any) {\n      await onError?.({ error: error_ as Error, task, queue });\n    }\n  };\n\n  return queue;\n}\n","import type { Common } from \"@/common/common.js\";\nimport { getHistoricalSyncProgress } from \"@/common/metrics.js\";\nimport type { Network } from \"@/config/networks.js\";\nimport type {\n  BlockSource,\n  CallTraceSource,\n  EventSource,\n  FactoryCallTraceSource,\n  FactoryLogSource,\n  LogSource,\n} from \"@/config/sources.js\";\nimport type { SyncStore } from \"@/sync-store/store.js\";\nimport {\n  type SyncBlock,\n  type SyncCallTrace,\n  type SyncLog,\n  _eth_getBlockByNumber,\n  _eth_getLogs,\n  _eth_getTransactionReceipt,\n  _trace_filter,\n} from \"@/sync/index.js\";\nimport { type Checkpoint, maxCheckpoint } from \"@/utils/checkpoint.js\";\nimport { formatEta, formatPercentage } from \"@/utils/format.js\";\nimport {\n  BlockProgressTracker,\n  ProgressTracker,\n  getChunks,\n  intervalDifference,\n  intervalIntersection,\n  intervalSum,\n} from \"@/utils/interval.js\";\nimport { never } from \"@/utils/never.js\";\nimport { type Queue, type Worker, createQueue } from \"@/utils/queue.js\";\nimport type { RequestQueue } from \"@/utils/requestQueue.js\";\nimport { debounce, dedupe } from \"@ponder/common\";\nimport Emittery from \"emittery\";\nimport { type Hash, hexToNumber, numberToHex, toHex } from \"viem\";\n\nconst HISTORICAL_CHECKPOINT_EMIT_INTERVAL = 500;\nconst TRACE_FILTER_CHUNK_SIZE = 10;\n\ntype HistoricalSyncEvents = {\n  /**\n   * Emitted when the service has finished processing all historical sync tasks.\n   */\n  syncComplete: undefined;\n  /**\n   * Emitted when the minimum cached timestamp among all registered sources moves forward.\n   * This indicates to consumers that the connected sync store now contains a complete history\n   * of events for all registered sources between their start block and this timestamp (inclusive).\n   */\n  historicalCheckpoint: Checkpoint;\n};\n\ntype FactoryChildAddressTask = {\n  kind: \"FACTORY_CHILD_ADDRESS\";\n  factory: FactoryLogSource | FactoryCallTraceSource;\n  fromBlock: number;\n  toBlock: number;\n};\n\ntype LogFilterTask = {\n  kind: \"LOG_FILTER\";\n  logFilter: LogSource;\n  fromBlock: number;\n  toBlock: number;\n};\n\ntype FactoryLogFilterTask = {\n  kind: \"FACTORY_LOG_FILTER\";\n  factoryLogFilter: FactoryLogSource;\n  fromBlock: number;\n  toBlock: number;\n};\n\ntype TraceFilterTask = {\n  kind: \"TRACE_FILTER\";\n  traceFilter: CallTraceSource;\n  fromBlock: number;\n  toBlock: number;\n};\n\ntype FactoryTraceFilterTask = {\n  kind: \"FACTORY_TRACE_FILTER\";\n  factoryTraceFilter: FactoryCallTraceSource;\n  fromBlock: number;\n  toBlock: number;\n};\n\ntype BlockFilterTask = {\n  kind: \"BLOCK_FILTER\";\n  blockFilter: BlockSource;\n  fromBlock: number;\n  toBlock: number;\n};\n\ntype BlockTask = {\n  kind: \"BLOCK\";\n  blockNumber: number;\n  callbacks: ((block: SyncBlock) => Promise<void>)[];\n};\n\ntype HistoricalSyncTask =\n  | FactoryChildAddressTask\n  | LogFilterTask\n  | FactoryLogFilterTask\n  | TraceFilterTask\n  | FactoryTraceFilterTask\n  | BlockFilterTask\n  | BlockTask;\n\nexport class HistoricalSyncService extends Emittery<HistoricalSyncEvents> {\n  private common: Common;\n  private syncStore: SyncStore;\n  private network: Network;\n  private requestQueue: RequestQueue;\n  private sources: EventSource[];\n\n  /**\n   * Block progress trackers for each task type.\n   */\n  private logFilterProgressTrackers: Record<string, ProgressTracker> = {};\n  private factoryChildAddressProgressTrackers: Record<string, ProgressTracker> =\n    {};\n  private factoryLogFilterProgressTrackers: Record<string, ProgressTracker> =\n    {};\n  private traceFilterProgressTrackers: Record<string, ProgressTracker> = {};\n  private factoryTraceFilterProgressTrackers: Record<string, ProgressTracker> =\n    {};\n  private blockFilterProgressTrackers: Record<string, ProgressTracker> = {};\n\n  private blockProgressTracker: BlockProgressTracker =\n    new BlockProgressTracker();\n\n  /**\n   * Functions registered by log filter + child contract tasks. These functions accept\n   * a raw block object, get required data from it, then insert data and cache metadata\n   * into the sync store. The keys of this object are used to keep track of which blocks\n   * must be fetched.\n   */\n  private blockCallbacks: Record<\n    number,\n    ((block: SyncBlock) => Promise<void>)[]\n  > = {};\n\n  /**\n   * Block tasks have been added to the queue up to and including this block number.\n   * Used alongside blockCallbacks to keep track of which block tasks to add to the queue.\n   */\n  private blockTasksEnqueuedCheckpoint = 0;\n\n  private queue: Queue<HistoricalSyncTask>;\n\n  /** If true, failed tasks should not log errors or be retried. */\n  private isShuttingDown = false;\n  private progressLogInterval?: NodeJS.Timeout;\n\n  constructor({\n    common,\n    syncStore,\n    network,\n    requestQueue,\n    sources = [],\n  }: {\n    common: Common;\n    syncStore: SyncStore;\n    network: Network;\n    requestQueue: RequestQueue;\n    sources?: EventSource[];\n  }) {\n    super();\n\n    this.common = common;\n    this.syncStore = syncStore;\n    this.network = network;\n    this.requestQueue = requestQueue;\n    this.sources = sources;\n\n    this.queue = this.buildQueue();\n  }\n\n  async setup({\n    finalizedBlockNumber,\n  }: {\n    finalizedBlockNumber: number;\n  }) {\n    // Initialize state variables. Required when restarting the service.\n    this.isShuttingDown = false;\n    this.blockTasksEnqueuedCheckpoint = 0;\n\n    for (const source of this.sources) {\n      const startBlock = source.startBlock;\n      const endBlock = source.endBlock ?? finalizedBlockNumber;\n\n      if (source.startBlock > finalizedBlockNumber) {\n        switch (source.type) {\n          case \"log\":\n          case \"factoryLog\": {\n            this.common.metrics.ponder_historical_total_blocks.set(\n              {\n                network: this.network.name,\n                source: source.contractName,\n                type: \"log\",\n              },\n              0,\n            );\n            this.common.logger.warn({\n              service: \"historical\",\n              msg: `Skipped syncing '${this.network.name}' logs for '${source.contractName}' because the start block is not finalized`,\n            });\n            break;\n          }\n\n          case \"callTrace\":\n          case \"factoryCallTrace\": {\n            this.common.metrics.ponder_historical_total_blocks.set(\n              {\n                network: this.network.name,\n                source: source.contractName,\n                type: \"trace\",\n              },\n              0,\n            );\n            this.common.logger.warn({\n              service: \"historical\",\n              msg: `Skipped syncing '${this.network.name}' call traces for '${source.contractName}' because the start block is not finalized`,\n            });\n            break;\n          }\n\n          case \"block\": {\n            this.common.metrics.ponder_historical_total_blocks.set(\n              {\n                network: this.network.name,\n                source: source.sourceName,\n                type: \"block\",\n              },\n              0,\n            );\n            this.common.logger.warn({\n              service: \"historical\",\n              msg: `Skipped syncing '${this.network.name}' blocks for '${source.sourceName}' because the start block is not finalized`,\n            });\n            break;\n          }\n\n          default:\n            never(source);\n        }\n\n        return;\n      }\n\n      switch (source.type) {\n        case \"log\":\n          {\n            const completedLogFilterIntervals =\n              await this.syncStore.getLogFilterIntervals({\n                chainId: source.chainId,\n                logFilter: source.criteria,\n              });\n            const logFilterProgressTracker = new ProgressTracker({\n              target: [startBlock, endBlock],\n              completed: completedLogFilterIntervals,\n            });\n            this.logFilterProgressTrackers[source.id] =\n              logFilterProgressTracker;\n\n            const requiredLogFilterIntervals =\n              logFilterProgressTracker.getRequired();\n\n            const logFilterTaskChunks = getChunks({\n              intervals: requiredLogFilterIntervals,\n              maxChunkSize:\n                source.maxBlockRange ?? this.network.defaultMaxBlockRange,\n            });\n\n            for (const [fromBlock, toBlock] of logFilterTaskChunks) {\n              this.queue.addTask(\n                {\n                  kind: \"LOG_FILTER\",\n                  logFilter: source,\n                  fromBlock,\n                  toBlock,\n                },\n                { priority: Number.MAX_SAFE_INTEGER - fromBlock },\n              );\n            }\n            if (logFilterTaskChunks.length > 0) {\n              const total = intervalSum(requiredLogFilterIntervals);\n              this.common.logger.debug({\n                service: \"historical\",\n                msg: `Added '${this.network.name}' LOG_FILTER tasks for '${source.contractName}' over a ${total} block range`,\n              });\n            }\n\n            const targetBlockCount = endBlock - startBlock + 1;\n            const cachedBlockCount =\n              targetBlockCount - intervalSum(requiredLogFilterIntervals);\n\n            this.common.metrics.ponder_historical_total_blocks.set(\n              {\n                network: this.network.name,\n                source: source.contractName,\n                type: \"log\",\n              },\n              targetBlockCount,\n            );\n            this.common.metrics.ponder_historical_cached_blocks.set(\n              {\n                network: this.network.name,\n                source: source.contractName,\n                type: \"log\",\n              },\n              cachedBlockCount,\n            );\n\n            this.common.logger.info({\n              service: \"historical\",\n              msg: `Started syncing '${this.network.name}' logs for '${\n                source.contractName\n              }' with ${formatPercentage(\n                Math.min(1, cachedBlockCount / (targetBlockCount || 1)),\n              )} cached`,\n            });\n          }\n          break;\n\n        case \"factoryLog\":\n          {\n            // Note that factory child address progress is stored using\n            // log intervals for the factory log.\n            const completedFactoryChildAddressIntervals =\n              await this.syncStore.getLogFilterIntervals({\n                chainId: source.chainId,\n                logFilter: {\n                  address: source.criteria.address,\n                  topics: [source.criteria.eventSelector],\n                  includeTransactionReceipts: false,\n                },\n              });\n            const factoryChildAddressProgressTracker = new ProgressTracker({\n              target: [startBlock, endBlock],\n              completed: completedFactoryChildAddressIntervals,\n            });\n            this.factoryChildAddressProgressTrackers[source.id] =\n              factoryChildAddressProgressTracker;\n\n            const requiredFactoryChildAddressIntervals =\n              factoryChildAddressProgressTracker.getRequired();\n            const factoryChildAddressTaskChunks = getChunks({\n              intervals: requiredFactoryChildAddressIntervals,\n              maxChunkSize:\n                source.maxBlockRange ?? this.network.defaultMaxBlockRange,\n            });\n\n            for (const [fromBlock, toBlock] of factoryChildAddressTaskChunks) {\n              this.queue.addTask(\n                {\n                  kind: \"FACTORY_CHILD_ADDRESS\",\n                  factory: source,\n                  fromBlock,\n                  toBlock,\n                },\n                { priority: Number.MAX_SAFE_INTEGER - fromBlock },\n              );\n            }\n            if (factoryChildAddressTaskChunks.length > 0) {\n              const total = intervalSum(requiredFactoryChildAddressIntervals);\n              this.common.logger.debug({\n                service: \"historical\",\n                msg: `Added '${this.network.name}' FACTORY_CHILD_ADDRESS tasks for '${source.contractName}' over a ${total} block range`,\n              });\n            }\n\n            const targetFactoryChildAddressBlockCount =\n              endBlock - startBlock + 1;\n            const cachedFactoryChildAddressBlockCount =\n              targetFactoryChildAddressBlockCount -\n              intervalSum(requiredFactoryChildAddressIntervals);\n\n            this.common.metrics.ponder_historical_total_blocks.set(\n              {\n                network: this.network.name,\n                source: `${source.contractName}_factory`,\n                type: \"log\",\n              },\n              targetFactoryChildAddressBlockCount,\n            );\n            this.common.metrics.ponder_historical_cached_blocks.set(\n              {\n                network: this.network.name,\n                source: `${source.contractName}_factory`,\n                type: \"log\",\n              },\n              cachedFactoryChildAddressBlockCount,\n            );\n\n            const completedFactoryLogFilterIntervals =\n              await this.syncStore.getFactoryLogFilterIntervals({\n                chainId: source.chainId,\n                factory: source.criteria,\n              });\n            const factoryLogFilterProgressTracker = new ProgressTracker({\n              target: [startBlock, endBlock],\n              completed: completedFactoryLogFilterIntervals,\n            });\n            this.factoryLogFilterProgressTrackers[source.id] =\n              factoryLogFilterProgressTracker;\n\n            // Only add factory log filter tasks for any intervals where the\n            // child address tasks are completed, but the factory log filter tasks are not,\n            // because these won't be added automatically by child address tasks.\n            const requiredFactoryLogFilterIntervals =\n              factoryLogFilterProgressTracker.getRequired();\n            const missingFactoryLogFilterIntervals = intervalDifference(\n              requiredFactoryLogFilterIntervals,\n              requiredFactoryChildAddressIntervals,\n            );\n\n            const missingFactoryLogFilterTaskChunks = getChunks({\n              intervals: missingFactoryLogFilterIntervals,\n              maxChunkSize:\n                source.maxBlockRange ?? this.network.defaultMaxBlockRange,\n            });\n\n            for (const [\n              fromBlock,\n              toBlock,\n            ] of missingFactoryLogFilterTaskChunks) {\n              this.queue.addTask(\n                {\n                  kind: \"FACTORY_LOG_FILTER\",\n                  factoryLogFilter: source,\n                  fromBlock,\n                  toBlock,\n                },\n                { priority: Number.MAX_SAFE_INTEGER - fromBlock },\n              );\n            }\n            if (missingFactoryLogFilterTaskChunks.length > 0) {\n              const total = intervalSum(missingFactoryLogFilterIntervals);\n              this.common.logger.debug({\n                service: \"historical\",\n                msg: `Added '${this.network.name}' FACTORY_LOG_FILTER tasks for '${source.contractName}' over a ${total} block range`,\n              });\n            }\n\n            const targetFactoryLogFilterBlockCount = endBlock - startBlock + 1;\n            const cachedFactoryLogFilterBlockCount =\n              targetFactoryLogFilterBlockCount -\n              intervalSum(requiredFactoryLogFilterIntervals);\n\n            this.common.metrics.ponder_historical_total_blocks.set(\n              {\n                network: this.network.name,\n                source: source.contractName,\n                type: \"log\",\n              },\n              targetFactoryLogFilterBlockCount,\n            );\n            this.common.metrics.ponder_historical_cached_blocks.set(\n              {\n                network: this.network.name,\n                source: source.contractName,\n                type: \"log\",\n              },\n              cachedFactoryLogFilterBlockCount,\n            );\n\n            // Use factory log filter progress for the logger because it better represents\n            // user-facing progress.\n            const cacheRate = Math.min(\n              1,\n              cachedFactoryLogFilterBlockCount /\n                (targetFactoryLogFilterBlockCount || 1),\n            );\n            this.common.logger.info({\n              service: \"historical\",\n              msg: `Started syncing '${this.network.name}' logs for '${\n                source.contractName\n              }' with ${formatPercentage(cacheRate)} cached`,\n            });\n          }\n          break;\n\n        case \"callTrace\":\n          {\n            const completedTraceFilterIntervals =\n              await this.syncStore.getTraceFilterIntervals({\n                chainId: source.chainId,\n                traceFilter: source.criteria,\n              });\n            const traceFilterProgressTracker = new ProgressTracker({\n              target: [startBlock, endBlock],\n              completed: completedTraceFilterIntervals,\n            });\n            this.traceFilterProgressTrackers[source.id] =\n              traceFilterProgressTracker;\n\n            const requiredTraceFilterIntervals =\n              traceFilterProgressTracker.getRequired();\n\n            const traceFilterTaskChunks = getChunks({\n              intervals: requiredTraceFilterIntervals,\n              maxChunkSize: TRACE_FILTER_CHUNK_SIZE,\n            });\n\n            for (const [fromBlock, toBlock] of traceFilterTaskChunks) {\n              this.queue.addTask(\n                {\n                  kind: \"TRACE_FILTER\",\n                  traceFilter: source,\n                  fromBlock,\n                  toBlock,\n                },\n                { priority: Number.MAX_SAFE_INTEGER - fromBlock },\n              );\n            }\n            if (traceFilterTaskChunks.length > 0) {\n              const total = intervalSum(requiredTraceFilterIntervals);\n              this.common.logger.debug({\n                service: \"historical\",\n                msg: `Added '${this.network.name}' TRACE_FILTER tasks for '${source.contractName}' over a ${total} block range`,\n              });\n            }\n\n            const targetBlockCount = endBlock - startBlock + 1;\n            const cachedBlockCount =\n              targetBlockCount - intervalSum(requiredTraceFilterIntervals);\n\n            this.common.metrics.ponder_historical_total_blocks.set(\n              {\n                network: this.network.name,\n                source: source.contractName,\n                type: \"trace\",\n              },\n              targetBlockCount,\n            );\n            this.common.metrics.ponder_historical_cached_blocks.set(\n              {\n                network: this.network.name,\n                source: source.contractName,\n                type: \"trace\",\n              },\n              cachedBlockCount,\n            );\n\n            this.common.logger.info({\n              service: \"historical\",\n              msg: `Started syncing '${this.network.name}' call traces for '${\n                source.contractName\n              }' with ${formatPercentage(\n                Math.min(1, cachedBlockCount / (targetBlockCount || 1)),\n              )} cached`,\n            });\n          }\n          break;\n\n        case \"factoryCallTrace\":\n          {\n            // Note that factory child address progress is stored using\n            // log intervals for the factory log.\n            const completedFactoryChildAddressIntervals =\n              await this.syncStore.getLogFilterIntervals({\n                chainId: source.chainId,\n                logFilter: {\n                  address: source.criteria.address,\n                  topics: [source.criteria.eventSelector],\n                  includeTransactionReceipts: false,\n                },\n              });\n            const factoryChildAddressProgressTracker = new ProgressTracker({\n              target: [startBlock, endBlock],\n              completed: completedFactoryChildAddressIntervals,\n            });\n            this.factoryChildAddressProgressTrackers[source.id] =\n              factoryChildAddressProgressTracker;\n\n            const requiredFactoryChildAddressIntervals =\n              factoryChildAddressProgressTracker.getRequired();\n            const factoryChildAddressTaskChunks = getChunks({\n              intervals: requiredFactoryChildAddressIntervals,\n              maxChunkSize:\n                source.maxBlockRange ?? this.network.defaultMaxBlockRange,\n            });\n\n            for (const [fromBlock, toBlock] of factoryChildAddressTaskChunks) {\n              this.queue.addTask(\n                {\n                  kind: \"FACTORY_CHILD_ADDRESS\",\n                  factory: source,\n                  fromBlock,\n                  toBlock,\n                },\n                { priority: Number.MAX_SAFE_INTEGER - fromBlock },\n              );\n            }\n            if (factoryChildAddressTaskChunks.length > 0) {\n              const total = intervalSum(requiredFactoryChildAddressIntervals);\n              this.common.logger.debug({\n                service: \"historical\",\n                msg: `Added '${this.network.name}' FACTORY_CHILD_ADDRESS tasks for '${source.contractName}' over a ${total} block range`,\n              });\n            }\n\n            const targetFactoryChildAddressBlockCount =\n              endBlock - startBlock + 1;\n            const cachedFactoryChildAddressBlockCount =\n              targetFactoryChildAddressBlockCount -\n              intervalSum(requiredFactoryChildAddressIntervals);\n\n            this.common.metrics.ponder_historical_total_blocks.set(\n              {\n                network: this.network.name,\n                source: `${source.contractName}_factory`,\n                type: \"trace\",\n              },\n              targetFactoryChildAddressBlockCount,\n            );\n            this.common.metrics.ponder_historical_cached_blocks.set(\n              {\n                network: this.network.name,\n                source: `${source.contractName}_factory`,\n                type: \"trace\",\n              },\n              cachedFactoryChildAddressBlockCount,\n            );\n\n            const completedFactoryTraceFilterIntervals =\n              await this.syncStore.getFactoryTraceFilterIntervals({\n                chainId: source.chainId,\n                factory: source.criteria,\n              });\n            const factoryTraceFilterProgressTracker = new ProgressTracker({\n              target: [startBlock, endBlock],\n              completed: completedFactoryTraceFilterIntervals,\n            });\n            this.factoryTraceFilterProgressTrackers[source.id] =\n              factoryTraceFilterProgressTracker;\n\n            // Only add factory trace filter tasks for any intervals where the\n            // child address tasks are completed, but the factory trace filter tasks are not,\n            // because these won't be added automatically by child address tasks.\n            const requiredFactoryTraceFilterIntervals =\n              factoryTraceFilterProgressTracker.getRequired();\n            const missingFactoryTraceFilterIntervals = intervalDifference(\n              requiredFactoryTraceFilterIntervals,\n              requiredFactoryChildAddressIntervals,\n            );\n\n            const missingFactoryTraceFilterTaskChunks = getChunks({\n              intervals: missingFactoryTraceFilterIntervals,\n              maxChunkSize: TRACE_FILTER_CHUNK_SIZE,\n            });\n\n            for (const [\n              fromBlock,\n              toBlock,\n            ] of missingFactoryTraceFilterTaskChunks) {\n              this.queue.addTask(\n                {\n                  kind: \"FACTORY_TRACE_FILTER\",\n                  factoryTraceFilter: source,\n                  fromBlock,\n                  toBlock,\n                },\n                { priority: Number.MAX_SAFE_INTEGER - fromBlock },\n              );\n            }\n            if (missingFactoryTraceFilterTaskChunks.length > 0) {\n              const total = intervalSum(missingFactoryTraceFilterIntervals);\n              this.common.logger.debug({\n                service: \"historical\",\n                msg: `Added '${this.network.name}' FACTORY_TRACE_FILTER tasks for '${source.contractName}' over a ${total} block range`,\n              });\n            }\n\n            const targetFactoryTraceFilterBlockCount =\n              endBlock - startBlock + 1;\n            const cachedFactoryTraceFilterBlockCount =\n              targetFactoryTraceFilterBlockCount -\n              intervalSum(requiredFactoryTraceFilterIntervals);\n\n            this.common.metrics.ponder_historical_total_blocks.set(\n              {\n                network: this.network.name,\n                source: source.contractName,\n                type: \"trace\",\n              },\n              targetFactoryTraceFilterBlockCount,\n            );\n            this.common.metrics.ponder_historical_cached_blocks.set(\n              {\n                network: this.network.name,\n                source: source.contractName,\n                type: \"trace\",\n              },\n              cachedFactoryTraceFilterBlockCount,\n            );\n\n            // Use factory trace filter progress for the logger because it better represents\n            // user-facing progress.\n            const cacheRate = Math.min(\n              1,\n              cachedFactoryTraceFilterBlockCount /\n                (targetFactoryTraceFilterBlockCount || 1),\n            );\n            this.common.logger.info({\n              service: \"historical\",\n              msg: `Started syncing '${this.network.name}' call traces for '${\n                source.contractName\n              }' with ${formatPercentage(cacheRate)} cached`,\n            });\n          }\n          break;\n\n        case \"block\":\n          {\n            const completedBlockFilterIntervals =\n              await this.syncStore.getBlockFilterIntervals({\n                chainId: source.chainId,\n                blockFilter: source.criteria,\n              });\n            const blockFilterProgressTracker = new ProgressTracker({\n              target: [startBlock, endBlock],\n              completed: completedBlockFilterIntervals,\n            });\n            this.blockFilterProgressTrackers[source.id] =\n              blockFilterProgressTracker;\n\n            const requiredBlockFilterIntervals =\n              blockFilterProgressTracker.getRequired();\n\n            // block filters are chunked into intervals to avoid unmanageable\n            // amounts of block callbacks being added at once.\n\n            const blockFilterTaskChunks = getChunks({\n              intervals: requiredBlockFilterIntervals,\n              maxChunkSize: this.network.defaultMaxBlockRange,\n            });\n\n            for (const [fromBlock, toBlock] of blockFilterTaskChunks) {\n              this.queue.addTask(\n                {\n                  kind: \"BLOCK_FILTER\",\n                  blockFilter: source,\n                  fromBlock,\n                  toBlock,\n                },\n                { priority: Number.MAX_SAFE_INTEGER - fromBlock },\n              );\n            }\n            if (blockFilterTaskChunks.length > 0) {\n              const total = intervalSum(requiredBlockFilterIntervals);\n              this.common.logger.debug({\n                service: \"historical\",\n                msg: `Added '${this.network.name}' BLOCK_FILTER tasks for '${source.sourceName}' over a ${total} block range`,\n              });\n            }\n\n            const targetBlockCount = endBlock - startBlock + 1;\n            const cachedBlockCount =\n              targetBlockCount - intervalSum(requiredBlockFilterIntervals);\n\n            this.common.metrics.ponder_historical_total_blocks.set(\n              {\n                network: this.network.name,\n                source: source.sourceName,\n                type: \"block\",\n              },\n              targetBlockCount,\n            );\n            this.common.metrics.ponder_historical_cached_blocks.set(\n              {\n                network: this.network.name,\n                source: source.sourceName,\n                type: \"block\",\n              },\n              cachedBlockCount,\n            );\n\n            this.common.logger.info({\n              service: \"historical\",\n              msg: `Started syncing '${this.network.name}' blocks for '${\n                source.sourceName\n              }' with ${formatPercentage(\n                Math.min(1, cachedBlockCount / (targetBlockCount || 1)),\n              )} cached`,\n            });\n          }\n          break;\n\n        default:\n          never(source);\n      }\n    }\n  }\n\n  start() {\n    this.common.metrics.ponder_historical_start_timestamp.set(Date.now());\n\n    // Emit status update logs on an interval for each active log filter.\n    this.progressLogInterval = setInterval(async () => {\n      const historical = await getHistoricalSyncProgress(this.common.metrics);\n\n      historical.sources.forEach(\n        ({ networkName, sourceName, progress, eta }) => {\n          if (progress === 1 || networkName !== this.network.name) return;\n          this.common.logger.info({\n            service: \"historical\",\n            msg: `Syncing '${this.network.name}' for '${sourceName}' with ${formatPercentage(\n              progress ?? 0,\n            )} complete${eta !== undefined ? ` and ~${formatEta(eta)} remaining` : \"\"}`,\n          });\n        },\n      );\n    }, 10_000);\n\n    // Edge case: If there are no tasks in the queue, this means the entire\n    // requested range was cached, so the sync is complete.\n    if (this.queue.size === 0) {\n      clearInterval(this.progressLogInterval);\n      this.common.logger.info({\n        service: \"historical\",\n        msg: `Finished '${this.network.name}' historical sync`,\n      });\n      this.emit(\"syncComplete\");\n    }\n\n    this.queue.start();\n  }\n\n  kill = () => {\n    this.isShuttingDown = true;\n    clearInterval(this.progressLogInterval);\n    this.queue.pause();\n    this.queue.clear();\n    this.common.logger.debug({\n      service: \"historical\",\n      msg: `Killed '${this.network.name}' historical sync`,\n    });\n  };\n\n  onIdle = () =>\n    new Promise((resolve) =>\n      setImmediate(() => this.queue.onIdle().then(resolve)),\n    );\n\n  private buildQueue = () => {\n    const worker: Worker<HistoricalSyncTask> = async ({ task, queue }) => {\n      switch (task.kind) {\n        case \"FACTORY_CHILD_ADDRESS\": {\n          await this.factoryChildAddressTaskWorker(task);\n          break;\n        }\n        case \"LOG_FILTER\": {\n          await this.logFilterTaskWorker(task);\n          break;\n        }\n        case \"FACTORY_LOG_FILTER\": {\n          await this.factoryLogFilterTaskWorker(task);\n          break;\n        }\n        case \"TRACE_FILTER\": {\n          await this.traceFilterTaskWorker(task);\n          break;\n        }\n        case \"FACTORY_TRACE_FILTER\": {\n          await this.factoryTraceFilterTaskWorker(task);\n          break;\n        }\n        case \"BLOCK_FILTER\": {\n          await this.blockFilterTaskWorker(task);\n          break;\n        }\n        case \"BLOCK\": {\n          await this.blockTaskWorker(task);\n          break;\n        }\n        default:\n          never(task);\n      }\n\n      // If this is not the final task, return.\n      if (queue.size > 0 || queue.pending > 1) return;\n      // If this is the final task but the kill() method has been called, do nothing.\n      if (this.isShuttingDown) return;\n\n      // If this is the final task, run the cleanup/completion logic.\n      clearInterval(this.progressLogInterval);\n      const startTimestamp =\n        (await this.common.metrics.ponder_historical_start_timestamp.get())\n          .values?.[0]?.value ?? Date.now();\n      const duration = Date.now() - startTimestamp;\n      this.common.logger.info({\n        service: \"historical\",\n        msg: `Finished '${this.network.name}' historical sync in ${formatEta(duration)}`,\n      });\n      this.emit(\"syncComplete\");\n    };\n\n    const queue = createQueue<HistoricalSyncTask>({\n      worker,\n      options: {\n        concurrency: this.network.maxHistoricalTaskConcurrency,\n        autoStart: false,\n      },\n      onError: ({ error, task, queue }) => {\n        if (this.isShuttingDown) return;\n\n        switch (task.kind) {\n          case \"FACTORY_CHILD_ADDRESS\": {\n            this.common.logger.warn({\n              service: \"historical\",\n              msg: `Failed to sync '${this.network.name}' child address logs for '${task.factory.contractName}' from block ${task.fromBlock} to ${task.toBlock}`,\n              error,\n            });\n            const priority = Number.MAX_SAFE_INTEGER - task.fromBlock;\n            queue.addTask({ ...task }, { priority });\n            break;\n          }\n          case \"LOG_FILTER\": {\n            this.common.logger.warn({\n              service: \"historical\",\n              msg: `Failed to sync '${this.network.name}' logs for '${task.logFilter.contractName}' from block ${task.fromBlock} to ${task.toBlock}`,\n              error,\n            });\n            const priority = Number.MAX_SAFE_INTEGER - task.fromBlock;\n            queue.addTask({ ...task }, { priority });\n            break;\n          }\n          case \"FACTORY_LOG_FILTER\": {\n            this.common.logger.warn({\n              service: \"historical\",\n              msg: `Failed to sync '${this.network.name}' logs for '${task.factoryLogFilter.contractName}' from block ${task.fromBlock} to ${task.toBlock}`,\n              error,\n            });\n            const priority = Number.MAX_SAFE_INTEGER - task.fromBlock;\n            queue.addTask({ ...task }, { priority });\n            break;\n          }\n          case \"TRACE_FILTER\": {\n            this.common.logger.warn({\n              service: \"historical\",\n              msg: `Failed to sync '${this.network.name}' call traces for '${task.traceFilter.contractName}' from block ${task.fromBlock} to ${task.toBlock}`,\n              error,\n            });\n            const priority = Number.MAX_SAFE_INTEGER - task.fromBlock;\n            queue.addTask({ ...task }, { priority });\n            break;\n          }\n\n          case \"FACTORY_TRACE_FILTER\": {\n            this.common.logger.warn({\n              service: \"historical\",\n              msg: `Failed to sync '${this.network.name}' call traces for '${task.factoryTraceFilter.contractName}' from block ${task.fromBlock} to ${task.toBlock}`,\n              error,\n            });\n            const priority = Number.MAX_SAFE_INTEGER - task.fromBlock;\n            queue.addTask({ ...task }, { priority });\n            break;\n          }\n          case \"BLOCK_FILTER\": {\n            this.common.logger.warn({\n              service: \"historical\",\n              msg: `Failed to sync '${this.network.name}' blocks for '${task.blockFilter.sourceName}' from block ${task.fromBlock} to ${task.toBlock}`,\n              error,\n            });\n            const priority = Number.MAX_SAFE_INTEGER - task.fromBlock;\n            queue.addTask({ ...task }, { priority });\n            break;\n          }\n          case \"BLOCK\": {\n            this.common.logger.warn({\n              service: \"historical\",\n              msg: `Failed to sync '${this.network.name}' block ${task.blockNumber}`,\n              error,\n            });\n            const priority = Number.MAX_SAFE_INTEGER - task.blockNumber;\n            queue.addTask({ ...task }, { priority });\n            break;\n          }\n\n          default:\n            never(task);\n        }\n\n        this.common.logger.warn({\n          service: \"historical\",\n          msg: `Retrying failed '${this.network.name}' sync task`,\n        });\n      },\n    });\n\n    return queue;\n  };\n\n  private logFilterTaskWorker = async ({\n    logFilter,\n    fromBlock,\n    toBlock,\n  }: LogFilterTask) => {\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Starting '${this.network.name}' LOG_FILTER task for '${logFilter.contractName}' from block ${fromBlock} to ${toBlock}`,\n    });\n\n    const logs = await _eth_getLogs(\n      { requestQueue: this.requestQueue },\n      {\n        address: logFilter.criteria.address,\n        topics: logFilter.criteria.topics,\n        fromBlock: toHex(fromBlock),\n        toBlock: toHex(toBlock),\n      },\n    );\n    const logIntervals = this.buildLogIntervals({ fromBlock, toBlock, logs });\n\n    for (const logInterval of logIntervals) {\n      const { startBlock, endBlock } = logInterval;\n\n      if (this.blockCallbacks[endBlock] === undefined)\n        this.blockCallbacks[endBlock] = [];\n\n      this.blockCallbacks[endBlock]!.push(async (block) => {\n        const { transactionHashes } = logInterval;\n        const transactions = block.transactions.filter((tx) =>\n          transactionHashes.has(tx.hash),\n        );\n        const transactionReceipts =\n          logFilter.criteria.includeTransactionReceipts === true\n            ? await Promise.all(\n                transactions.map((tx) =>\n                  _eth_getTransactionReceipt(\n                    { requestQueue: this.requestQueue },\n                    { hash: tx.hash },\n                  ),\n                ),\n              )\n            : [];\n\n        await this.syncStore.insertLogFilterInterval({\n          logs: logInterval.logs,\n          interval: {\n            startBlock: BigInt(logInterval.startBlock),\n            endBlock: BigInt(logInterval.endBlock),\n          },\n          logFilter: logFilter.criteria,\n          chainId: logFilter.chainId,\n          block,\n          transactions,\n          transactionReceipts,\n        });\n\n        this.common.metrics.ponder_historical_completed_blocks.inc(\n          {\n            network: this.network.name,\n            source: logFilter.contractName,\n            type: \"log\",\n          },\n          endBlock - startBlock + 1,\n        );\n      });\n    }\n\n    this.logFilterProgressTrackers[logFilter.id]!.addCompletedInterval([\n      fromBlock,\n      toBlock,\n    ]);\n\n    this.enqueueBlockTasks();\n\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Completed '${this.network.name}' LOG_FILTER task for '${logFilter.contractName}' from block ${fromBlock} to ${toBlock}`,\n    });\n  };\n\n  private factoryLogFilterTaskWorker = async ({\n    factoryLogFilter,\n    fromBlock,\n    toBlock,\n  }: FactoryLogFilterTask) => {\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Starting '${this.network.name}' FACTORY_LOG_FILTER task for '${factoryLogFilter.contractName}' from block ${fromBlock} to ${toBlock}`,\n    });\n\n    const iterator = this.syncStore.getFactoryChildAddresses({\n      chainId: factoryLogFilter.chainId,\n      factory: factoryLogFilter.criteria,\n      fromBlock: BigInt(factoryLogFilter.startBlock),\n      toBlock: BigInt(toBlock),\n    });\n\n    const logs: SyncLog[] = [];\n    for await (const childContractAddressBatch of iterator) {\n      const _logs = await _eth_getLogs(\n        { requestQueue: this.requestQueue },\n        {\n          address: childContractAddressBatch,\n          topics: factoryLogFilter.criteria.topics,\n          fromBlock: numberToHex(fromBlock),\n          toBlock: numberToHex(toBlock),\n        },\n      );\n      logs.push(..._logs);\n    }\n\n    const logIntervals = this.buildLogIntervals({ fromBlock, toBlock, logs });\n\n    for (const logInterval of logIntervals) {\n      const { startBlock, endBlock, logs, transactionHashes } = logInterval;\n\n      if (this.blockCallbacks[endBlock] === undefined)\n        this.blockCallbacks[endBlock] = [];\n\n      this.blockCallbacks[endBlock]!.push(async (block) => {\n        const transactions = block.transactions.filter((tx) =>\n          transactionHashes.has(tx.hash),\n        );\n        const transactionReceipts =\n          factoryLogFilter.criteria.includeTransactionReceipts === true\n            ? await Promise.all(\n                transactions.map((tx) =>\n                  _eth_getTransactionReceipt(\n                    { requestQueue: this.requestQueue },\n                    { hash: tx.hash },\n                  ),\n                ),\n              )\n            : [];\n\n        await this.syncStore.insertFactoryLogFilterInterval({\n          chainId: factoryLogFilter.chainId,\n          factory: factoryLogFilter.criteria,\n          block,\n          transactions,\n          transactionReceipts,\n          logs,\n          interval: {\n            startBlock: BigInt(startBlock),\n            endBlock: BigInt(endBlock),\n          },\n        });\n\n        this.common.metrics.ponder_historical_completed_blocks.inc(\n          {\n            network: this.network.name,\n            source: factoryLogFilter.contractName,\n            type: \"log\",\n          },\n          endBlock - startBlock + 1,\n        );\n      });\n    }\n\n    this.factoryLogFilterProgressTrackers[\n      factoryLogFilter.id\n    ]!.addCompletedInterval([fromBlock, toBlock]);\n\n    this.enqueueBlockTasks();\n\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Completed '${this.network.name}' FACTORY_LOG_FILTER task for '${factoryLogFilter.contractName}' from block ${fromBlock} to ${toBlock}`,\n    });\n  };\n\n  private factoryChildAddressTaskWorker = async ({\n    factory,\n    fromBlock,\n    toBlock,\n  }: FactoryChildAddressTask) => {\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Starting '${this.network.name}' FACTORY_CHILD_ADDRESS task for '${factory.contractName}' from block ${fromBlock} to ${toBlock}`,\n    });\n\n    const logs = await _eth_getLogs(\n      { requestQueue: this.requestQueue },\n      {\n        address: factory.criteria.address,\n        topics: [factory.criteria.eventSelector],\n        fromBlock: toHex(fromBlock),\n        toBlock: toHex(toBlock),\n      },\n    );\n\n    // Insert the new child address logs into the store.\n    await this.syncStore.insertFactoryChildAddressLogs({\n      chainId: factory.chainId,\n      logs,\n    });\n\n    // Register block callbacks for the child address logs. This is how\n    // the intervals will be recorded (marking the child address logs as\n    // cached on subsequent starts).\n    const logIntervals = this.buildLogIntervals({ fromBlock, toBlock, logs });\n    for (const logInterval of logIntervals) {\n      if (this.blockCallbacks[logInterval.endBlock] === undefined)\n        this.blockCallbacks[logInterval.endBlock] = [];\n\n      this.blockCallbacks[logInterval.endBlock]!.push(async (block) => {\n        const { transactionHashes } = logInterval;\n\n        const transactions = block.transactions.filter((tx) =>\n          transactionHashes.has(tx.hash),\n        );\n\n        await this.syncStore.insertLogFilterInterval({\n          logs: logInterval.logs,\n          interval: {\n            startBlock: BigInt(logInterval.startBlock),\n            endBlock: BigInt(logInterval.endBlock),\n          },\n          logFilter: {\n            address: factory.criteria.address,\n            topics: [factory.criteria.eventSelector],\n            includeTransactionReceipts: false,\n          },\n          chainId: factory.chainId,\n          block,\n          transactions,\n          transactionReceipts: [],\n        });\n      });\n    }\n\n    // Update the checkpoint, and if necessary, enqueue factory log filter tasks.\n    const { isUpdated, prevCheckpoint, newCheckpoint } =\n      this.factoryChildAddressProgressTrackers[\n        factory.id\n      ]!.addCompletedInterval([fromBlock, toBlock]);\n\n    switch (factory.type) {\n      case \"factoryLog\": {\n        if (isUpdated) {\n          // It's possible for the factory log filter to have already completed some or\n          // all of the block interval here. To avoid duplicates, only add intervals that\n          // are still marked as required.\n          const requiredIntervals = intervalIntersection(\n            [[prevCheckpoint + 1, newCheckpoint]],\n            this.factoryLogFilterProgressTrackers[factory.id]!.getRequired(),\n          );\n          const factoryLogFilterChunks = getChunks({\n            intervals: requiredIntervals,\n            maxChunkSize:\n              factory.maxBlockRange ?? this.network.defaultMaxBlockRange,\n          });\n\n          for (const [fromBlock, toBlock] of factoryLogFilterChunks) {\n            this.queue.addTask(\n              {\n                kind: \"FACTORY_LOG_FILTER\",\n                factoryLogFilter: factory,\n                fromBlock,\n                toBlock,\n              },\n              { priority: Number.MAX_SAFE_INTEGER - fromBlock },\n            );\n          }\n        }\n        this.common.metrics.ponder_historical_completed_blocks.inc(\n          {\n            network: this.network.name,\n            source: `${factory.contractName}_factory`,\n            type: \"log\",\n          },\n          toBlock - fromBlock + 1,\n        );\n        break;\n      }\n\n      case \"factoryCallTrace\": {\n        if (isUpdated) {\n          // It's possible for the factory log filter to have already completed some or\n          // all of the block interval here. To avoid duplicates, only add intervals that\n          // are still marked as required.\n          const requiredIntervals = intervalIntersection(\n            [[prevCheckpoint + 1, newCheckpoint]],\n            this.factoryTraceFilterProgressTrackers[factory.id]!.getRequired(),\n          );\n          const factoryTraceFilterChunks = getChunks({\n            intervals: requiredIntervals,\n            maxChunkSize: TRACE_FILTER_CHUNK_SIZE,\n          });\n\n          for (const [fromBlock, toBlock] of factoryTraceFilterChunks) {\n            this.queue.addTask(\n              {\n                kind: \"FACTORY_TRACE_FILTER\",\n                factoryTraceFilter: factory,\n                fromBlock,\n                toBlock,\n              },\n              { priority: Number.MAX_SAFE_INTEGER - fromBlock },\n            );\n          }\n        }\n        this.common.metrics.ponder_historical_completed_blocks.inc(\n          {\n            network: this.network.name,\n            source: `${factory.contractName}_factory`,\n            type: \"trace\",\n          },\n          toBlock - fromBlock + 1,\n        );\n        break;\n      }\n\n      default:\n        never(factory);\n    }\n\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Completed '${this.network.name}' FACTORY_CHILD_ADDRESS task for '${factory.contractName}' from block ${fromBlock} to ${toBlock}`,\n    });\n  };\n\n  private blockFilterTaskWorker = async ({\n    blockFilter,\n    fromBlock,\n    toBlock,\n  }: BlockFilterTask) => {\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Starting '${this.network.name}' BLOCK_FILTER task for '${blockFilter.sourceName}' from block ${fromBlock} to ${toBlock}`,\n    });\n\n    const baseOffset =\n      (fromBlock - blockFilter.criteria.offset) % blockFilter.criteria.interval;\n    const offset =\n      baseOffset === 0 ? 0 : blockFilter.criteria.interval - baseOffset;\n\n    // Determine which blocks are matched by the block filter, and add a callback for\n    // each block. A block callback, and subsequent \"eth_getBlock\" request can be\n    // skipped if the block is already present in the database.\n\n    const requiredBlocks: number[] = [];\n    for (\n      let blockNumber = fromBlock + offset;\n      blockNumber <= toBlock;\n      blockNumber += blockFilter.criteria.interval\n    ) {\n      requiredBlocks.push(blockNumber);\n    }\n\n    // If toBlock is not already required, add it. This is necessary\n    // to mark the full block range of the eth_getLogs request as cached.\n    if (!requiredBlocks.includes(toBlock)) {\n      requiredBlocks.push(toBlock);\n    }\n\n    let prevBlockNumber = fromBlock;\n    for (const blockNumber of requiredBlocks) {\n      const hasBlock = await this.syncStore.getBlock({\n        chainId: blockFilter.chainId,\n        blockNumber,\n      });\n\n      const startBlock = prevBlockNumber;\n      const endBlock = blockNumber;\n\n      if (hasBlock) {\n        await this.syncStore.insertBlockFilterInterval({\n          chainId: blockFilter.chainId,\n          blockFilter: blockFilter.criteria,\n          interval: {\n            startBlock: BigInt(startBlock),\n            endBlock: BigInt(endBlock),\n          },\n        });\n\n        this.common.metrics.ponder_historical_completed_blocks.inc(\n          {\n            network: this.network.name,\n            source: blockFilter.sourceName,\n            type: \"block\",\n          },\n          endBlock - startBlock + 1,\n        );\n      } else {\n        if (this.blockCallbacks[blockNumber] === undefined)\n          this.blockCallbacks[blockNumber] = [];\n\n        this.blockCallbacks[blockNumber]!.push(async (block) => {\n          await this.syncStore.insertBlockFilterInterval({\n            chainId: blockFilter.chainId,\n            blockFilter: blockFilter.criteria,\n            block,\n            interval: {\n              startBlock: BigInt(startBlock),\n              endBlock: BigInt(endBlock),\n            },\n          });\n\n          this.common.metrics.ponder_historical_completed_blocks.inc(\n            {\n              network: this.network.name,\n              source: blockFilter.sourceName,\n              type: \"block\",\n            },\n            endBlock - startBlock + 1,\n          );\n        });\n      }\n\n      prevBlockNumber = blockNumber + 1;\n    }\n\n    this.blockFilterProgressTrackers[blockFilter.id]!.addCompletedInterval([\n      fromBlock,\n      toBlock,\n    ]);\n\n    this.enqueueBlockTasks();\n\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Completed '${this.network.name}' BLOCK_FILTER task for '${blockFilter.sourceName}' from block ${fromBlock} to ${toBlock}`,\n    });\n  };\n\n  private traceFilterTaskWorker = async ({\n    traceFilter,\n    fromBlock,\n    toBlock,\n  }: TraceFilterTask) => {\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Starting '${this.network.name}' TRACE_FILTER task for '${traceFilter.contractName}' from block ${fromBlock} to ${toBlock}`,\n    });\n\n    const traces = await _trace_filter(\n      { requestQueue: this.requestQueue },\n      {\n        fromBlock,\n        toBlock,\n        fromAddress: traceFilter.criteria.fromAddress,\n        toAddress: traceFilter.criteria.toAddress,\n      },\n    ).then(\n      (traces) => traces.filter((t) => t.type === \"call\") as SyncCallTrace[],\n    );\n\n    // Request transactionReceipts to check for reverted transactions.\n    const transactionReceipts = await Promise.all(\n      dedupe(traces.map((t) => t.transactionHash)).map((hash) =>\n        _eth_getTransactionReceipt(\n          {\n            requestQueue: this.requestQueue,\n          },\n          {\n            hash,\n          },\n        ),\n      ),\n    );\n\n    const revertedTransactions = new Set<Hash>();\n    for (const receipt of transactionReceipts) {\n      if (receipt.status === \"0x0\") {\n        revertedTransactions.add(receipt.transactionHash);\n      }\n    }\n\n    const persistentTraces = traces.filter(\n      (trace) => revertedTransactions.has(trace.transactionHash) === false,\n    );\n\n    const tracesByBlockNumber: Record<number, SyncCallTrace[] | undefined> = {};\n    const txHashesByBlockNumber: Record<number, Set<Hash> | undefined> = {};\n\n    for (const trace of persistentTraces) {\n      const blockNumber = hexToNumber(trace.blockNumber);\n\n      if (tracesByBlockNumber[blockNumber] === undefined) {\n        tracesByBlockNumber[blockNumber] = [];\n      }\n      if (txHashesByBlockNumber[blockNumber] === undefined) {\n        txHashesByBlockNumber[blockNumber] = new Set<Hash>();\n      }\n\n      tracesByBlockNumber[blockNumber]!.push(trace);\n      txHashesByBlockNumber[blockNumber]!.add(trace.transactionHash);\n    }\n\n    const requiredBlocks = Object.keys(txHashesByBlockNumber)\n      .map(Number)\n      .sort((a, b) => a - b);\n\n    // If toBlock is not already required, add it. This is necessary\n    // to mark the full block range of the trace_filter request as cached.\n    if (!requiredBlocks.includes(toBlock)) {\n      requiredBlocks.push(toBlock);\n    }\n\n    const traceIntervals: {\n      startBlock: number;\n      endBlock: number;\n      traces: SyncCallTrace[];\n      transactionHashes: Set<Hash>;\n    }[] = [];\n\n    let prev = fromBlock;\n    for (const blockNumber of requiredBlocks) {\n      traceIntervals.push({\n        startBlock: prev,\n        endBlock: blockNumber,\n        traces: tracesByBlockNumber[blockNumber] ?? [],\n        transactionHashes: txHashesByBlockNumber[blockNumber] ?? new Set(),\n      });\n      prev = blockNumber + 1;\n    }\n\n    for (const traceInterval of traceIntervals) {\n      const { startBlock, endBlock } = traceInterval;\n\n      if (this.blockCallbacks[endBlock] === undefined)\n        this.blockCallbacks[endBlock] = [];\n\n      this.blockCallbacks[endBlock]!.push(async (block) => {\n        const { transactionHashes } = traceInterval;\n        const transactions = block.transactions.filter((tx) =>\n          transactionHashes.has(tx.hash),\n        );\n\n        await this.syncStore.insertTraceFilterInterval({\n          traces: traceInterval.traces,\n          interval: {\n            startBlock: BigInt(startBlock),\n            endBlock: BigInt(endBlock),\n          },\n          traceFilter: traceFilter.criteria,\n          chainId: traceFilter.chainId,\n          block,\n          transactions,\n          // trace intervals always include transaction receipts because\n          // the transactions receipts are already needed determine the\n          // persistence of a trace.\n          transactionReceipts: transactionReceipts.filter((txr) =>\n            transactionHashes.has(txr.transactionHash),\n          ),\n        });\n\n        this.common.metrics.ponder_historical_completed_blocks.inc(\n          {\n            network: this.network.name,\n            source: traceFilter.contractName,\n            type: \"trace\",\n          },\n          endBlock - startBlock + 1,\n        );\n      });\n    }\n    this.traceFilterProgressTrackers[traceFilter.id]!.addCompletedInterval([\n      fromBlock,\n      toBlock,\n    ]);\n\n    this.enqueueBlockTasks();\n\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Completed '${this.network.name}' TRACE_FILTER task for '${traceFilter.contractName}' from block ${fromBlock} to ${toBlock}`,\n    });\n  };\n\n  private factoryTraceFilterTaskWorker = async ({\n    factoryTraceFilter,\n    fromBlock,\n    toBlock,\n  }: FactoryTraceFilterTask) => {\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Starting '${this.network.name}' FACTORY_TRACE_FILTER task for '${factoryTraceFilter.contractName}' from block ${fromBlock} to ${toBlock}`,\n    });\n\n    const iterator = this.syncStore.getFactoryChildAddresses({\n      chainId: factoryTraceFilter.chainId,\n      factory: factoryTraceFilter.criteria,\n      fromBlock: BigInt(factoryTraceFilter.startBlock),\n      toBlock: BigInt(toBlock),\n    });\n\n    const traces: SyncCallTrace[] = [];\n    for await (const childContractAddressBatch of iterator) {\n      const _traces = await _trace_filter(\n        { requestQueue: this.requestQueue },\n        {\n          fromBlock,\n          toBlock,\n          fromAddress: factoryTraceFilter.criteria.fromAddress,\n          toAddress: childContractAddressBatch,\n        },\n      ).then(\n        (traces) => traces.filter((t) => t.type === \"call\") as SyncCallTrace[],\n      );\n      traces.push(..._traces);\n    }\n\n    // Request transactionReceipts to check for reverted transactions.\n    const transactionReceipts = await Promise.all(\n      dedupe(traces.map((t) => t.transactionHash)).map((hash) =>\n        _eth_getTransactionReceipt(\n          {\n            requestQueue: this.requestQueue,\n          },\n          {\n            hash,\n          },\n        ),\n      ),\n    );\n\n    const revertedTransactions = new Set<Hash>();\n    for (const receipt of transactionReceipts) {\n      if (receipt.status === \"0x0\") {\n        revertedTransactions.add(receipt.transactionHash);\n      }\n    }\n\n    const persistentTraces = traces.filter(\n      (trace) => revertedTransactions.has(trace.transactionHash) === false,\n    );\n\n    const tracesByBlockNumber: Record<number, SyncCallTrace[] | undefined> = {};\n    const txHashesByBlockNumber: Record<number, Set<Hash> | undefined> = {};\n\n    for (const trace of persistentTraces) {\n      const blockNumber = hexToNumber(trace.blockNumber);\n\n      if (tracesByBlockNumber[blockNumber] === undefined) {\n        tracesByBlockNumber[blockNumber] = [];\n      }\n      if (txHashesByBlockNumber[blockNumber] === undefined) {\n        txHashesByBlockNumber[blockNumber] = new Set<Hash>();\n      }\n\n      tracesByBlockNumber[blockNumber]!.push(trace);\n      txHashesByBlockNumber[blockNumber]!.add(trace.transactionHash);\n    }\n\n    const requiredBlocks = Object.keys(txHashesByBlockNumber)\n      .map(Number)\n      .sort((a, b) => a - b);\n\n    // If toBlock is not already required, add it. This is necessary\n    // to mark the full block range of the trace_filter request as cached.\n    if (!requiredBlocks.includes(toBlock)) {\n      requiredBlocks.push(toBlock);\n    }\n\n    const traceIntervals: {\n      startBlock: number;\n      endBlock: number;\n      traces: SyncCallTrace[];\n      transactionHashes: Set<Hash>;\n    }[] = [];\n\n    let prev = fromBlock;\n    for (const blockNumber of requiredBlocks) {\n      traceIntervals.push({\n        startBlock: prev,\n        endBlock: blockNumber,\n        traces: tracesByBlockNumber[blockNumber] ?? [],\n        transactionHashes: txHashesByBlockNumber[blockNumber] ?? new Set(),\n      });\n      prev = blockNumber + 1;\n    }\n\n    for (const traceInterval of traceIntervals) {\n      const { startBlock, endBlock } = traceInterval;\n\n      if (this.blockCallbacks[endBlock] === undefined)\n        this.blockCallbacks[endBlock] = [];\n\n      this.blockCallbacks[endBlock]!.push(async (block) => {\n        const { transactionHashes } = traceInterval;\n        const transactions = block.transactions.filter((tx) =>\n          transactionHashes.has(tx.hash),\n        );\n\n        await this.syncStore.insertFactoryTraceFilterInterval({\n          chainId: factoryTraceFilter.chainId,\n          factory: factoryTraceFilter.criteria,\n          block,\n          transactions,\n          // factory trace intervals always include transaction receipts because\n          // the transactions receipts are already needed determine the\n          // persistence of a trace.\n          transactionReceipts: transactionReceipts.filter((txr) =>\n            transactionHashes.has(txr.transactionHash),\n          ),\n          traces: traceInterval.traces,\n          interval: {\n            startBlock: BigInt(startBlock),\n            endBlock: BigInt(endBlock),\n          },\n        });\n\n        this.common.metrics.ponder_historical_completed_blocks.inc(\n          {\n            network: this.network.name,\n            source: factoryTraceFilter.contractName,\n            type: \"trace\",\n          },\n          endBlock - startBlock + 1,\n        );\n      });\n    }\n\n    this.factoryTraceFilterProgressTrackers[\n      factoryTraceFilter.id\n    ]!.addCompletedInterval([fromBlock, toBlock]);\n\n    this.enqueueBlockTasks();\n\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Completed '${this.network.name}' FACTORY_TRACE_FILTER task for '${factoryTraceFilter.contractName}' from block ${fromBlock} to ${toBlock}`,\n    });\n  };\n\n  private blockTaskWorker = async ({ blockNumber, callbacks }: BlockTask) => {\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Starting '${this.network.name}' BLOCK task for block ${blockNumber} with ${callbacks.length} callbacks`,\n    });\n\n    const block = await _eth_getBlockByNumber(\n      { requestQueue: this.requestQueue },\n      {\n        blockNumber,\n      },\n    );\n\n    for (const callback of callbacks) {\n      await callback(block);\n    }\n\n    const newBlockCheckpoint = this.blockProgressTracker.addCompletedBlock({\n      blockNumber,\n      blockTimestamp: hexToNumber(block.timestamp),\n    });\n\n    if (newBlockCheckpoint) {\n      this.debouncedEmitCheckpoint.call({\n        ...maxCheckpoint,\n        blockTimestamp: newBlockCheckpoint.blockTimestamp,\n        chainId: BigInt(this.network.chainId),\n        blockNumber: BigInt(newBlockCheckpoint.blockNumber),\n      });\n    }\n\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Completed '${this.network.name}' BLOCK task for block ${blockNumber} with ${callbacks.length} callbacks`,\n    });\n  };\n\n  private buildLogIntervals = ({\n    fromBlock,\n    toBlock,\n    logs,\n  }: {\n    fromBlock: number;\n    toBlock: number;\n    logs: SyncLog[];\n  }) => {\n    const logsByBlockNumber: Record<number, SyncLog[] | undefined> = {};\n    const txHashesByBlockNumber: Record<number, Set<Hash> | undefined> = {};\n\n    logs.forEach((log) => {\n      const blockNumber = hexToNumber(log.blockNumber!);\n      (txHashesByBlockNumber[blockNumber] ||= new Set<Hash>()).add(\n        log.transactionHash!,\n      );\n      (logsByBlockNumber[blockNumber] ||= []).push(log);\n    });\n\n    const requiredBlocks = Object.keys(txHashesByBlockNumber)\n      .map(Number)\n      .sort((a, b) => a - b);\n\n    // If toBlock is not already required, add it. This is necessary\n    // to mark the full block range of the eth_getLogs request as cached.\n    if (!requiredBlocks.includes(toBlock)) {\n      requiredBlocks.push(toBlock);\n    }\n\n    const requiredIntervals: {\n      startBlock: number;\n      endBlock: number;\n      logs: SyncLog[];\n      transactionHashes: Set<Hash>;\n    }[] = [];\n\n    let prev = fromBlock;\n    for (const blockNumber of requiredBlocks) {\n      requiredIntervals.push({\n        startBlock: prev,\n        endBlock: blockNumber,\n        logs: logsByBlockNumber[blockNumber] ?? [],\n        transactionHashes: txHashesByBlockNumber[blockNumber] ?? new Set(),\n      });\n      prev = blockNumber + 1;\n    }\n\n    return requiredIntervals;\n  };\n\n  private enqueueBlockTasks = () => {\n    // If a source has an endBlock and is completed, its checkpoint\n    // will be equal to its endBlock. This poses a problem if other sources\n    // don't have an endBlock and are still in progress, because this value\n    // will get \"stuck\" at the endBlock. To avoid this, filter out any sources\n    // that have no more required intervals.\n    const blockTasksCanBeEnqueuedTo = Math.min(\n      ...[\n        ...Object.values(this.logFilterProgressTrackers),\n        ...Object.values(this.factoryChildAddressProgressTrackers),\n        ...Object.values(this.factoryLogFilterProgressTrackers),\n        ...Object.values(this.traceFilterProgressTrackers),\n        ...Object.values(this.factoryTraceFilterProgressTrackers),\n        ...Object.values(this.blockFilterProgressTrackers),\n      ]\n        .filter((i) => i.getRequired().length > 0)\n        .map((i) => i.getCheckpoint()),\n    );\n\n    if (blockTasksCanBeEnqueuedTo > this.blockTasksEnqueuedCheckpoint) {\n      const newBlocks = Object.keys(this.blockCallbacks)\n        .map(Number)\n        .filter((blockNumber) => blockNumber <= blockTasksCanBeEnqueuedTo);\n\n      this.blockProgressTracker.addPendingBlocks({ blockNumbers: newBlocks });\n\n      for (const blockNumber of newBlocks) {\n        this.queue.addTask(\n          {\n            kind: \"BLOCK\",\n            blockNumber,\n            callbacks: this.blockCallbacks[blockNumber]!,\n          },\n          { priority: Number.MAX_SAFE_INTEGER - blockNumber },\n        );\n        delete this.blockCallbacks[blockNumber];\n      }\n\n      this.blockTasksEnqueuedCheckpoint = blockTasksCanBeEnqueuedTo;\n    }\n  };\n\n  private debouncedEmitCheckpoint = debounce(\n    HISTORICAL_CHECKPOINT_EMIT_INTERVAL,\n    (checkpoint: Checkpoint) => {\n      this.emit(\"historicalCheckpoint\", checkpoint);\n    },\n  );\n}\n","import type { Common } from \"@/common/common.js\";\nimport type { Network } from \"@/config/networks.js\";\nimport {\n  type BlockSource,\n  type CallTraceSource,\n  type EventSource,\n  type FactoryCallTraceSource,\n  type FactoryLogSource,\n  type LogSource,\n  sourceIsBlock,\n  sourceIsCallTrace,\n  sourceIsFactoryCallTrace,\n  sourceIsFactoryLog,\n  sourceIsLog,\n} from \"@/config/sources.js\";\nimport type { SyncStore } from \"@/sync-store/store.js\";\nimport {\n  type SyncBlock,\n  type SyncCallTrace,\n  type SyncLog,\n  _eth_getBlockByHash,\n  _eth_getBlockByNumber,\n  _eth_getLogs,\n  _eth_getTransactionReceipt,\n  _trace_block,\n} from \"@/sync/index.js\";\nimport { type Checkpoint, maxCheckpoint } from \"@/utils/checkpoint.js\";\nimport { range } from \"@/utils/range.js\";\nimport type { RequestQueue } from \"@/utils/requestQueue.js\";\nimport { wait } from \"@/utils/wait.js\";\nimport { type Queue, createQueue } from \"@ponder/common\";\nimport { type Address, type Hash, hexToNumber } from \"viem\";\nimport { isMatchedLogInBloomFilter, zeroLogsBloom } from \"./bloom.js\";\nimport { filterCallTraces, filterLogs } from \"./filter.js\";\nimport { type LightBlock, syncBlockToLightBlock } from \"./format.js\";\n\nexport type Service = {\n  // static\n  common: Common;\n  syncStore: SyncStore;\n  network: Network;\n  requestQueue: RequestQueue;\n  sources: EventSource[];\n\n  // state\n  isKilled: boolean;\n  finalizedBlock: LightBlock;\n  /**\n   * Blocks and logs that have been ingested and are\n   * waiting to be finalized. It is an invariant that\n   * all blocks are linked to each other,\n   * `parentHash` => `hash`.\n   */\n  localChain: LightBlock[];\n  queue: Queue<void, SyncBlock> | undefined;\n  consecutiveErrors: number;\n\n  // callbacks\n  onEvent: (event: RealtimeSyncEvent) => void;\n  onFatalError: (error: Error) => void;\n\n  // derived static\n  hasTransactionReceiptSource: boolean;\n  logSources: LogSource[];\n  factoryLogSources: FactoryLogSource[];\n  callTraceSources: CallTraceSource[];\n  factoryCallTraceSources: FactoryCallTraceSource[];\n  blockSources: BlockSource[];\n};\n\nexport type RealtimeSyncEvent =\n  | {\n      type: \"reorg\";\n      chainId: number;\n      safeCheckpoint: Checkpoint;\n    }\n  | {\n      type: \"checkpoint\";\n      chainId: number;\n      checkpoint: Checkpoint;\n    }\n  | {\n      type: \"finalize\";\n      chainId: number;\n      checkpoint: Checkpoint;\n    };\n\nconst ERROR_TIMEOUT = [\n  1, 2, 5, 10, 30, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n] as const;\nconst MAX_QUEUED_BLOCKS = 25;\n\nexport const create = ({\n  common,\n  syncStore,\n  network,\n  requestQueue,\n  sources,\n  finalizedBlock,\n  onEvent,\n  onFatalError,\n}: {\n  common: Common;\n  syncStore: SyncStore;\n  network: Network;\n  requestQueue: RequestQueue;\n  sources: EventSource[];\n  finalizedBlock: SyncBlock;\n  onEvent: (event: RealtimeSyncEvent) => void;\n  onFatalError: (error: Error) => void;\n}): Service => {\n  const logSources = sources.filter(sourceIsLog);\n  const factoryLogSources = sources.filter(sourceIsFactoryLog);\n  const blockSources = sources.filter(sourceIsBlock);\n  const callTraceSources = sources.filter(sourceIsCallTrace);\n  const factoryCallTraceSources = sources.filter(sourceIsFactoryCallTrace);\n\n  return {\n    common,\n    syncStore,\n    network,\n    requestQueue,\n    sources,\n    isKilled: false,\n    finalizedBlock: syncBlockToLightBlock(finalizedBlock),\n    localChain: [],\n    queue: undefined,\n    consecutiveErrors: 0,\n    onEvent,\n    onFatalError,\n    hasTransactionReceiptSource:\n      logSources.some((s) => s.criteria.includeTransactionReceipts) ||\n      factoryLogSources.some((s) => s.criteria.includeTransactionReceipts),\n    logSources,\n    factoryLogSources,\n    callTraceSources,\n    factoryCallTraceSources,\n    blockSources,\n  };\n};\n\nexport const start = (service: Service) => {\n  /**\n   * The queue reacts to a new block. The four states are:\n   * 1) Block is the same as the one just processed, no-op.\n   * 2) Block is exactly one block ahead of the last processed,\n   *    handle this new block (happy path).\n   * 3) Block is more than one ahead of the last processed,\n   *    fetch all intermediate blocks and enqueue them again.\n   * 4) Block is behind the last processed. This is a sign that\n   *    a reorg has occurred.\n   */\n  const queue = createQueue({\n    browser: false,\n    concurrency: 1,\n    initialStart: true,\n    worker: async (newHeadBlock: SyncBlock) => {\n      const latestLocalBlock = getLatestLocalBlock(service);\n      const newHeadBlockNumber = hexToNumber(newHeadBlock.number);\n\n      // We already saw and handled this block. No-op.\n      if (latestLocalBlock.hash === newHeadBlock.hash) {\n        service.common.logger.trace({\n          service: \"realtime\",\n          msg: `Skipped processing '${service.network.name}' block ${newHeadBlockNumber}, already synced`,\n        });\n\n        return;\n      }\n\n      try {\n        // Quickly check for a reorg by comparing block numbers. If the block\n        // number has not increased, a reorg must have occurred.\n        if (latestLocalBlock.number >= newHeadBlockNumber) {\n          await handleReorg(service, newHeadBlock);\n\n          queue.clear();\n          return;\n        }\n\n        // Blocks are missing. They should be fetched and enqueued.\n        if (latestLocalBlock.number + 1 < newHeadBlockNumber) {\n          // Retrieve missing blocks, but only fetch a certain amount.\n          const missingBlockRange = range(\n            latestLocalBlock.number + 1,\n            Math.min(\n              newHeadBlockNumber,\n              latestLocalBlock.number + MAX_QUEUED_BLOCKS,\n            ),\n          );\n          const pendingBlocks = await Promise.all(\n            missingBlockRange.map((blockNumber) =>\n              _eth_getBlockByNumber(service, { blockNumber }),\n            ),\n          );\n\n          service.common.logger.debug({\n            service: \"realtime\",\n            msg: `Fetched ${missingBlockRange.length} missing '${\n              service.network.name\n            }' blocks from ${latestLocalBlock.number + 1} to ${Math.min(\n              newHeadBlockNumber,\n              latestLocalBlock.number + MAX_QUEUED_BLOCKS,\n            )}`,\n          });\n\n          // This is needed to ensure proper `kill()` behavior. When the service\n          // is killed, nothing should be added to the queue, or else `onIdle()`\n          // will never resolve.\n          if (service.isKilled) return;\n\n          queue.clear();\n\n          for (const pendingBlock of pendingBlocks) {\n            queue.add(pendingBlock);\n          }\n\n          queue.add(newHeadBlock);\n\n          return;\n        }\n\n        // Check if a reorg occurred by validating the chain of block hashes.\n        if (newHeadBlock.parentHash !== latestLocalBlock.hash) {\n          await handleReorg(service, newHeadBlock);\n          queue.clear();\n          return;\n        }\n\n        // New block is exactly one block ahead of the local chain.\n        // Attempt to ingest it.\n        await handleBlock(service, { newHeadBlock });\n\n        // Reset the error state after successfully completing the happy path.\n        service.consecutiveErrors = 0;\n\n        return;\n      } catch (_error) {\n        if (service.isKilled) return;\n\n        const error = _error as Error;\n        error.stack = undefined;\n\n        service.common.logger.warn({\n          service: \"realtime\",\n          msg: `Failed to process '${service.network.name}' block ${newHeadBlockNumber}`,\n          error,\n        });\n\n        const duration = ERROR_TIMEOUT[service.consecutiveErrors]!;\n\n        service.common.logger.warn({\n          service: \"realtime\",\n          msg: `Retrying '${service.network.name}' sync after ${duration} ${\n            duration === 1 ? \"second\" : \"seconds\"\n          }.`,\n        });\n\n        await wait(duration * 1_000);\n\n        // Remove all blocks from the queue. This protects against an\n        // erroneous block causing a fatal error.\n        queue.clear();\n\n        // After a certain number of attempts, emit a fatal error.\n        if (++service.consecutiveErrors === ERROR_TIMEOUT.length) {\n          service.common.logger.error({\n            service: \"realtime\",\n            msg: `Fatal error: Unable to process '${service.network.name}' block ${newHeadBlockNumber} after ${ERROR_TIMEOUT.length} attempts.`,\n            error,\n          });\n\n          service.onFatalError(error);\n        }\n      }\n    },\n  });\n\n  const enqueue = async () => {\n    try {\n      const block = await _eth_getBlockByNumber(service, {\n        blockTag: \"latest\",\n      });\n\n      return queue.add(block);\n    } catch (_error) {\n      if (service.isKilled) return;\n\n      const error = _error as Error;\n\n      service.common.logger.warn({\n        service: \"realtime\",\n        msg: `Failed to fetch latest '${service.network.name}' block`,\n        error,\n      });\n    }\n  };\n\n  setInterval(enqueue, service.network.pollingInterval);\n\n  service.queue = queue;\n\n  // Note: this is done just for testing.\n  return enqueue().then(() => queue);\n};\n\nexport const kill = async (service: Service) => {\n  service.isKilled = true;\n  service.queue?.pause();\n  service.queue?.clear();\n\n  service.common.logger.debug({\n    service: \"realtime\",\n    msg: `Killed '${service.network.name}' realtime sync`,\n  });\n\n  await service.queue?.onIdle();\n};\n\n/**\n * 1) Determine if a reorg occurred.\n * 2) Insert new event data into the store.\n * 3) Determine if a new range of events has become finalized,\n *    if so insert interval to store and remove the finalized data.\n *\n * @param newHeadBlock Block to be injested. Must be exactly\n * 1 block ahead of the local chain.\n * @returns true if a reorg occurred\n */\nexport const handleBlock = async (\n  service: Service,\n  { newHeadBlock }: { newHeadBlock: SyncBlock },\n) => {\n  const newHeadBlockNumber = hexToNumber(newHeadBlock.number);\n  const newHeadBlockTimestamp = hexToNumber(newHeadBlock.timestamp);\n\n  service.common.logger.debug({\n    service: \"realtime\",\n    msg: `Started syncing '${service.network.name}' block ${newHeadBlockNumber}`,\n  });\n\n  // \"eth_getLogs\" calls can be skipped if a negative match is given from \"logsBloom\".\n  const shouldRequestLogs =\n    service.factoryLogSources.length > 0 ||\n    newHeadBlock.logsBloom === zeroLogsBloom ||\n    isMatchedLogInBloomFilter({\n      bloom: newHeadBlock.logsBloom,\n      logFilters: service.logSources.map((s) => s.criteria),\n    });\n  const shouldRequestTraces =\n    service.callTraceSources.length > 0 ||\n    service.factoryCallTraceSources.length > 0;\n\n  // Request logs\n  const blockLogs = shouldRequestLogs\n    ? await _eth_getLogs(service, { blockHash: newHeadBlock.hash })\n    : [];\n  const newLogs = await getMatchedLogs(service, {\n    logs: blockLogs,\n    upToBlockNumber: BigInt(newHeadBlockNumber),\n  });\n\n  // Protect against RPCs returning empty logs. Known to happen near chain tip.\n  if (\n    shouldRequestLogs &&\n    newHeadBlock.logsBloom !== zeroLogsBloom &&\n    blockLogs.length === 0\n  ) {\n    throw new Error(\n      `Detected invalid '${service.network.name}' eth_getLogs response.`,\n    );\n  }\n\n  if (\n    shouldRequestLogs === false &&\n    (service.logSources.length > 0 || service.factoryLogSources.length > 0)\n  ) {\n    service.common.logger.debug({\n      service: \"realtime\",\n      msg: `Skipped fetching logs for '${service.network.name}' block ${newHeadBlockNumber} due to bloom filter result`,\n    });\n  }\n\n  // Request traces\n  const blockTraces = shouldRequestTraces\n    ? await _trace_block(service, {\n        blockNumber: newHeadBlockNumber,\n      })\n    : [];\n  const blockCallTraces = blockTraces.filter(\n    (trace) => trace.type === \"call\",\n  ) as SyncCallTrace[];\n  const newCallTraces = await getMatchedCallTraces(service, {\n    callTraces: blockCallTraces,\n    logs: blockLogs,\n    upToBlockNumber: BigInt(newHeadBlockNumber),\n  });\n\n  // Check that traces refer to the correct block\n  for (const callTrace of newCallTraces) {\n    if (callTrace.blockHash !== newHeadBlock.hash) {\n      throw new Error(\n        `Received call trace with block hash '${callTrace.blockHash}' that does not match current head block '${newHeadBlock.hash}'`,\n      );\n    }\n  }\n\n  // Protect against RPCs returning empty traces. Known to happen near chain tip.\n  // Use the fact that any stateRoot change produces a trace.\n  if (\n    shouldRequestTraces &&\n    newHeadBlock.transactions.length !== 0 &&\n    blockTraces.length === 0\n  ) {\n    throw new Error(\n      `Detected invalid '${service.network.name}' trace_block response.`,\n    );\n  }\n\n  const transactionHashes = new Set<Hash>();\n  for (const log of newLogs) {\n    transactionHashes.add(log.transactionHash);\n  }\n  for (const callTrace of newCallTraces) {\n    transactionHashes.add(callTrace.transactionHash);\n  }\n\n  const transactions = newHeadBlock.transactions.filter((t) =>\n    transactionHashes.has(t.hash),\n  );\n\n  const newTransactionReceipts =\n    service.hasTransactionReceiptSource || newCallTraces.length > 0\n      ? await Promise.all(\n          transactions.map(({ hash }) =>\n            _eth_getTransactionReceipt(service, { hash }),\n          ),\n        )\n      : [];\n\n  // Filter out reverted call traces\n  const revertedTransactions = new Set<Hash>();\n  for (const receipt of newTransactionReceipts) {\n    if (receipt.status === \"0x0\") {\n      revertedTransactions.add(receipt.transactionHash);\n    }\n  }\n\n  const newPersistentCallTraces = newCallTraces.filter(\n    (trace) => revertedTransactions.has(trace.transactionHash) === false,\n  );\n\n  // Add pending event data to sync store and local event data. Ordering is\n  // important because the sync store operation may throw an error, causing a retry.\n\n  const hasLogEvent = newLogs.length > 0;\n  const hasCallTraceEvent = newPersistentCallTraces.length > 0;\n  const hasBlockEvent = service.blockSources.some(\n    (blockSource) =>\n      (newHeadBlockNumber - blockSource.criteria.offset) %\n        blockSource.criteria.interval ===\n      0,\n  );\n\n  if (hasLogEvent || hasCallTraceEvent || hasBlockEvent) {\n    await service.syncStore.insertRealtimeBlock({\n      chainId: service.network.chainId,\n      block: newHeadBlock,\n      transactions,\n      transactionReceipts: newTransactionReceipts,\n      logs: newLogs,\n      traces: newPersistentCallTraces,\n    });\n  }\n\n  if (hasLogEvent || hasCallTraceEvent) {\n    const logCountText =\n      newLogs.length === 1 ? \"1 log\" : `${newLogs.length} logs`;\n    const traceCountText =\n      newCallTraces.length === 1\n        ? \"1 call trace\"\n        : `${newCallTraces.length} call traces`;\n    const text = [logCountText, traceCountText].join(\" and \");\n    service.common.logger.info({\n      service: \"realtime\",\n      msg: `Synced ${text} from '${service.network.name}' block ${newHeadBlockNumber}`,\n    });\n  } else if (hasBlockEvent) {\n    service.common.logger.info({\n      service: \"realtime\",\n      msg: `Synced block ${newHeadBlockNumber} from '${service.network.name}' `,\n    });\n  }\n\n  service.localChain.push(syncBlockToLightBlock(newHeadBlock));\n\n  service.onEvent({\n    type: \"checkpoint\",\n    chainId: service.network.chainId,\n    checkpoint: {\n      ...maxCheckpoint,\n      blockTimestamp: newHeadBlockTimestamp,\n      chainId: BigInt(service.network.chainId),\n      blockNumber: BigInt(newHeadBlockNumber),\n    } satisfies Checkpoint,\n  });\n\n  service.common.metrics.ponder_realtime_latest_block_number.set(\n    { network: service.network.name },\n    newHeadBlockNumber,\n  );\n  service.common.metrics.ponder_realtime_latest_block_timestamp.set(\n    { network: service.network.name },\n    newHeadBlockTimestamp,\n  );\n\n  // Determine if a new range has become finalized by evaluating if the\n  // latest block number is 2 * finalityBlockCount >= finalized block number.\n  // Essentially, there is a range the width of finalityBlockCount that is entirely\n  // finalized.\n  const blockMovesFinality =\n    newHeadBlockNumber >=\n    service.finalizedBlock.number + 2 * service.network.finalityBlockCount;\n  if (blockMovesFinality) {\n    const pendingFinalizedBlock = service.localChain.find(\n      (block) =>\n        block.number ===\n        newHeadBlockNumber - service.network.finalityBlockCount,\n    )!;\n\n    // Insert cache intervals into the store and update the local chain.\n    // Ordering is important here because the database query can fail.\n    await service.syncStore.insertRealtimeInterval({\n      chainId: service.network.chainId,\n      logFilters: service.logSources.map((l) => l.criteria),\n      factoryLogFilters: service.factoryLogSources.map((f) => f.criteria),\n      blockFilters: service.blockSources.map((b) => b.criteria),\n      traceFilters: service.callTraceSources.map((f) => f.criteria),\n      factoryTraceFilters: service.factoryCallTraceSources.map(\n        (f) => f.criteria,\n      ),\n      interval: {\n        startBlock: BigInt(service.finalizedBlock.number + 1),\n        endBlock: BigInt(pendingFinalizedBlock.number),\n      },\n    });\n\n    service.common.logger.debug({\n      service: \"realtime\",\n      msg: `Finalized ${pendingFinalizedBlock.number - service.finalizedBlock.number + 1} '${\n        service.network.name\n      }' blocks from ${service.finalizedBlock.number + 1} to ${pendingFinalizedBlock.number}`,\n    });\n\n    service.localChain = service.localChain.filter(\n      (block) => block.number > pendingFinalizedBlock.number,\n    );\n\n    service.finalizedBlock = pendingFinalizedBlock;\n\n    service.onEvent({\n      type: \"finalize\",\n      chainId: service.network.chainId,\n      checkpoint: {\n        ...maxCheckpoint,\n        blockTimestamp: service.finalizedBlock.timestamp,\n        chainId: BigInt(service.network.chainId),\n        blockNumber: BigInt(service.finalizedBlock.number),\n      } satisfies Checkpoint,\n    });\n  }\n\n  service.common.logger.debug({\n    service: \"realtime\",\n    msg: `Finished syncing '${service.network.name}' block ${newHeadBlockNumber}`,\n  });\n};\n\n/**\n * Traverse the remote chain until we find a block that is\n * compatible with out local chain.\n *\n * @param newHeadBlock Block that caused reorg to be detected.\n * Must be at most 1 block ahead of the local chain.\n */\nexport const handleReorg = async (\n  service: Service,\n  newHeadBlock: SyncBlock,\n) => {\n  const forkedBlockNumber = hexToNumber(newHeadBlock.number);\n\n  service.common.logger.warn({\n    service: \"realtime\",\n    msg: `Detected forked '${service.network.name}' block at height ${forkedBlockNumber}`,\n  });\n\n  // Prune the local chain of blocks that have been reorged out\n  const newLocalChain = service.localChain.filter(\n    (block) => block.number < forkedBlockNumber,\n  );\n\n  // Block we are attempting to fit into the local chain.\n  let remoteBlock = newHeadBlock;\n\n  while (true) {\n    const parentBlock = getLatestLocalBlock({\n      localChain: newLocalChain,\n      finalizedBlock: service.finalizedBlock,\n    });\n\n    if (parentBlock.hash === remoteBlock.parentHash) {\n      await service.syncStore.deleteRealtimeData({\n        chainId: service.network.chainId,\n        fromBlock: BigInt(parentBlock.number),\n      });\n\n      service.localChain = newLocalChain;\n\n      service.onEvent({\n        type: \"reorg\",\n        chainId: service.network.chainId,\n        safeCheckpoint: {\n          ...maxCheckpoint,\n          blockTimestamp: parentBlock.timestamp,\n          chainId: BigInt(service.network.chainId),\n          blockNumber: BigInt(parentBlock.number),\n        },\n      });\n\n      service.common.logger.warn({\n        service: \"realtime\",\n        msg: `Reconciled ${forkedBlockNumber - parentBlock.number}-block reorg on '${\n          service.network.name\n        }' with common ancestor block ${parentBlock.number}`,\n      });\n\n      return;\n    }\n\n    if (newLocalChain.length === 0) break;\n    else {\n      remoteBlock = await _eth_getBlockByHash(service, {\n        blockHash: remoteBlock.parentHash,\n      });\n      newLocalChain.pop();\n    }\n  }\n\n  // No compatible block was found in the local chain, must be a deep reorg.\n\n  const msg = `Encountered unrecoverable '${service.network.name}' reorg beyond finalized block ${service.finalizedBlock.number}`;\n\n  service.common.logger.warn({ service: \"realtime\", msg });\n\n  service.localChain = [];\n\n  throw new Error(msg);\n};\n\n/**\n * Find the most recent block that is less than or equal to\n * the provided checkpoint.\n */\nexport const getMostRecentBlock = (\n  service: Service,\n  checkpoint: Checkpoint,\n): LightBlock | undefined => {\n  const localBlock = service.localChain.findLast(\n    (block) => block.timestamp <= checkpoint.blockTimestamp,\n  );\n\n  if (localBlock !== undefined) return localBlock;\n\n  if (service.finalizedBlock.timestamp < checkpoint.blockTimestamp)\n    return service.finalizedBlock;\n\n  return undefined;\n};\n\nconst getMatchedLogs = async (\n  service: Service,\n  {\n    logs,\n    upToBlockNumber,\n  }: {\n    logs: SyncLog[];\n    upToBlockNumber: bigint;\n  },\n) => {\n  if (service.factoryLogSources.length === 0) {\n    return filterLogs({\n      logs,\n      logFilters: service.logSources.map((s) => s.criteria),\n    });\n  } else {\n    // Find and insert any new child contracts.\n    const matchedFactoryLogs = filterLogs({\n      logs,\n      logFilters: service.factoryLogSources.map((fs) => ({\n        address: fs.criteria.address,\n        topics: [fs.criteria.eventSelector],\n      })),\n    });\n\n    await service.syncStore.insertFactoryChildAddressLogs({\n      chainId: service.network.chainId,\n      logs: matchedFactoryLogs,\n    });\n\n    // Find any logs matching log filters or child contract filters.\n    // NOTE: It might make sense to just insert all logs rather than introduce\n    // a potentially slow DB operation here. It's a tradeoff between sync\n    // latency and database growth.\n    // NOTE: Also makes sense to hold factoryChildAddresses in memory rather than\n    // a query each interval.\n    const factoryLogFilters = await Promise.all(\n      service.factoryLogSources.map(async (factory) => {\n        const iterator = service.syncStore.getFactoryChildAddresses({\n          chainId: service.network.chainId,\n          factory: factory.criteria,\n          fromBlock: BigInt(factory.startBlock),\n          toBlock: upToBlockNumber,\n        });\n        const childContractAddresses: Address[] = [];\n        for await (const batch of iterator) {\n          childContractAddresses.push(...batch);\n        }\n        return {\n          address: childContractAddresses,\n          topics: factory.criteria.topics,\n        };\n      }),\n    );\n\n    return filterLogs({\n      logs,\n      logFilters: [\n        ...service.logSources.map((l) => l.criteria),\n        ...factoryLogFilters.filter((f) => f.address.length !== 0),\n      ],\n    });\n  }\n};\n\nconst getMatchedCallTraces = async (\n  service: Service,\n  {\n    callTraces,\n    logs,\n    upToBlockNumber,\n  }: {\n    callTraces: SyncCallTrace[];\n    logs: SyncLog[];\n    upToBlockNumber: bigint;\n  },\n) => {\n  if (service.factoryCallTraceSources.length === 0) {\n    return filterCallTraces({\n      callTraces,\n      callTraceFilters: service.callTraceSources.map((s) => s.criteria),\n    });\n  } else {\n    // Find and insert any new child contracts.\n    const matchedFactoryLogs = filterLogs({\n      logs,\n      logFilters: service.factoryLogSources.map((fs) => ({\n        address: fs.criteria.address,\n        topics: [fs.criteria.eventSelector],\n      })),\n    });\n\n    await service.syncStore.insertFactoryChildAddressLogs({\n      chainId: service.network.chainId,\n      logs: matchedFactoryLogs,\n    });\n\n    // Find any logs matching log filters or child contract filters.\n    // NOTE: It might make sense to just insert all logs rather than introduce\n    // a potentially slow DB operation here. It's a tradeoff between sync\n    // latency and database growth.\n    // NOTE: Also makes sense to hold factoryChildAddresses in memory rather than\n    // a query each interval.\n    const factoryTraceFilters = await Promise.all(\n      service.factoryCallTraceSources.map(async (factory) => {\n        const iterator = service.syncStore.getFactoryChildAddresses({\n          chainId: service.network.chainId,\n          factory: factory.criteria,\n          fromBlock: BigInt(factory.startBlock),\n          toBlock: upToBlockNumber,\n        });\n        const childContractAddresses: Address[] = [];\n        for await (const batch of iterator) {\n          childContractAddresses.push(...batch);\n        }\n        return {\n          toAddress: childContractAddresses,\n          fromAddress: factory.criteria.fromAddress,\n        };\n      }),\n    );\n\n    return filterCallTraces({\n      callTraces,\n      callTraceFilters: [\n        ...service.callTraceSources.map((s) => s.criteria),\n        ...factoryTraceFilters.filter((f) => f.toAddress.length !== 0),\n      ],\n    });\n  }\n};\n\nconst getLatestLocalBlock = ({\n  localChain,\n  finalizedBlock,\n}: Pick<Service, \"localChain\" | \"finalizedBlock\">) => {\n  if (localChain.length === 0) {\n    return finalizedBlock;\n  } else return localChain[localChain.length - 1]!;\n};\n","import {\n  type Address,\n  type Hex,\n  type LogTopic,\n  hexToBytes,\n  keccak256,\n} from \"viem\";\n\nexport const zeroLogsBloom =\n  \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\";\n\nconst BLOOM_SIZE_BYTES = 256;\n\nexport const isInBloom = (_bloom: Hex, input: Hex): boolean => {\n  const bloom = hexToBytes(_bloom);\n  const hash = hexToBytes(keccak256(input));\n\n  for (const i of [0, 2, 4]) {\n    const bit = (hash[i + 1]! + (hash[i]! << 8)) & 0x7ff;\n    if (\n      (bloom[BLOOM_SIZE_BYTES - 1 - Math.floor(bit / 8)]! &\n        (1 << (bit % 8))) ===\n      0\n    )\n      return false;\n  }\n\n  return true;\n};\n\nexport function isMatchedLogInBloomFilter({\n  bloom,\n  logFilters,\n}: {\n  bloom: Hex;\n  logFilters: {\n    address?: Address | Address[];\n    topics?: LogTopic[];\n  }[];\n}) {\n  const allAddresses: Address[] = [];\n  logFilters.forEach((logFilter) => {\n    const address =\n      logFilter.address === undefined\n        ? []\n        : Array.isArray(logFilter.address)\n          ? logFilter.address\n          : [logFilter.address];\n    allAddresses.push(...address);\n  });\n  if (allAddresses.some((a) => isInBloom(bloom, a))) {\n    return true;\n  }\n\n  const allTopics: Hex[] = [];\n  logFilters.forEach((logFilter) => {\n    logFilter.topics?.forEach((topic) => {\n      if (topic === null) return;\n      if (Array.isArray(topic)) allTopics.push(...topic);\n      else allTopics.push(topic);\n    });\n  });\n  if (allTopics.some((a) => isInBloom(bloom, a))) {\n    return true;\n  }\n\n  return false;\n}\n","import type {\n  CallTraceFilterCriteria,\n  LogFilterCriteria,\n} from \"@/config/sources.js\";\nimport type { SyncCallTrace, SyncLog } from \"@/sync/index.js\";\nimport { toLowerCase } from \"@/utils/lowercase.js\";\n\nexport function filterLogs({\n  logs,\n  logFilters,\n}: {\n  logs: SyncLog[];\n  logFilters: Pick<LogFilterCriteria, \"address\" | \"topics\">[];\n}) {\n  return logs.filter((log) =>\n    logFilters.some((logFilter) => isLogMatchedByFilter({ log, logFilter })),\n  );\n}\n\nexport function isLogMatchedByFilter({\n  log,\n  logFilter,\n}: {\n  log: Pick<SyncLog, \"address\" | \"topics\">;\n  logFilter: Pick<LogFilterCriteria, \"address\" | \"topics\">;\n}) {\n  const logAddress = toLowerCase(log.address);\n\n  if (logFilter.address !== undefined && logFilter.address.length > 0) {\n    if (Array.isArray(logFilter.address)) {\n      if (!logFilter.address.includes(logAddress)) return false;\n    } else {\n      if (logAddress !== logFilter.address) return false;\n    }\n  }\n\n  if (logFilter.topics) {\n    for (const [index, topic] of logFilter.topics.entries()) {\n      if (topic === null || topic === undefined) continue;\n\n      if (log.topics[index] === null || log.topics[index] === undefined)\n        return false;\n\n      if (Array.isArray(topic)) {\n        if (!topic.includes(toLowerCase(log.topics[index]!))) return false;\n      } else {\n        if (toLowerCase(log.topics[index]!) !== topic) return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nexport function filterCallTraces({\n  callTraces,\n  callTraceFilters,\n}: {\n  callTraces: SyncCallTrace[];\n  callTraceFilters: Pick<\n    CallTraceFilterCriteria,\n    \"fromAddress\" | \"toAddress\"\n  >[];\n}) {\n  return callTraces.filter((callTrace) =>\n    callTraceFilters.some((callTraceFilter) =>\n      isCallTraceMatchedByFilter({ callTrace, callTraceFilter }),\n    ),\n  );\n}\n\nexport function isCallTraceMatchedByFilter({\n  callTrace,\n  callTraceFilter,\n}: {\n  callTrace: Pick<SyncCallTrace, \"action\">;\n  callTraceFilter: Pick<CallTraceFilterCriteria, \"fromAddress\" | \"toAddress\">;\n}) {\n  const fromAddress = toLowerCase(callTrace.action.from);\n  const toAddress = toLowerCase(callTrace.action.to);\n\n  if (\n    callTraceFilter.fromAddress !== undefined &&\n    callTraceFilter.fromAddress.length > 0\n  ) {\n    if (!callTraceFilter.fromAddress.includes(fromAddress)) return false;\n  }\n\n  if (\n    callTraceFilter.toAddress !== undefined &&\n    callTraceFilter.toAddress.length > 0\n  ) {\n    if (!callTraceFilter.toAddress.includes(toAddress)) return false;\n  }\n\n  return true;\n}\n","import type { SyncBlock } from \"@/sync/index.js\";\nimport { type Block, type BlockTag, hexToNumber } from \"viem\";\n\nexport type LightBlock = Pick<\n  Block<number, boolean, Exclude<BlockTag, \"pending\">>,\n  \"hash\" | \"parentHash\" | \"number\" | \"timestamp\"\n>;\n\nexport const syncBlockToLightBlock = ({\n  hash,\n  parentHash,\n  number,\n  timestamp,\n}: SyncBlock): LightBlock => ({\n  hash,\n  parentHash,\n  number: hexToNumber(number),\n  timestamp: hexToNumber(timestamp),\n});\n","import { type Extend, extend } from \"@/utils/extend.js\";\nimport { create, getMostRecentBlock, kill, start } from \"./service.js\";\nimport type { RealtimeSyncEvent, Service } from \"./service.js\";\n\nconst methods = {\n  start,\n  kill,\n  getMostRecentBlock,\n};\n\nexport const createRealtimeSyncService = extend(create, methods);\n\nexport type RealtimeSyncService = Extend<Service, typeof methods>;\n\nexport type { RealtimeSyncEvent };\n","import type { Common } from \"@/common/common.js\";\nimport type { Network } from \"@/config/networks.js\";\nimport { type Queue, createQueue } from \"@ponder/common\";\nimport {\n  type GetLogsRetryHelperParameters,\n  getLogsRetryHelper,\n} from \"@ponder/utils\";\nimport {\n  BlockNotFoundError,\n  type EIP1193Parameters,\n  HttpRequestError,\n  InternalRpcError,\n  InvalidInputRpcError,\n  LimitExceededRpcError,\n  type PublicRpcSchema,\n  type RpcError,\n  type RpcLog,\n  hexToBigInt,\n  isHex,\n} from \"viem\";\nimport { startClock } from \"./timer.js\";\nimport { wait } from \"./wait.js\";\n\ntype RequestReturnType<\n  method extends EIP1193Parameters<PublicRpcSchema>[\"method\"],\n> = Extract<PublicRpcSchema[number], { Method: method }>[\"ReturnType\"];\n\nexport type RequestQueue = Omit<\n  Queue<\n    RequestReturnType<EIP1193Parameters<PublicRpcSchema>[\"method\"]>,\n    EIP1193Parameters<PublicRpcSchema>\n  >,\n  \"add\"\n> & {\n  request: <TParameters extends EIP1193Parameters<PublicRpcSchema>>(\n    parameters: TParameters,\n  ) => Promise<RequestReturnType<TParameters[\"method\"]>>;\n};\n\nconst RETRY_COUNT = 9;\nconst BASE_DURATION = 125;\n\n/**\n * Creates a queue built to manage rpc requests.\n */\nexport const createRequestQueue = ({\n  network,\n  common,\n}: {\n  network: Network;\n  common: Common;\n}): RequestQueue => {\n  const fetchRequest = async (request: EIP1193Parameters<PublicRpcSchema>) => {\n    for (let i = 0; i <= RETRY_COUNT; i++) {\n      try {\n        const stopClock = startClock();\n        const response = await network.transport.request(request);\n        common.metrics.ponder_rpc_request_duration.observe(\n          { method: request.method, network: network.name },\n          stopClock(),\n        );\n\n        return response;\n      } catch (_error) {\n        const error = _error as Error;\n\n        if (\n          request.method === \"eth_getLogs\" &&\n          isHex(request.params[0].fromBlock) &&\n          isHex(request.params[0].toBlock)\n        ) {\n          const getLogsErrorResponse = getLogsRetryHelper({\n            params: request.params as GetLogsRetryHelperParameters[\"params\"],\n            error: error as RpcError,\n          });\n\n          if (getLogsErrorResponse.shouldRetry === false) throw error;\n\n          common.logger.debug({\n            service: \"sync\",\n            msg: `Caught eth_getLogs error on '${\n              network.name\n            }', retrying with ranges: [${getLogsErrorResponse.ranges\n              .map(\n                ({ fromBlock, toBlock }) =>\n                  `[${hexToBigInt(fromBlock).toString()}, ${hexToBigInt(toBlock).toString()}]`,\n              )\n              .join(\", \")}].`,\n          });\n\n          const logs: RpcLog[] = [];\n          for (const { fromBlock, toBlock } of getLogsErrorResponse.ranges) {\n            const _logs = await fetchRequest({\n              method: \"eth_getLogs\",\n              params: [\n                {\n                  topics: request.params![0].topics,\n                  address: request.params![0].address,\n                  fromBlock,\n                  toBlock,\n                },\n              ],\n            });\n\n            logs.push(...(_logs as RpcLog[]));\n          }\n\n          return logs;\n        }\n\n        if (shouldRetry(request.method, error) === false) {\n          common.logger.warn({\n            service: \"sync\",\n            msg: `Failed '${request.method}' RPC request`,\n          });\n          throw error;\n        }\n\n        if (i === RETRY_COUNT) {\n          common.logger.warn({\n            service: \"sync\",\n            msg: `Failed '${request.method}' RPC request after ${i + 1} attempts`,\n            error,\n          });\n          throw error;\n        }\n\n        const duration = BASE_DURATION * 2 ** i;\n        common.logger.debug({\n          service: \"sync\",\n          msg: `Failed '${request.method}' RPC request, retrying after ${duration} milliseconds`,\n          error,\n        });\n        await wait(duration);\n      }\n    }\n  };\n\n  const requestQueue: Queue<\n    unknown,\n    {\n      request: EIP1193Parameters<PublicRpcSchema>;\n      stopClockLag: () => number;\n    }\n  > = createQueue({\n    frequency: network.maxRequestsPerSecond,\n    concurrency: Math.ceil(network.maxRequestsPerSecond / 4),\n    initialStart: true,\n    browser: false,\n    worker: async (task: {\n      request: EIP1193Parameters<PublicRpcSchema>;\n      stopClockLag: () => number;\n    }) => {\n      common.metrics.ponder_rpc_request_lag.observe(\n        { method: task.request.method, network: network.name },\n        task.stopClockLag(),\n      );\n\n      return await fetchRequest(task.request);\n    },\n  });\n\n  return {\n    ...requestQueue,\n    request: <TParameters extends EIP1193Parameters<PublicRpcSchema>>(\n      params: TParameters,\n    ) => {\n      const stopClockLag = startClock();\n\n      return requestQueue.add({ request: params, stopClockLag });\n    },\n  } as RequestQueue;\n};\n\n/**\n * @link https://github.com/wevm/viem/blob/main/src/utils/buildRequest.ts#L192\n */\nfunction shouldRetry(method: string, error: Error) {\n  if (\"code\" in error && typeof error.code === \"number\") {\n    if (error.code === -1) return true; // Unknown error\n    if (method === \"eth_getLogs\" && error.code === InvalidInputRpcError.code)\n      return true;\n    if (error.code === LimitExceededRpcError.code) return true;\n    if (error.code === InternalRpcError.code) return true;\n    return false;\n  }\n  if (error instanceof BlockNotFoundError) return true;\n  if (error instanceof HttpRequestError && error.status) {\n    // Forbidden\n    if (error.status === 403) return true;\n    // Request Timeout\n    if (error.status === 408) return true;\n    // Request Entity Too Large\n    if (error.status === 413) return true;\n    // Too Many Requests\n    if (error.status === 429) return true;\n    // Internal Server Error\n    if (error.status === 500) return true;\n    // Bad Gateway\n    if (error.status === 502) return true;\n    // Service Unavailable\n    if (error.status === 503) return true;\n    // Gateway Timeout\n    if (error.status === 504) return true;\n    return false;\n  }\n  return true;\n}\n","import type { RealtimeEvent } from \"@/bin/utils/run.js\";\nimport type { Common } from \"@/common/common.js\";\nimport type { Network } from \"@/config/networks.js\";\nimport type { EventSource } from \"@/config/sources.js\";\nimport { HistoricalSyncService } from \"@/sync-historical/service.js\";\nimport {\n  type RealtimeSyncEvent,\n  type RealtimeSyncService,\n  createRealtimeSyncService,\n} from \"@/sync-realtime/index.js\";\nimport type { SyncStore } from \"@/sync-store/store.js\";\nimport {\n  type Checkpoint,\n  checkpointMax,\n  checkpointMin,\n  isCheckpointGreaterThan,\n  maxCheckpoint,\n  zeroCheckpoint,\n} from \"@/utils/checkpoint.js\";\nimport { never } from \"@/utils/never.js\";\nimport { type RequestQueue, createRequestQueue } from \"@/utils/requestQueue.js\";\nimport { wait } from \"@/utils/wait.js\";\nimport { type Transport, hexToBigInt, hexToNumber } from \"viem\";\nimport { type SyncBlock, _eth_getBlockByNumber } from \"./index.js\";\nimport { cachedTransport } from \"./transport.js\";\n\nexport type Service = {\n  // static\n  common: Common;\n  syncStore: SyncStore;\n  sources: EventSource[];\n\n  // state\n  checkpoint: Checkpoint;\n  /** Checkpoint of the earliest start block. */\n  startCheckpoint: Checkpoint;\n  /**\n   * Checkpoint of the latest end block, can\n   * be undefined if not every end block is set.\n   */\n  endCheckpoint: Checkpoint | undefined;\n  finalizedCheckpoint: Checkpoint;\n  isKilled: boolean;\n\n  // network specific services\n  networkServices: {\n    network: Network;\n    sources: EventSource[];\n    requestQueue: RequestQueue;\n    cachedTransport: Transport;\n\n    startCheckpoint: Checkpoint;\n    endCheckpoint: Checkpoint | undefined;\n    initialFinalizedCheckpoint: Checkpoint;\n\n    realtime:\n      | {\n          realtimeSync: RealtimeSyncService;\n          checkpoint: Checkpoint;\n          finalizedCheckpoint: Checkpoint;\n          finalizedBlock: SyncBlock;\n          endBlock: number | undefined;\n        }\n      | undefined;\n\n    historical: {\n      historicalSync: HistoricalSyncService;\n      checkpoint: Checkpoint | undefined;\n      isHistoricalSyncComplete: boolean;\n    };\n  }[];\n\n  // cache\n  sourceById: { [sourceId: EventSource[\"id\"]]: EventSource };\n};\n\nconst HISTORICAL_CHECKPOINT_INTERVAL = 500;\n\nexport const create = async ({\n  common,\n  syncStore,\n  networks,\n  sources,\n  onRealtimeEvent,\n  onFatalError,\n  initialCheckpoint,\n}: {\n  common: Common;\n  syncStore: SyncStore;\n  networks: Network[];\n  sources: EventSource[];\n  onRealtimeEvent: (realtimeEvent: RealtimeEvent) => void;\n  onFatalError: (error: Error) => void;\n  initialCheckpoint: Checkpoint;\n}): Promise<Service> => {\n  const sourceById = sources.reduce<Service[\"sourceById\"]>((acc, cur) => {\n    acc[cur.id] = cur;\n    return acc;\n  }, {});\n\n  const onRealtimeSyncEvent = (realtimeSyncEvent: RealtimeSyncEvent) => {\n    switch (realtimeSyncEvent.type) {\n      case \"checkpoint\": {\n        const networkService = syncService.networkServices.find(\n          (ns) => ns.network.chainId === realtimeSyncEvent.chainId,\n        )!;\n\n        // \"realtime\" property may be undefined when `kill()` has been\n        // invoked but hasn't completed.\n        if (networkService.realtime === undefined) return;\n\n        networkService.realtime.checkpoint = realtimeSyncEvent.checkpoint;\n\n        // `realtime` can be undefined if no contracts for that network require a realtime\n        // service. Those networks can be left out of the checkpoint calculation.\n        const newCheckpoint = checkpointMin(\n          ...syncService.networkServices\n            .filter((ns) => ns.realtime !== undefined)\n            .map((ns) => ns.realtime!.checkpoint),\n        );\n\n        // Do nothing if the checkpoint hasn't advanced. This also protects against\n        // edged cases in the caching logic with un-trustworthy finalized checkpoints.\n        if (!isCheckpointGreaterThan(newCheckpoint, syncService.checkpoint))\n          return;\n\n        // Must be cautious to deep copy checkpoints.\n\n        const fromCheckpoint = { ...syncService.checkpoint };\n        const toCheckpoint = { ...newCheckpoint };\n\n        syncService.checkpoint = newCheckpoint;\n\n        onRealtimeEvent({\n          type: \"newEvents\",\n          fromCheckpoint,\n          toCheckpoint,\n        });\n\n        break;\n      }\n\n      case \"reorg\": {\n        const networkService = syncService.networkServices.find(\n          (ns) => ns.network.chainId === realtimeSyncEvent.chainId,\n        )!;\n\n        // \"realtime\" property may be undefined when `kill()` has been\n        // invoked but hasn't completed.\n        if (networkService.realtime === undefined) return;\n\n        networkService.realtime!.checkpoint = realtimeSyncEvent.safeCheckpoint;\n\n        if (\n          isCheckpointGreaterThan(\n            syncService.checkpoint,\n            realtimeSyncEvent.safeCheckpoint,\n          )\n        ) {\n          syncService.checkpoint = realtimeSyncEvent.safeCheckpoint;\n        }\n\n        onRealtimeEvent(realtimeSyncEvent);\n\n        break;\n      }\n\n      case \"finalize\": {\n        const networkService = syncService.networkServices.find(\n          (ns) => ns.network.chainId === realtimeSyncEvent.chainId,\n        )!;\n\n        // \"realtime\" property may be undefined when `kill()` has been\n        // invoked but hasn't completed.\n        if (networkService.realtime === undefined) return;\n\n        networkService.realtime!.finalizedCheckpoint =\n          realtimeSyncEvent.checkpoint;\n\n        // Check if the finalized blockNumber is greater than the end block of all\n        // sources for the network. Potentially kill the realtime sync and remove the\n        // network from checkpoint calculations.\n        if (\n          networkService.realtime.endBlock !== undefined &&\n          realtimeSyncEvent.checkpoint.blockNumber >\n            networkService.realtime.endBlock\n        ) {\n          common.logger.info({\n            service: \"sync\",\n            msg: `Synced final end block for '${networkService.network.name}' (${networkService.realtime.endBlock}), killing realtime sync service`,\n          });\n          networkService.realtime.realtimeSync.kill();\n          networkService.realtime = undefined;\n        }\n\n        const newFinalizedCheckpoint = checkpointMin(\n          ...syncService.networkServices\n            .filter((ns) => ns.realtime !== undefined)\n            .map((ns) => ns.realtime!.finalizedCheckpoint),\n        );\n\n        if (\n          isCheckpointGreaterThan(\n            newFinalizedCheckpoint,\n            syncService.finalizedCheckpoint,\n          )\n        ) {\n          onRealtimeEvent({\n            type: \"finalize\",\n            checkpoint: newFinalizedCheckpoint,\n          });\n          syncService.finalizedCheckpoint = newFinalizedCheckpoint;\n        }\n\n        break;\n      }\n\n      default:\n        never(realtimeSyncEvent);\n    }\n  };\n\n  const networkServices: Service[\"networkServices\"] = await Promise.all(\n    networks.map(async (network) => {\n      const networkSources = sources.filter(\n        (source) => source.networkName === network.name,\n      );\n\n      const requestQueue = createRequestQueue({\n        network,\n        common,\n      });\n\n      const hasEndBlock = networkSources.every(\n        (source) => source.endBlock !== undefined,\n      );\n\n      const [\n        startBlock,\n        endBlock,\n        { latestBlock, finalizedBlock },\n        remoteChainId,\n      ] = await Promise.all([\n        _eth_getBlockByNumber(\n          { requestQueue },\n          {\n            blockNumber: Math.min(\n              ...networkSources.map((source) => source.startBlock),\n            ),\n          },\n        ),\n        hasEndBlock\n          ? _eth_getBlockByNumber(\n              { requestQueue },\n              {\n                blockNumber: Math.max(\n                  ...networkSources.map((source) => source.endBlock!),\n                ),\n              },\n            )\n          : undefined,\n        getLatestAndFinalizedBlocks({\n          network,\n          requestQueue,\n        }),\n        requestQueue.request({ method: \"eth_chainId\" }).then(hexToNumber),\n      ]);\n\n      if (network.chainId !== remoteChainId) {\n        common.logger.warn({\n          service: \"sync\",\n          msg: `Remote chain ID (${remoteChainId}) does not match configured chain ID (${network.chainId}) for network \"${network.name}\"`,\n        });\n      }\n\n      for (const source of networkSources) {\n        if (source.startBlock > hexToNumber(latestBlock.number)) {\n          common.logger.warn({\n            service: \"sync\",\n            msg: `Start block ${source.startBlock} is greater than the latest block ${hexToNumber(\n              latestBlock.number,\n            )} for '${network.name}'.`,\n          });\n        }\n      }\n\n      const historicalSync = new HistoricalSyncService({\n        common,\n        syncStore,\n        network,\n        requestQueue,\n        sources: networkSources,\n      });\n\n      await historicalSync.setup({\n        finalizedBlockNumber: hexToNumber(finalizedBlock.number),\n      });\n\n      const initialFinalizedCheckpoint: Checkpoint = {\n        ...maxCheckpoint,\n        blockTimestamp: hexToNumber(finalizedBlock.timestamp),\n        chainId: BigInt(network.chainId),\n        blockNumber: hexToBigInt(finalizedBlock.number),\n      };\n\n      const startCheckpoint = {\n        ...zeroCheckpoint,\n        blockTimestamp: hexToNumber(startBlock.timestamp),\n        blockNumber: hexToBigInt(startBlock.number),\n        chainId: BigInt(network.chainId),\n      };\n\n      const endCheckpoint = endBlock\n        ? {\n            ...zeroCheckpoint,\n            blockTimestamp: hexToNumber(endBlock.timestamp),\n            blockNumber: hexToBigInt(endBlock.number),\n            chainId: BigInt(network.chainId),\n          }\n        : undefined;\n\n      const canSkipRealtime = getCanSkipRealtime({\n        sources: networkSources,\n        finalizedBlock,\n      });\n\n      if (canSkipRealtime) {\n        return {\n          network,\n          sources: networkSources,\n          requestQueue,\n          cachedTransport: cachedTransport({ requestQueue, syncStore }),\n          startCheckpoint,\n          endCheckpoint,\n          initialFinalizedCheckpoint,\n          realtime: undefined,\n          historical: {\n            historicalSync,\n            checkpoint: undefined,\n            isHistoricalSyncComplete: false,\n          },\n        } satisfies Service[\"networkServices\"][number];\n      } else {\n        const realtimeSync = createRealtimeSyncService({\n          common,\n          syncStore,\n          network,\n          requestQueue,\n          sources: networkSources,\n          finalizedBlock,\n          onEvent: onRealtimeSyncEvent,\n          onFatalError,\n        });\n\n        return {\n          network,\n          sources: networkSources,\n          requestQueue,\n          cachedTransport: cachedTransport({ requestQueue, syncStore }),\n          startCheckpoint,\n          endCheckpoint,\n          initialFinalizedCheckpoint,\n          realtime: {\n            realtimeSync,\n            checkpoint: initialFinalizedCheckpoint,\n            finalizedCheckpoint: initialFinalizedCheckpoint,\n            finalizedBlock,\n            endBlock: networkSources.every(\n              (source) => source.endBlock !== undefined,\n            )\n              ? Math.max(...networkSources.map((source) => source.endBlock!))\n              : undefined,\n          },\n          historical: {\n            historicalSync,\n            checkpoint: undefined,\n            isHistoricalSyncComplete: false,\n          },\n        } satisfies Service[\"networkServices\"][number];\n      }\n    }),\n  );\n\n  // Register historical sync event listeners\n  for (const networkService of networkServices) {\n    networkService.historical.historicalSync.on(\n      \"historicalCheckpoint\",\n      (checkpoint: Checkpoint) => {\n        networkService.historical.checkpoint = checkpoint;\n\n        common.logger.trace({\n          service: \"sync\",\n          msg: `New historical checkpoint (timestamp=${checkpoint.blockTimestamp} chainId=${checkpoint.chainId} blockNumber=${checkpoint.blockNumber})`,\n        });\n      },\n    );\n    networkService.historical.historicalSync.on(\"syncComplete\", () => {\n      networkService.historical.isHistoricalSyncComplete = true;\n\n      if (\n        networkServices.every(\n          ({ historical }) => historical.isHistoricalSyncComplete,\n        )\n      ) {\n        common.logger.info({\n          service: \"sync\",\n          msg: \"Completed historical sync across all networks\",\n        });\n      }\n    });\n  }\n\n  // Invalidate sync cache for devnet sources\n  for (const networkService of networkServices) {\n    if (networkService.network.disableCache) {\n      const minStartBlock = Math.min(\n        ...networkService.sources.map((source) => source.startBlock),\n      );\n\n      common.logger.warn({\n        service: \"sync\",\n        msg: `Deleting cache records for '${networkService.network.name}' from block ${minStartBlock}`,\n      });\n\n      await syncStore.pruneByChainId({\n        chainId: networkService.network.chainId,\n        block: minStartBlock,\n      });\n    }\n  }\n\n  const startCheckpoint = checkpointMin(\n    ...networkServices.map((ns) => ns.startCheckpoint),\n  );\n\n  const syncService: Service = {\n    common,\n    syncStore,\n    sources,\n    networkServices,\n    isKilled: false,\n    startCheckpoint,\n    endCheckpoint: networkServices.every((ns) => ns.endCheckpoint !== undefined)\n      ? checkpointMax(...networkServices.map((ns) => ns.endCheckpoint!))\n      : undefined,\n    // Note: The initial checkpoint will be not zero if there is a cache hit.\n    checkpoint: checkpointMax(initialCheckpoint, startCheckpoint),\n    finalizedCheckpoint: checkpointMin(\n      ...networkServices.map((ns) => ns.initialFinalizedCheckpoint),\n    ),\n    sourceById,\n  };\n\n  return syncService;\n};\n\n/**\n * Start the historical sync service for all networks.\n */\nexport const startHistorical = (syncService: Service) => {\n  for (const { historical } of syncService.networkServices) {\n    historical.historicalSync.start();\n  }\n};\n\n/**\n * Returns an async generator of checkpoints that resolves\n * when historical sync is complete.\n */\nexport const getHistoricalCheckpoint = async function* (\n  syncService: Service,\n): AsyncGenerator<{ fromCheckpoint: Checkpoint; toCheckpoint: Checkpoint }> {\n  while (true) {\n    if (syncService.isKilled) return;\n\n    const isComplete = syncService.networkServices.every(\n      (ns) => ns.historical.isHistoricalSyncComplete,\n    );\n\n    if (isComplete) {\n      const finalityCheckpoint = checkpointMin(\n        ...syncService.networkServices.map(\n          ({ initialFinalizedCheckpoint }) => initialFinalizedCheckpoint,\n        ),\n      );\n\n      // Do nothing if the checkpoint hasn't advanced. This also protects against\n      // edged cases in the caching logic with un-trustworthy finalized checkpoints.\n      if (!isCheckpointGreaterThan(finalityCheckpoint, syncService.checkpoint))\n        break;\n\n      yield {\n        fromCheckpoint: syncService.checkpoint,\n        toCheckpoint: syncService.endCheckpoint ?? finalityCheckpoint,\n      };\n\n      syncService.checkpoint = finalityCheckpoint;\n\n      break;\n    } else {\n      await wait(HISTORICAL_CHECKPOINT_INTERVAL);\n\n      const networkCheckpoints = syncService.networkServices.map(\n        (ns) => ns.historical.checkpoint,\n      );\n\n      // If a network hasn't yet found any checkpoint, it is\n      // impossible to determine a checkpoint amongst all networks.\n      if (networkCheckpoints.some((nc) => nc === undefined)) {\n        continue;\n      }\n\n      const newCheckpoint = checkpointMin(\n        ...(networkCheckpoints as Checkpoint[]),\n      );\n\n      // Do nothing if the checkpoint hasn't advanced.\n      if (!isCheckpointGreaterThan(newCheckpoint, syncService.checkpoint)) {\n        continue;\n      }\n\n      yield {\n        fromCheckpoint: syncService.checkpoint,\n        toCheckpoint: newCheckpoint,\n      };\n\n      syncService.checkpoint = newCheckpoint;\n    }\n  }\n};\n\n/**\n * Start the realtime sync service for all networks.\n */\nexport const startRealtime = (syncService: Service) => {\n  for (const { realtime, network } of syncService.networkServices) {\n    if (realtime === undefined) {\n      syncService.common.logger.debug({\n        service: \"realtime\",\n        msg: `No realtime contracts (network=${network.name})`,\n      });\n      syncService.common.metrics.ponder_realtime_is_connected.set(\n        { network: network.name },\n        0,\n      );\n    } else {\n      realtime.realtimeSync.start();\n      syncService.common.metrics.ponder_realtime_is_connected.set(\n        { network: network.name },\n        1,\n      );\n    }\n  }\n};\n\nexport const kill = async (syncService: Service) => {\n  syncService.isKilled = true;\n\n  const killPromise: Promise<void>[] = [];\n\n  for (const { historical, realtime } of syncService.networkServices) {\n    historical.historicalSync.kill();\n    if (realtime !== undefined) killPromise.push(realtime.realtimeSync.kill());\n  }\n\n  await Promise.all(killPromise);\n};\n\n/** Return the number and timestamp of the most recently processed blocks. */\nexport const getStatusBlocks = (\n  syncService: Service,\n  realtimeCheckpoint?: Checkpoint,\n) => {\n  const status: {\n    [networkName: string]: { number: number; timestamp: number } | undefined;\n  } = {};\n\n  for (const networkService of syncService.networkServices) {\n    if (networkService.realtime === undefined) {\n      status[networkService.network.name] = {\n        number: Number(networkService.endCheckpoint!.blockNumber),\n        timestamp: networkService.endCheckpoint!.blockTimestamp,\n      };\n    } else {\n      const mostRecentBlock =\n        networkService.realtime.realtimeSync.getMostRecentBlock(\n          realtimeCheckpoint === undefined\n            ? syncService.checkpoint\n            : checkpointMin(syncService.checkpoint, realtimeCheckpoint),\n        );\n\n      if (mostRecentBlock === undefined) {\n        status[networkService.network.name] = undefined;\n      } else {\n        status[networkService.network.name] = {\n          timestamp: mostRecentBlock.timestamp,\n          number: mostRecentBlock.number,\n        };\n      }\n    }\n  }\n\n  return status;\n};\n\nexport const getCachedTransport = (syncService: Service, network: Network) => {\n  const { requestQueue } = syncService.networkServices.find(\n    (ns) => ns.network.chainId === network.chainId,\n  )!;\n  return cachedTransport({ requestQueue, syncStore: syncService.syncStore });\n};\n\nconst getLatestAndFinalizedBlocks = async ({\n  network,\n  requestQueue,\n}: { network: Network; requestQueue: RequestQueue }) => {\n  const latestBlock = await _eth_getBlockByNumber(\n    { requestQueue },\n    { blockTag: \"latest\" },\n  );\n\n  const finalizedBlockNumber = Math.max(\n    0,\n    hexToNumber(latestBlock.number) - network.finalityBlockCount,\n  );\n\n  const finalizedBlock = await _eth_getBlockByNumber(\n    { requestQueue },\n    {\n      blockNumber: finalizedBlockNumber,\n    },\n  );\n\n  return { latestBlock, finalizedBlock };\n};\n\nconst getCanSkipRealtime = ({\n  sources,\n  finalizedBlock,\n}: {\n  sources: EventSource[];\n  finalizedBlock: SyncBlock;\n}) => {\n  // If an endBlock is specified for every event source on this network, and the\n  // latest end block is less than the finalized block number, we can stop here.\n  // The service won't poll for new blocks and won't emit any events.\n  const endBlocks = sources.map((f) => f.endBlock);\n  return endBlocks.every(\n    (b) => b !== undefined && b <= hexToNumber(finalizedBlock.number),\n  );\n};\n","import type { SyncStore } from \"@/sync-store/store.js\";\nimport { toLowerCase } from \"@/utils/lowercase.js\";\nimport type { RequestQueue } from \"@/utils/requestQueue.js\";\nimport type { Address, Hex, Transport } from \"viem\";\nimport { custom, hexToBigInt, maxUint256 } from \"viem\";\n\nconst cachedMethods = [\n  \"eth_call\",\n  \"eth_getBalance\",\n  \"eth_getCode\",\n  \"eth_getStorageAt\",\n] as const;\n\nexport const cachedTransport = ({\n  requestQueue,\n  syncStore,\n}: {\n  requestQueue: RequestQueue;\n  syncStore: SyncStore;\n}): Transport => {\n  return ({ chain }) => {\n    const c = custom({\n      async request({ method, params }) {\n        const body = { method, params };\n\n        if (cachedMethods.includes(method)) {\n          let request: string = undefined!;\n          let blockNumber: Hex | \"latest\" = undefined!;\n\n          if (method === \"eth_call\") {\n            const [{ data, to }, _blockNumber] = params as [\n              { data: Hex; to: Hex },\n              Hex | \"latest\",\n            ];\n\n            request = `${method as string}_${toLowerCase(to)}_${toLowerCase(data)}`;\n            blockNumber = _blockNumber;\n          } else if (method === \"eth_getBalance\") {\n            const [address, _blockNumber] = params as [Address, Hex | \"latest\"];\n\n            request = `${method as string}_${toLowerCase(address)}`;\n            blockNumber = _blockNumber;\n          } else if (method === \"eth_getCode\") {\n            const [address, _blockNumber] = params as [Address, Hex | \"latest\"];\n\n            request = `${method as string}_${toLowerCase(address)}`;\n            blockNumber = _blockNumber;\n          } else if (method === \"eth_getStorageAt\") {\n            const [address, slot, _blockNumber] = params as [\n              Address,\n              Hex,\n              Hex | \"latest\",\n            ];\n\n            request = `${method as string}_${toLowerCase(address)}_${toLowerCase(slot)}`;\n            blockNumber = _blockNumber;\n          }\n\n          const blockNumberBigInt =\n            blockNumber === \"latest\" ? maxUint256 : hexToBigInt(blockNumber);\n\n          const cachedResult = await syncStore.getRpcRequestResult({\n            blockNumber: blockNumberBigInt,\n            chainId: chain!.id,\n            request,\n          });\n\n          if (cachedResult?.result) return cachedResult.result;\n          else {\n            const response = await requestQueue.request(body);\n            await syncStore.insertRpcRequestResult({\n              blockNumber: blockNumberBigInt,\n              chainId: chain!.id,\n              request,\n              result: response as string,\n            });\n            return response;\n          }\n        } else {\n          return requestQueue.request(body);\n        }\n      },\n    });\n    return c({ chain, retryCount: 0 });\n  };\n};\n","import type { IndexingBuild } from \"@/build/index.js\";\nimport { runCodegen } from \"@/common/codegen.js\";\nimport type { Common } from \"@/common/common.js\";\nimport { PostgresDatabaseService } from \"@/database/postgres/service.js\";\nimport type { DatabaseService, NamespaceInfo } from \"@/database/service.js\";\nimport { SqliteDatabaseService } from \"@/database/sqlite/service.js\";\nimport { getHistoricalStore } from \"@/indexing-store/historical.js\";\nimport { getMetadataStore } from \"@/indexing-store/metadata.js\";\nimport { getReadonlyStore } from \"@/indexing-store/readonly.js\";\nimport { getRealtimeStore } from \"@/indexing-store/realtime.js\";\nimport type { IndexingStore, Status } from \"@/indexing-store/store.js\";\nimport { createIndexingService } from \"@/indexing/index.js\";\nimport { PostgresSyncStore } from \"@/sync-store/postgres/store.js\";\nimport { SqliteSyncStore } from \"@/sync-store/sqlite/store.js\";\nimport type { SyncStore } from \"@/sync-store/store.js\";\nimport type { Event } from \"@/sync/events.js\";\nimport { decodeEvents } from \"@/sync/events.js\";\nimport { createSyncService } from \"@/sync/index.js\";\nimport {\n  type Checkpoint,\n  isCheckpointEqual,\n  zeroCheckpoint,\n} from \"@/utils/checkpoint.js\";\nimport { never } from \"@/utils/never.js\";\nimport { createQueue } from \"@ponder/common\";\n\nexport type RealtimeEvent =\n  | {\n      type: \"newEvents\";\n      fromCheckpoint: Checkpoint;\n      toCheckpoint: Checkpoint;\n    }\n  | {\n      type: \"reorg\";\n      safeCheckpoint: Checkpoint;\n    }\n  | {\n      type: \"finalize\";\n      checkpoint: Checkpoint;\n    };\n\n/**\n * Starts the sync and indexing services for the specified build.\n */\nexport async function run({\n  common,\n  build,\n  onFatalError,\n  onReloadableError,\n}: {\n  common: Common;\n  build: IndexingBuild;\n  onFatalError: (error: Error) => void;\n  onReloadableError: (error: Error) => void;\n}) {\n  const {\n    buildId,\n    databaseConfig,\n    optionsConfig,\n    networks,\n    sources,\n    graphqlSchema,\n    schema,\n    indexingFunctions,\n  } = build;\n\n  common.options = { ...common.options, ...optionsConfig };\n\n  let database: DatabaseService;\n  let syncStore: SyncStore;\n  let namespaceInfo: NamespaceInfo;\n  let initialCheckpoint: Checkpoint;\n\n  const status: Status = {};\n  for (const network of networks) {\n    status[network.name] = {\n      ready: false,\n      block: null,\n    };\n  }\n\n  if (databaseConfig.kind === \"sqlite\") {\n    const { directory } = databaseConfig;\n    database = new SqliteDatabaseService({ common, directory });\n    [namespaceInfo, initialCheckpoint] = await database\n      .setup({ schema, buildId })\n      .then(({ namespaceInfo, checkpoint }) => [namespaceInfo, checkpoint]);\n\n    syncStore = new SqliteSyncStore({ db: database.syncDb, common });\n  } else {\n    const { poolConfig, schema: userNamespace, publishSchema } = databaseConfig;\n    database = new PostgresDatabaseService({\n      common,\n      poolConfig,\n      userNamespace,\n      publishSchema,\n    });\n    [namespaceInfo, initialCheckpoint] = await database\n      .setup({ schema, buildId })\n      .then(({ namespaceInfo, checkpoint }) => [namespaceInfo, checkpoint]);\n\n    syncStore = new PostgresSyncStore({ db: database.syncDb, common });\n  }\n\n  const metadataStore = getMetadataStore({\n    encoding: database.kind,\n    namespaceInfo,\n    db: database.indexingDb,\n  });\n\n  // This can be a long-running operation, so it's best to do it after\n  // starting the server so the app can become responsive more quickly.\n  await database.migrateSyncStore();\n\n  runCodegen({ common, graphqlSchema });\n\n  // Note: can throw\n  const syncService = await createSyncService({\n    common,\n    syncStore,\n    networks,\n    sources,\n    // Note: this is not great because it references the\n    // `realtimeQueue` which isn't defined yet\n    onRealtimeEvent: (realtimeEvent) => {\n      realtimeQueue.add(realtimeEvent);\n    },\n    onFatalError,\n    initialCheckpoint,\n  });\n\n  const handleEvents = async (events: Event[], toCheckpoint: Checkpoint) => {\n    indexingService.updateTotalSeconds(toCheckpoint);\n\n    if (events.length === 0) return { status: \"success\" } as const;\n\n    return await indexingService.processEvents({ events });\n  };\n\n  const handleReorg = async (safeCheckpoint: Checkpoint) => {\n    await database.revert({\n      checkpoint: safeCheckpoint,\n      namespaceInfo,\n    });\n  };\n\n  const handleFinalize = async (checkpoint: Checkpoint) => {\n    await database.updateFinalizedCheckpoint({ checkpoint });\n  };\n\n  const realtimeQueue = createQueue({\n    initialStart: true,\n    browser: false,\n    concurrency: 1,\n    worker: async (event: RealtimeEvent) => {\n      switch (event.type) {\n        case \"newEvents\": {\n          // Note: statusBlocks should be assigned before any other\n          // asynchronous statements in order to prevent race conditions and\n          // ensure its correctness.\n          const statusBlocks = syncService.getStatusBlocks(event.toCheckpoint);\n\n          for await (const rawEvents of syncStore.getEvents({\n            sources,\n            fromCheckpoint: event.fromCheckpoint,\n            toCheckpoint: event.toCheckpoint,\n          })) {\n            const result = await handleEvents(\n              decodeEvents(syncService, rawEvents),\n              event.toCheckpoint,\n            );\n            if (result.status === \"error\") onReloadableError(result.error);\n          }\n\n          // set status to most recently processed realtime block or end block\n          // for each chain.\n          for (const network of networks) {\n            if (statusBlocks[network.name] !== undefined) {\n              status[network.name]!.block = statusBlocks[network.name]!;\n            }\n          }\n\n          await metadataStore.setStatus(status);\n\n          break;\n        }\n        case \"reorg\":\n          await handleReorg(event.safeCheckpoint);\n          break;\n\n        case \"finalize\":\n          await handleFinalize(event.checkpoint);\n          break;\n\n        default:\n          never(event);\n      }\n    },\n  });\n\n  const readonlyStore = getReadonlyStore({\n    encoding: database.kind,\n    schema,\n    namespaceInfo,\n    db: database.indexingDb,\n    common,\n  });\n\n  const historicalStore = getHistoricalStore({\n    encoding: database.kind,\n    schema,\n    readonlyStore,\n    namespaceInfo,\n    db: database.indexingDb,\n    common,\n    isCacheExhaustive: isCheckpointEqual(zeroCheckpoint, initialCheckpoint),\n  });\n\n  let indexingStore: IndexingStore = historicalStore;\n\n  const indexingService = createIndexingService({\n    indexingFunctions,\n    common,\n    indexingStore,\n    sources,\n    networks,\n    syncService,\n    schema,\n  });\n\n  const start = async () => {\n    syncService.startHistorical();\n\n    // If the initial checkpoint is zero, we need to run setup events.\n    if (isCheckpointEqual(initialCheckpoint, zeroCheckpoint)) {\n      const result = await indexingService.processSetupEvents({\n        sources,\n        networks,\n      });\n      if (result.status === \"killed\") {\n        return;\n      } else if (result.status === \"error\") {\n        onReloadableError(result.error);\n        return;\n      }\n    }\n\n    // Run historical indexing until complete.\n    for await (const {\n      fromCheckpoint,\n      toCheckpoint,\n    } of syncService.getHistoricalCheckpoint()) {\n      for await (const rawEvents of syncStore.getEvents({\n        sources: sources,\n        fromCheckpoint,\n        toCheckpoint,\n      })) {\n        const result = await handleEvents(\n          decodeEvents(syncService, rawEvents),\n          toCheckpoint,\n        );\n\n        if (result.status === \"killed\") {\n          return;\n        } else if (result.status === \"error\") {\n          onReloadableError(result.error);\n          return;\n        }\n      }\n    }\n\n    await historicalStore.flush({ isFullFlush: true });\n\n    // Manually update metrics to fix a UI bug that occurs when the end\n    // checkpoint is between the last processed event and the finalized\n    // checkpoint.\n    common.metrics.ponder_indexing_completed_seconds.set(\n      syncService.checkpoint.blockTimestamp -\n        syncService.startCheckpoint.blockTimestamp,\n    );\n    common.metrics.ponder_indexing_completed_timestamp.set(\n      syncService.checkpoint.blockTimestamp,\n    );\n\n    // Become healthy\n    common.logger.info({\n      service: \"indexing\",\n      msg: \"Completed historical indexing\",\n    });\n\n    if (database.kind === \"postgres\") {\n      await database.publish();\n    }\n    await handleFinalize(syncService.finalizedCheckpoint);\n\n    await database.createIndexes({ schema });\n\n    indexingStore = {\n      ...readonlyStore,\n      ...getRealtimeStore({\n        encoding: database.kind,\n        schema,\n        namespaceInfo,\n        db: database.indexingDb,\n        common,\n      }),\n    };\n\n    indexingService.updateIndexingStore({ indexingStore, schema });\n\n    syncService.startRealtime();\n\n    // set status to ready and set blocks to most recently processed\n    // or end block\n    const statusBlocks = syncService.getStatusBlocks();\n    for (const network of networks) {\n      status[network.name] = {\n        ready: true,\n        block: statusBlocks[network.name] ?? null,\n      };\n    }\n\n    await metadataStore.setStatus(status);\n\n    common.logger.info({\n      service: \"server\",\n      msg: \"Started responding as healthy\",\n    });\n  };\n\n  const startPromise = start();\n\n  return async () => {\n    indexingService.kill();\n    await syncService.kill();\n    realtimeQueue.pause();\n    realtimeQueue.clear();\n    await realtimeQueue.onIdle();\n    await startPromise;\n    await database.kill();\n  };\n}\n","import http from \"node:http\";\nimport type { Common } from \"@/common/common.js\";\nimport type { DatabaseService } from \"@/database/service.js\";\nimport { createDrizzleDb, createDrizzleTables } from \"@/drizzle/runtime.js\";\nimport { graphql } from \"@/graphql/index.js\";\nimport { type PonderRoutes, applyHonoRoutes } from \"@/hono/index.js\";\nimport { getMetadataStore } from \"@/indexing-store/metadata.js\";\nimport { getReadonlyStore } from \"@/indexing-store/readonly.js\";\nimport type { Schema } from \"@/schema/common.js\";\nimport { startClock } from \"@/utils/timer.js\";\nimport { serve } from \"@hono/node-server\";\nimport { Hono } from \"hono\";\nimport { cors } from \"hono/cors\";\nimport { createMiddleware } from \"hono/factory\";\nimport { createHttpTerminator } from \"http-terminator\";\nimport { onError } from \"./error.js\";\n\ntype Server = {\n  hono: Hono;\n  port: number;\n  kill: () => Promise<void>;\n};\n\nexport async function createServer({\n  app: userApp,\n  routes: userRoutes,\n  common,\n  schema,\n  database,\n  dbNamespace,\n}: {\n  app: Hono;\n  routes: PonderRoutes;\n  common: Common;\n  schema: Schema;\n  database: DatabaseService;\n  dbNamespace: string;\n}): Promise<Server> {\n  // Create hono app\n\n  const startTime = Date.now();\n\n  const readonlyStore = getReadonlyStore({\n    encoding: database.kind,\n    schema,\n    namespaceInfo: { userNamespace: dbNamespace },\n    db: database.readonlyDb,\n    common,\n  });\n\n  const metadataStore = getMetadataStore({\n    encoding: database.kind,\n    namespaceInfo: { userNamespace: dbNamespace },\n    db: database.readonlyDb,\n  });\n\n  const metricsMiddleware = createMiddleware(async (c, next) => {\n    const commonLabels = { method: c.req.method, path: c.req.path };\n    common.metrics.ponder_http_server_active_requests.inc(commonLabels);\n    const endClock = startClock();\n\n    try {\n      await next();\n    } finally {\n      const requestSize = Number(c.req.header(\"Content-Length\") ?? 0);\n      const responseSize = Number(c.res.headers.get(\"Content-Length\") ?? 0);\n      const responseDuration = endClock();\n      const status =\n        c.res.status >= 200 && c.res.status < 300\n          ? \"2XX\"\n          : c.res.status >= 300 && c.res.status < 400\n            ? \"3XX\"\n            : c.res.status >= 400 && c.res.status < 500\n              ? \"4XX\"\n              : \"5XX\";\n\n      common.metrics.ponder_http_server_active_requests.dec(commonLabels);\n      common.metrics.ponder_http_server_request_size_bytes.observe(\n        { ...commonLabels, status },\n        requestSize,\n      );\n      common.metrics.ponder_http_server_response_size_bytes.observe(\n        { ...commonLabels, status },\n        responseSize,\n      );\n      common.metrics.ponder_http_server_request_duration_ms.observe(\n        { ...commonLabels, status },\n        responseDuration,\n      );\n    }\n  });\n\n  const db = createDrizzleDb(database);\n  const tables = createDrizzleTables(schema, database, dbNamespace);\n\n  // context required for graphql middleware and hono middleware\n  const contextMiddleware = createMiddleware(async (c, next) => {\n    c.set(\"db\", db);\n    c.set(\"tables\", tables);\n    c.set(\"readonlyStore\", readonlyStore);\n    c.set(\"metadataStore\", metadataStore);\n    c.set(\"schema\", schema);\n    await next();\n  });\n\n  const hono = new Hono()\n    .use(metricsMiddleware)\n    .use(cors({ origin: \"*\", maxAge: 86400 }))\n    .get(\"/metrics\", async (c) => {\n      try {\n        const metrics = await common.metrics.getMetrics();\n        return c.text(metrics);\n      } catch (error) {\n        return c.json(error as Error, 500);\n      }\n    })\n    .get(\"/health\", async (c) => {\n      const status = await metadataStore.getStatus();\n\n      if (\n        status !== null &&\n        Object.values(status).every(({ ready }) => ready === true)\n      ) {\n        return c.text(\"\", 200);\n      }\n\n      const elapsed = (Date.now() - startTime) / 1000;\n      const max = common.options.maxHealthcheckDuration;\n\n      if (elapsed > max) {\n        common.logger.warn({\n          service: \"server\",\n          msg: `Historical indexing duration has exceeded the max healthcheck duration of ${max} seconds (current: ${elapsed}). Sevice is now responding as healthy and may serve incomplete data.`,\n        });\n        return c.text(\"\", 200);\n      }\n\n      return c.text(\"Historical indexing is not complete.\", 503);\n    })\n    .get(\"/status\", async (c) => {\n      const status = await metadataStore.getStatus();\n\n      return c.json(status);\n    })\n    .use(contextMiddleware);\n\n  if (userRoutes.length === 0 && userApp.routes.length === 0) {\n    // apply graphql middleware if no custom api exists\n    hono.use(\"/graphql\", graphql());\n    hono.use(\"/\", graphql());\n  } else {\n    // apply user routes to hono instance, registering a custom error handler\n    applyHonoRoutes(hono, userRoutes, { db, tables }).onError((error, c) =>\n      onError(error, c, common),\n    );\n\n    common.logger.debug({\n      service: \"server\",\n      msg: `Detected a custom server with routes: [${userRoutes\n        .map(({ pathOrHandlers: [maybePathOrHandler] }) => maybePathOrHandler)\n        .filter((maybePathOrHandler) => typeof maybePathOrHandler === \"string\")\n        .join(\", \")}]`,\n    });\n\n    hono.route(\"/\", userApp);\n  }\n\n  // Create nodejs server\n\n  let port = common.options.port;\n\n  const createServerWithNextAvailablePort: typeof http.createServer = (\n    ...args: any\n  ) => {\n    const httpServer = http.createServer(...args);\n\n    const errorHandler = (error: Error & { code: string }) => {\n      if (error.code === \"EADDRINUSE\") {\n        common.logger.warn({\n          service: \"server\",\n          msg: `Port ${port} was in use, trying port ${port + 1}`,\n        });\n        port += 1;\n        setTimeout(() => {\n          httpServer.close();\n          httpServer.listen(port, common.options.hostname);\n        }, 5);\n      }\n    };\n\n    const listenerHandler = () => {\n      common.metrics.ponder_http_server_port.set(port);\n      common.logger.info({\n        service: \"server\",\n        msg: `Started listening on port ${port}`,\n      });\n      httpServer.off(\"error\", errorHandler);\n    };\n\n    httpServer.on(\"error\", errorHandler);\n    httpServer.on(\"listening\", listenerHandler);\n\n    return httpServer;\n  };\n\n  const httpServer = await new Promise<http.Server>((resolve, reject) => {\n    const timeout = setTimeout(() => {\n      reject(new Error(\"HTTP server failed to start within 5 seconds.\"));\n    }, 5_000);\n\n    const httpServer = serve(\n      {\n        fetch: hono.fetch,\n        createServer: createServerWithNextAvailablePort,\n        port,\n        // Note that common.options.hostname can be undefined if the user did not specify one.\n        // In this case, Node.js uses `::` if IPv6 is available and `0.0.0.0` otherwise.\n        // https://nodejs.org/api/net.html#serverlistenport-host-backlog-callback\n        hostname: common.options.hostname,\n      },\n      () => {\n        clearTimeout(timeout);\n        resolve(httpServer as http.Server);\n      },\n    );\n  });\n\n  const terminator = createHttpTerminator({\n    server: httpServer,\n    gracefulTerminationTimeout: 1000,\n  });\n\n  return {\n    hono,\n    port,\n    kill: () => terminator.terminate(),\n  };\n}\n","import type { DatabaseService } from \"@/database/service.js\";\nimport type { Scalar, Schema } from \"@/schema/common.js\";\nimport {\n  isEnumColumn,\n  isJSONColumn,\n  isListColumn,\n  isMaterialColumn,\n  isOptionalColumn,\n  isReferenceColumn,\n  isScalarColumn,\n} from \"@/schema/utils.js\";\nimport { getTables } from \"@/schema/utils.js\";\nimport { drizzle as drizzleSQLite } from \"drizzle-orm/better-sqlite3\";\nimport { drizzle as drizzlePg } from \"drizzle-orm/node-postgres\";\nimport { pgSchema, pgTable } from \"drizzle-orm/pg-core\";\nimport {\n  doublePrecision as PgDoublePrecision,\n  integer as PgInteger,\n  jsonb as PgJsonb,\n  numeric as PgNumeric,\n  text as PgText,\n} from \"drizzle-orm/pg-core\";\nimport {\n  integer as SQLiteInteger,\n  real as SQLiteReal,\n  text as SQLiteText,\n  sqliteTable,\n} from \"drizzle-orm/sqlite-core\";\nimport { SQLiteBigintBuilder } from \"./bigint.js\";\nimport { PgHexBuilder, SQLiteHexBuilder } from \"./hex.js\";\nimport { SQLiteJsonBuilder } from \"./json.js\";\nimport { PgListBuilder, SQLiteListBuilder } from \"./list.js\";\n\nexport const createDrizzleDb = (database: DatabaseService) => {\n  if (database.kind === \"postgres\") {\n    const drizzle = drizzlePg(database.readonlyPool);\n    return {\n      // @ts-ignore\n      select: (...args: any[]) => drizzle.select(...args),\n      execute: (query: any) => drizzle.execute(query),\n    };\n  } else {\n    const drizzle = drizzleSQLite(database.readonlyDatabase);\n    return {\n      // @ts-ignore\n      select: (...args: any[]) => drizzle.select(...args),\n      execute: (query: any) => {\n        try {\n          try {\n            return drizzle.all(query);\n          } catch (e) {\n            const error = e as Error;\n            if (\n              error.name === \"SqliteError\" &&\n              error.message ===\n                \"This statement does not return data. Use run() instead\"\n            ) {\n              return drizzle.run(query);\n            } else {\n              throw error;\n            }\n          }\n        } catch (e) {\n          const error = e as Error;\n          if (error.cause) throw error.cause;\n          throw error;\n        }\n      },\n    };\n  }\n};\n\ntype SQLiteTable = Parameters<typeof sqliteTable>[1];\ntype PostgresTable = Parameters<typeof pgTable>[1];\ntype DrizzleTable = { [tableName: string]: any };\n\nexport const createDrizzleTables = (\n  schema: Schema,\n  database: DatabaseService,\n  dbNamespace: string,\n) => {\n  const drizzleTables: { [tableName: string]: DrizzleTable } = {};\n\n  for (const [tableName, { table }] of Object.entries(getTables(schema))) {\n    const drizzleColumns: DrizzleTable = {};\n\n    for (const [columnName, column] of Object.entries(table)) {\n      if (isMaterialColumn(column)) {\n        if (isJSONColumn(column)) {\n          drizzleColumns[columnName] = convertJsonColumn(\n            columnName,\n            database.kind,\n          );\n        } else if (isEnumColumn(column)) {\n          if (isListColumn(column)) {\n            drizzleColumns[columnName] = convertListColumn(\n              columnName,\n              database.kind,\n              \"string\",\n            );\n          } else {\n            drizzleColumns[columnName] = convertEnumColumn(\n              columnName,\n              database.kind,\n            );\n          }\n        } else if (isScalarColumn(column) || isReferenceColumn(column)) {\n          if (isListColumn(column)) {\n            drizzleColumns[columnName] = convertListColumn(\n              columnName,\n              database.kind,\n              column[\" scalar\"],\n            );\n          } else {\n            switch (column[\" scalar\"]) {\n              case \"string\":\n                drizzleColumns[columnName] = convertStringColumn(\n                  columnName,\n                  database.kind,\n                );\n                break;\n\n              case \"int\":\n                drizzleColumns[columnName] = convertIntColumn(\n                  columnName,\n                  database.kind,\n                );\n                break;\n\n              case \"boolean\":\n                drizzleColumns[columnName] = convertBooleanColumn(\n                  columnName,\n                  database.kind,\n                );\n                break;\n\n              case \"float\":\n                drizzleColumns[columnName] = convertFloatColumn(\n                  columnName,\n                  database.kind,\n                );\n                break;\n\n              case \"hex\":\n                drizzleColumns[columnName] = convertHexColumn(\n                  columnName,\n                  database.kind,\n                );\n                break;\n\n              case \"bigint\":\n                drizzleColumns[columnName] = convertBigintColumn(\n                  columnName,\n                  database.kind,\n                );\n                break;\n            }\n          }\n\n          // apply column constraints\n          if (columnName === \"id\") {\n            drizzleColumns[columnName] =\n              drizzleColumns[columnName]!.primaryKey();\n          } else if (isOptionalColumn(column) === false) {\n            drizzleColumns[columnName] = drizzleColumns[columnName]!.notNull();\n          }\n        }\n      }\n    }\n\n    if (database.kind === \"postgres\") {\n      // Note: this is to avoid an error thrown by drizzle when\n      // setting schema to \"public\".\n      if (dbNamespace === \"public\") {\n        drizzleTables[tableName] = pgTable(\n          tableName,\n          drizzleColumns as PostgresTable,\n        );\n      } else {\n        drizzleTables[tableName] = pgSchema(dbNamespace).table(\n          tableName,\n          drizzleColumns as PostgresTable,\n        );\n      }\n    } else {\n      drizzleTables[tableName] = sqliteTable(\n        tableName,\n        drizzleColumns as SQLiteTable,\n      );\n    }\n  }\n\n  return drizzleTables;\n};\n\nconst convertStringColumn = (\n  columnName: string,\n  kind: \"sqlite\" | \"postgres\",\n) => {\n  return kind === \"sqlite\" ? SQLiteText(columnName) : PgText(columnName);\n};\n\nconst convertIntColumn = (columnName: string, kind: \"sqlite\" | \"postgres\") => {\n  return kind === \"sqlite\" ? SQLiteInteger(columnName) : PgInteger(columnName);\n};\n\nconst convertFloatColumn = (\n  columnName: string,\n  kind: \"sqlite\" | \"postgres\",\n) => {\n  return kind === \"sqlite\"\n    ? SQLiteReal(columnName)\n    : PgDoublePrecision(columnName);\n};\n\nconst convertBooleanColumn = (\n  columnName: string,\n  kind: \"sqlite\" | \"postgres\",\n) => {\n  return kind === \"sqlite\" ? SQLiteInteger(columnName) : PgInteger(columnName);\n};\n\nconst convertHexColumn = (columnName: string, kind: \"sqlite\" | \"postgres\") => {\n  return kind === \"sqlite\"\n    ? new SQLiteHexBuilder(columnName)\n    : new PgHexBuilder(columnName);\n};\n\nconst convertBigintColumn = (\n  columnName: string,\n  kind: \"sqlite\" | \"postgres\",\n) => {\n  return kind === \"sqlite\"\n    ? new SQLiteBigintBuilder(columnName)\n    : PgNumeric(columnName, { precision: 78 });\n};\n\nconst convertListColumn = (\n  columnName: string,\n  kind: \"sqlite\" | \"postgres\",\n  element: Scalar,\n) => {\n  return kind === \"sqlite\"\n    ? new SQLiteListBuilder(columnName, element)\n    : new PgListBuilder(columnName, element);\n};\n\nconst convertJsonColumn = (columnName: string, kind: \"sqlite\" | \"postgres\") => {\n  return kind === \"sqlite\"\n    ? new SQLiteJsonBuilder(columnName)\n    : PgJsonb(columnName);\n};\n\nconst convertEnumColumn = (columnName: string, kind: \"sqlite\" | \"postgres\") => {\n  return kind === \"sqlite\" ? SQLiteText(columnName) : PgText(columnName);\n};\n","import { decodeToBigInt, encodeAsText } from \"@/utils/encoding.js\";\nimport { entityKind } from \"drizzle-orm\";\nimport {\n  type AnySQLiteTable,\n  SQLiteColumn,\n  SQLiteColumnBuilder,\n} from \"drizzle-orm/sqlite-core\";\n\nexport class SQLiteBigintBuilder extends SQLiteColumnBuilder {\n  static readonly [entityKind]: string = \"SQliteBigintBuilder\";\n\n  constructor(columnName: string) {\n    super(columnName, \"string\", \"SQLiteBigint\");\n  }\n\n  build(table: AnySQLiteTable) {\n    return new SQLiteBigint(table, this.config);\n  }\n}\n\nexport class SQLiteBigint extends SQLiteColumn {\n  static readonly [entityKind]: string = \"SQLiteBigint\";\n\n  getSQLType(): string {\n    return \"varchar(79)\";\n  }\n\n  override mapFromDriverValue(value: string) {\n    return decodeToBigInt(value);\n  }\n\n  override mapToDriverValue(value: bigint): string {\n    return encodeAsText(value as bigint);\n  }\n}\n","import { entityKind } from \"drizzle-orm\";\nimport {\n  type AnyPgTable,\n  PgColumn,\n  PgColumnBuilder,\n} from \"drizzle-orm/pg-core\";\nimport {\n  type AnySQLiteTable,\n  SQLiteColumn,\n  SQLiteColumnBuilder,\n} from \"drizzle-orm/sqlite-core\";\nimport { bytesToHex, hexToBytes } from \"viem\";\n\nexport class PgHexBuilder extends PgColumnBuilder {\n  static readonly [entityKind]: string = \"PgHexBuilder\";\n\n  constructor(columnName: string) {\n    super(columnName, \"buffer\", \"PgHex\");\n  }\n\n  build(table: AnyPgTable) {\n    return new PgHex(table, this.config);\n  }\n}\n\nexport class PgHex extends PgColumn {\n  static readonly [entityKind]: string = \"PgHex\";\n\n  getSQLType(): string {\n    return \"bytea\";\n  }\n\n  override mapFromDriverValue(value: Buffer) {\n    return bytesToHex(value);\n  }\n\n  override mapToDriverValue(value: `0x${string}`): Buffer {\n    return Buffer.from(hexToBytes(value));\n  }\n}\n\nexport class SQLiteHexBuilder extends SQLiteColumnBuilder {\n  static readonly [entityKind]: string = \"SQliteHexBuilder\";\n\n  constructor(columnName: string) {\n    super(columnName, \"buffer\", \"SQLiteHex\");\n  }\n\n  build(table: AnySQLiteTable) {\n    return new SQLiteHex(table, this.config);\n  }\n}\n\nexport class SQLiteHex extends SQLiteColumn {\n  static readonly [entityKind]: string = \"SQLiteHex\";\n\n  getSQLType(): string {\n    return \"blob\";\n  }\n\n  override mapFromDriverValue(value: Buffer) {\n    return bytesToHex(value);\n  }\n\n  override mapToDriverValue(value: `0x${string}`): Buffer {\n    return Buffer.from(hexToBytes(value));\n  }\n}\n","import { entityKind } from \"drizzle-orm\";\nimport {\n  type AnySQLiteTable,\n  SQLiteColumn,\n  SQLiteColumnBuilder,\n} from \"drizzle-orm/sqlite-core\";\n\nexport class SQLiteJsonBuilder extends SQLiteColumnBuilder {\n  static readonly [entityKind]: string = \"SQliteJsonBuilder\";\n\n  constructor(columnName: string) {\n    super(columnName, \"json\", \"SQLiteJson\");\n  }\n\n  build(table: AnySQLiteTable) {\n    return new SQLiteJson(table, this.config);\n  }\n}\n\nexport class SQLiteJson extends SQLiteColumn {\n  static readonly [entityKind]: string = \"SQLiteJson\";\n\n  getSQLType(): string {\n    return \"jsonb\";\n  }\n\n  override mapFromDriverValue(value: string) {\n    return JSON.parse(value);\n  }\n\n  override mapToDriverValue(value: object): string {\n    return JSON.stringify(value);\n  }\n}\n","import type { Scalar } from \"@/schema/common.js\";\nimport { entityKind } from \"drizzle-orm\";\nimport {\n  type AnyPgTable,\n  PgColumn,\n  PgColumnBuilder,\n} from \"drizzle-orm/pg-core\";\nimport {\n  type AnySQLiteTable,\n  SQLiteColumn,\n  SQLiteColumnBuilder,\n} from \"drizzle-orm/sqlite-core\";\n\nexport class PgListBuilder extends PgColumnBuilder {\n  static readonly [entityKind]: string = \"PgListBuilder\";\n  element: Scalar;\n\n  constructor(columnName: string, element: Scalar) {\n    super(columnName, \"string\", \"PgList\");\n    this.element = element;\n  }\n\n  build(table: AnyPgTable) {\n    return new PgList(table, this.config, this.element);\n  }\n}\n\nexport class PgList extends PgColumn {\n  static readonly [entityKind]: string = \"PgList\";\n  element: Scalar;\n\n  constructor(\n    table: AnyPgTable,\n    config: PgListBuilder[\"config\"],\n    element: Scalar,\n  ) {\n    super(table, config);\n    this.element = element;\n  }\n\n  getSQLType(): string {\n    return \"text\";\n  }\n\n  override mapFromDriverValue(value: string) {\n    return this.element === \"bigint\"\n      ? JSON.parse(value).map(BigInt)\n      : JSON.parse(value);\n  }\n\n  override mapToDriverValue(value: Array<unknown>): string {\n    return this.element === \"bigint\"\n      ? JSON.stringify(value.map(String))\n      : JSON.stringify(value);\n  }\n}\n\nexport class SQLiteListBuilder extends SQLiteColumnBuilder {\n  static readonly [entityKind]: string = \"SQliteListBuilder\";\n  element: Scalar;\n\n  constructor(columnName: string, element: Scalar) {\n    super(columnName, \"string\", \"PgList\");\n    this.element = element;\n  }\n\n  build(table: AnySQLiteTable) {\n    return new SQLiteList(table, this.config, this.element);\n  }\n}\n\nexport class SQLiteList extends SQLiteColumn {\n  static readonly [entityKind]: string = \"SQLiteList\";\n  element: Scalar;\n\n  constructor(\n    table: AnyPgTable,\n    config: SQLiteListBuilder[\"config\"],\n    element: Scalar,\n  ) {\n    super(table, config);\n    this.element = element;\n  }\n\n  getSQLType(): string {\n    return \"text\";\n  }\n\n  override mapFromDriverValue(value: string) {\n    return this.element === \"bigint\"\n      ? JSON.parse(value).map(BigInt)\n      : JSON.parse(value);\n  }\n\n  override mapToDriverValue(value: Array<unknown>): string {\n    return this.element === \"bigint\"\n      ? JSON.stringify(value.map(String))\n      : JSON.stringify(value);\n  }\n}\n","import type { Hono } from \"hono\";\nimport type { Handler, MiddlewareHandler } from \"./handler.js\";\n\nexport type PonderRoutes = {\n  method: \"GET\" | \"POST\" | \"USE\";\n  pathOrHandlers: [\n    maybePathOrHandler: string | Handler | MiddlewareHandler,\n    ...handlers: (Handler | MiddlewareHandler)[],\n  ];\n}[];\n\nexport const applyHonoRoutes = (\n  hono: Hono,\n  routes: PonderRoutes,\n  customContext?: object,\n) => {\n  // add custom properties to hono context\n  const addCustomContext =\n    (handler: Handler | MiddlewareHandler) => (c: any, next: any) => {\n      for (const key of Object.keys(customContext ?? {})) {\n        // @ts-ignore\n        c[key] = customContext![key];\n      }\n\n      return handler(c, next);\n    };\n\n  for (const {\n    method,\n    pathOrHandlers: [maybePathOrHandler, ...handlers],\n  } of routes) {\n    let path = \"/\";\n    if (method === \"GET\" || method === \"POST\") {\n      // register collected \"GET\" or \"POST\" path + handlers to the underlying hono instance\n      // from https://github.com/honojs/hono/blob/main/src/hono-base.ts#L125-L142\n      if (typeof maybePathOrHandler === \"string\") {\n        path = maybePathOrHandler;\n      } else {\n        // @ts-expect-error access private property\n        hono.addRoute(method, path, addCustomContext(maybePathOrHandler));\n      }\n\n      for (const handler of handlers) {\n        if (typeof handler !== \"string\") {\n          // @ts-expect-error access private property\n          hono.addRoute(method, path, addCustomContext(handler));\n        }\n      }\n    } else {\n      // register collected middleware to the underlying hono instance\n      // from: https://github.com/honojs/hono/blob/main/src/hono-base.ts#L158-L169\n      if (typeof maybePathOrHandler === \"string\") {\n        path = maybePathOrHandler;\n      } else {\n        path = \"*\";\n        handlers.unshift(maybePathOrHandler);\n      }\n      for (const handler of handlers) {\n        // @ts-expect-error access private property\n        hono.addRoute(\"ALL\", path, addCustomContext(handler));\n      }\n    }\n  }\n\n  return hono;\n};\n","import type { Common } from \"@/common/common.js\";\nimport type { BaseError } from \"@/common/errors.js\";\nimport { addStackTrace } from \"@/indexing/addStackTrace.js\";\nimport { prettyPrint } from \"@/utils/print.js\";\nimport type { Context, HonoRequest } from \"hono\";\nimport { html } from \"hono/html\";\n\nexport const onError = async (_error: Error, c: Context, common: Common) => {\n  const error = _error as BaseError;\n\n  // Find the filename where the error occurred\n  const regex = /(\\S+\\.(?:js|ts|mjs|cjs)):\\d+:\\d+/;\n  const matches = error.stack?.match(regex);\n  const errorFile = (() => {\n    if (!matches?.[0]) return undefined;\n    const path = matches[0].trim();\n    if (path.startsWith(\"(\")) {\n      return path.slice(1);\n    } else if (path.startsWith(\"file://\")) {\n      return path.slice(7);\n    }\n    return path;\n  })();\n\n  addStackTrace(error, common.options);\n\n  error.meta = Array.isArray(error.meta) ? error.meta : [];\n  error.meta.push(\n    `Request:\\n${prettyPrint({\n      path: c.req.path,\n      method: c.req.method,\n      body: await tryExtractRequestBody(c.req),\n    })}`,\n  );\n\n  common.logger.warn({\n    service: \"server\",\n    msg: `An error occurred while handling a '${c.req.method}' request to the route '${c.req.path}'`,\n    error,\n  });\n\n  // 500: Internal Server Error\n  return c.text(\n    `${error.name}: ${error.message} occurred in '${errorFile}' while handling a '${c.req.method}' request to the route '${c.req.path}'`,\n    500,\n  );\n};\n\nexport const onNotFound = (c: Context) => {\n  return c.html(\n    html`<!doctype html>\n      <h1>Bad news!</h1>\n      <p>The route \"<code>${c.req.path}</code>\" does not exist</p>`,\n  );\n};\n\nconst tryExtractRequestBody = async (request: HonoRequest) => {\n  try {\n    return await request.json();\n  } catch {\n    try {\n      const text = await request.text();\n      if (text !== \"\") return text;\n    } catch {}\n  }\n  return undefined;\n};\n","import type { ApiBuild } from \"@/build/index.js\";\nimport type { Common } from \"@/common/common.js\";\nimport { PostgresDatabaseService } from \"@/database/postgres/service.js\";\nimport type { DatabaseService } from \"@/database/service.js\";\nimport { SqliteDatabaseService } from \"@/database/sqlite/service.js\";\nimport { createServer } from \"@/server/service.js\";\n\n/**\n * Starts the server for the specified build.\n */\nexport async function runServer({\n  common,\n  build,\n}: {\n  common: Common;\n  build: ApiBuild;\n}) {\n  const { databaseConfig, optionsConfig, schema } = build;\n\n  common.options = { ...common.options, ...optionsConfig };\n\n  let database: DatabaseService;\n\n  if (databaseConfig.kind === \"sqlite\") {\n    const { directory } = databaseConfig;\n    database = new SqliteDatabaseService({ common, directory });\n  } else {\n    const { poolConfig, schema: userNamespace, publishSchema } = databaseConfig;\n    database = new PostgresDatabaseService({\n      common,\n      poolConfig,\n      userNamespace,\n      publishSchema,\n    });\n  }\n\n  const server = await createServer({\n    app: build.app,\n    routes: build.routes,\n    common,\n    schema,\n    database,\n    dbNamespace:\n      databaseConfig.kind === \"sqlite\" ? \"public\" : databaseConfig.schema,\n  });\n\n  return async () => {\n    await server.kill();\n  };\n}\n","import path from \"node:path\";\nimport { createBuildService } from \"@/build/index.js\";\nimport { createLogger } from \"@/common/logger.js\";\nimport { MetricsService } from \"@/common/metrics.js\";\nimport { buildOptions } from \"@/common/options.js\";\nimport { buildPayload, createTelemetry } from \"@/common/telemetry.js\";\nimport { PostgresDatabaseService } from \"@/database/postgres/service.js\";\nimport { createServer } from \"@/server/service.js\";\nimport type { CliOptions } from \"../ponder.js\";\nimport { setupShutdown } from \"../utils/shutdown.js\";\n\nexport async function serve({ cliOptions }: { cliOptions: CliOptions }) {\n  const options = buildOptions({ cliOptions });\n\n  const logger = createLogger({\n    level: options.logLevel,\n    mode: options.logFormat,\n  });\n\n  const [major, minor, _patch] = process.versions.node\n    .split(\".\")\n    .map(Number) as [number, number, number];\n  if (major < 18 || (major === 18 && minor < 14)) {\n    logger.fatal({\n      service: \"process\",\n      msg: `Invalid Node.js version. Expected >=18.14, detected ${major}.${minor}.`,\n    });\n    await logger.kill();\n    process.exit(1);\n  }\n\n  const configRelPath = path.relative(options.rootDir, options.configFile);\n  logger.debug({\n    service: \"app\",\n    msg: `Started using config file: ${configRelPath}`,\n  });\n\n  const metrics = new MetricsService();\n  const telemetry = createTelemetry({ options, logger });\n  const common = { options, logger, metrics, telemetry };\n\n  const buildService = await createBuildService({ common });\n\n  let cleanupReloadable = () => Promise.resolve();\n\n  const cleanup = async () => {\n    await cleanupReloadable();\n    await telemetry.kill();\n  };\n\n  const shutdown = setupShutdown({ common, cleanup });\n\n  const { api, indexing } = await buildService.start({ watch: false });\n  // Once we have the initial build, we can kill the build service.\n  await buildService.kill();\n\n  if (api.status === \"error\" || indexing.status === \"error\") {\n    await shutdown({ reason: \"Failed intial build\", code: 1 });\n    return cleanup;\n  }\n\n  telemetry.record({\n    name: \"lifecycle:session_start\",\n    properties: {\n      cli_command: \"serve\",\n      ...buildPayload(indexing.build),\n    },\n  });\n\n  const { databaseConfig, optionsConfig, schema } = api.build;\n\n  common.options = { ...common.options, ...optionsConfig };\n\n  if (databaseConfig.kind === \"sqlite\") {\n    await shutdown({\n      reason: \"The 'ponder serve' command does not support SQLite\",\n      code: 1,\n    });\n    return cleanup;\n  }\n\n  if (databaseConfig.publishSchema === undefined) {\n    await shutdown({\n      reason: \"The 'ponder serve' command requires 'publishSchema' to be set\",\n      code: 1,\n    });\n    return cleanup;\n  }\n\n  const { poolConfig, schema: userNamespace } = databaseConfig;\n  const database = new PostgresDatabaseService({\n    common,\n    poolConfig,\n    userNamespace,\n    // Ensures that the `readonly` connection pool gets\n    // allocated the maximum number of connections.\n    isReadonly: true,\n  });\n\n  const server = await createServer({\n    app: api.build.app,\n    routes: api.build.routes,\n    common,\n    schema,\n    database,\n    dbNamespace: databaseConfig.publishSchema,\n  });\n\n  cleanupReloadable = async () => {\n    await server.kill();\n    await database.kill();\n  };\n\n  return cleanup;\n}\n","import path from \"node:path\";\nimport { createBuildService } from \"@/build/index.js\";\nimport { createLogger } from \"@/common/logger.js\";\nimport { MetricsService } from \"@/common/metrics.js\";\nimport { buildOptions } from \"@/common/options.js\";\nimport { buildPayload, createTelemetry } from \"@/common/telemetry.js\";\nimport type { CliOptions } from \"../ponder.js\";\nimport { run } from \"../utils/run.js\";\nimport { runServer } from \"../utils/runServer.js\";\nimport { setupShutdown } from \"../utils/shutdown.js\";\n\nexport async function start({ cliOptions }: { cliOptions: CliOptions }) {\n  const options = buildOptions({ cliOptions });\n\n  const logger = createLogger({\n    level: options.logLevel,\n    mode: options.logFormat,\n  });\n\n  const [major, minor, _patch] = process.versions.node\n    .split(\".\")\n    .map(Number) as [number, number, number];\n  if (major < 18 || (major === 18 && minor < 14)) {\n    logger.fatal({\n      service: \"process\",\n      msg: `Invalid Node.js version. Expected >=18.14, detected ${major}.${minor}.`,\n    });\n    await logger.kill();\n    process.exit(1);\n  }\n\n  const configRelPath = path.relative(options.rootDir, options.configFile);\n  logger.debug({\n    service: \"app\",\n    msg: `Started using config file: ${configRelPath}`,\n  });\n\n  const metrics = new MetricsService();\n  const telemetry = createTelemetry({ options, logger });\n  const common = { options, logger, metrics, telemetry };\n\n  const buildService = await createBuildService({ common });\n\n  let cleanupReloadable = () => Promise.resolve();\n  let cleanupReloadableServer = () => Promise.resolve();\n\n  const cleanup = async () => {\n    await cleanupReloadable();\n    await cleanupReloadableServer();\n    await telemetry.kill();\n  };\n\n  const shutdown = setupShutdown({ common, cleanup });\n\n  const { indexing, api } = await buildService.start({ watch: false });\n  // Once we have the initial build, we can kill the build service.\n  await buildService.kill();\n\n  if (indexing.status === \"error\" || api.status === \"error\") {\n    await shutdown({ reason: \"Failed intial build\", code: 1 });\n    return cleanup;\n  }\n\n  telemetry.record({\n    name: \"lifecycle:session_start\",\n    properties: {\n      cli_command: \"start\",\n      ...buildPayload(indexing.build),\n    },\n  });\n\n  cleanupReloadable = await run({\n    common,\n    build: indexing.build,\n    onFatalError: () => {\n      shutdown({ reason: \"Received fatal error\", code: 1 });\n    },\n    onReloadableError: () => {\n      shutdown({ reason: \"Encountered indexing error\", code: 1 });\n    },\n  });\n\n  cleanupReloadableServer = await runServer({\n    common,\n    build: api.build,\n  });\n\n  return cleanup;\n}\n"],"mappings":"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","names":["readFileSync","create","methods","params","path","getEventSelector","transport","symbol","resolve","resolve","_parameters","startBlockMaybeNan","startBlock","endBlockMaybeNan","endBlock","intervalMaybeNan","interval","columnName","tableName","column","file","path","path","file","hash","path","totalBlocks","cachedBlocks","completedBlocks","progress","path","createHash","readFileSync","os","path","start","hash","createHash","packageJson","os","kill","path","packageJsonPath","readFileSync","os","os","existsSync","path","Box","Text","React","Text","React","React","Box","Text","ui","createHash","sql","prometheus","migrations","StaticMigrationProvider","migrationProvider","migrationProvider","finalizedCheckpoint","result","sql","prometheus","existsSync","path","sql","migrations","StaticMigrationProvider","migrationProvider","existsSync","mkdirSync","path","dirname","Migrator","WithSchemaPlugin","sql","prometheus","migrations","StaticMigrationProvider","migrationProvider","path","Migrator","WithSchemaPlugin","migrationProvider","finalizedCheckpoint","result","sql","scalarToSqlType","prometheus","existsSync","sql","column","columnName","record","query","records","db","sql","create","sql","columnName","query","sql","records","records","create","record","readFileSync","codeFrameColumns","parseStackTrace","path","create","create","kill","methods","create","kill","start","start2","blockNumber","start","sql","checksumAddress","hexToBigInt","hexToNumber","sql","query","hexToNumber","hexToBigInt","checksumAddress","fs","start","sql","checksumAddress","hexToBigInt","hexToNumber","hexToNumber","sql","buildFactoryChildAddressSelectExpression","query","hexToNumber","hexToBigInt","checksumAddress","fs","start","BlockNotFoundError","numberToHex","createQueue","onError","hexToNumber","resolve","queue","createQueue","logs","fromBlock","toBlock","traces","hash","hexToNumber","hexToBytes","hash","hexToNumber","hash","create","start","hexToNumber","kill","hash","fs","methods","start","kill","create","hexToBigInt","isHex","RETRY_COUNT","BASE_DURATION","isHex","hexToBigInt","hexToBigInt","hexToNumber","hexToBigInt","create","hexToNumber","hexToBigInt","startCheckpoint","kill","methods","kill","create","numberToHex","BlockNotFoundError","hash","namespaceInfo","handleReorg","start","entityKind","SQLiteColumn","SQLiteColumnBuilder","bytesToHex","hexToBytes","entityKind","SQLiteColumn","SQLiteColumnBuilder","entityKind","PgColumn","PgColumnBuilder","SQLiteColumn","SQLiteColumnBuilder","query","path","path","createServer","httpServer","resolve","createServer","existsSync","path","path","serve","path","createServer","path","start","path","readFileSync","start","serve"]}
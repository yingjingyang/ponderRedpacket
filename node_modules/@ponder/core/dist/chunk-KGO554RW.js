// src/ui/graphiql.html.ts
var graphiQLHtml = (path) => `<!--
 *  Copyright (c) 2021 GraphQL Contributors
 *  All rights reserved.
 *
 *  This source code is licensed under the license found in the
 *  LICENSE file in the root directory of this source tree.
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Ponder Playground</title>
    <style>
      body {
        height: 100%;
        margin: 0;
        width: 100%;
        overflow: hidden;
      }
      #graphiql {
        height: 100vh;
      }
      *::-webkit-scrollbar {
        height: 0.3rem;
        width: 0.5rem;
      }
      *::-webkit-scrollbar-track {
        -ms-overflow-style: none;
        overflow: -moz-scrollbars-none;
      }
      *::-webkit-scrollbar-thumb {
        -ms-overflow-style: none;
        overflow: -moz-scrollbars-none;
      }
    </style>
    <link rel="stylesheet" href="https://unpkg.com/graphiql/graphiql.min.css" />
    <link rel="stylesheet" href="https://unpkg.com/@graphiql/plugin-explorer/dist/style.css" />
  </head>
  <body>
    <div id="graphiql">Loading...</div>
    <script crossorigin src="https://unpkg.com/react/umd/react.development.js"></script>1
    <script crossorigin src="https://unpkg.com/react-dom/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/graphiql/graphiql.min.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@graphiql/plugin-explorer/dist/index.umd.js" crossorigin="anonymous"></script>
    <script>
      const fetcher = GraphiQL.createFetcher({ url: "${path}" });
      const explorerPlugin = GraphiQLPluginExplorer.explorerPlugin();
      const root = ReactDOM.createRoot(document.getElementById("graphiql"));
      root.render(
        React.createElement(GraphiQL, {
          fetcher,
          plugins: [explorerPlugin],
          defaultEditorToolsVisibility: false,
        })
      );
    </script>
  </body>
</html>`;

// src/graphql/index.ts
import { maxAliasesPlugin } from "@escape.tech/graphql-armor-max-aliases";
import { maxDepthPlugin } from "@escape.tech/graphql-armor-max-depth";
import { maxTokensPlugin } from "@escape.tech/graphql-armor-max-tokens";
import { createYoga } from "graphql-yoga";
import { createMiddleware } from "hono/factory";

// src/schema/utils.ts
var isScalarColumn = (column) => column[" type"] === "scalar";
var isReferenceColumn = (column) => column[" type"] === "reference";
var isOneColumn = (column) => column[" type"] === "one";
var isManyColumn = (column) => column[" type"] === "many";
var isJSONColumn = (column) => column[" type"] === "json";
var isEnumColumn = (column) => column[" type"] === "enum";
var isOptionalColumn = (column) => {
  if (isManyColumn(column) || isOneColumn(column))
    return false;
  return column[" optional"];
};
var isListColumn = (column) => {
  if (isManyColumn(column) || isOneColumn(column) || isReferenceColumn(column) || isJSONColumn(column))
    return false;
  return column[" list"];
};
var isMaterialColumn = (column) => isScalarColumn(column) || isReferenceColumn(column) || isEnumColumn(column) || isJSONColumn(column);
var isTable = (tableOrEnum) => !Array.isArray(tableOrEnum);
var isEnum = (tableOrEnum) => Array.isArray(tableOrEnum);
var getTables = (schema) => {
  const tables = {};
  for (const [name, tableOrEnum] of Object.entries(schema)) {
    if (isTable(tableOrEnum)) {
      tables[name] = tableOrEnum;
    }
  }
  return tables;
};
var getEnums = (schema) => {
  const enums = {};
  for (const [name, tableOrEnum] of Object.entries(schema)) {
    if (isEnum(tableOrEnum)) {
      enums[name] = tableOrEnum;
    }
  }
  return enums;
};
var extractReferenceTable = (ref) => {
  return ref[" reference"].split(".")[0];
};
var encodeSchema = (schema) => {
  return JSON.stringify({
    tables: getTables(schema),
    enums: getEnums(schema)
  });
};

// src/graphql/buildGraphqlSchema.ts
import {
  GraphQLObjectType as GraphQLObjectType3,
  GraphQLSchema
} from "graphql";

// src/graphql/entity.ts
import {
  GraphQLBoolean as GraphQLBoolean2
} from "graphql";
import {
  GraphQLInt as GraphQLInt2,
  GraphQLList as GraphQLList2,
  GraphQLNonNull,
  GraphQLObjectType,
  GraphQLString as GraphQLString2
} from "graphql";

// src/common/errors.ts
var BaseError = class _BaseError extends Error {
  name = "BaseError";
  meta = [];
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, _BaseError.prototype);
  }
};
function getBaseError(err) {
  if (err instanceof BaseError)
    return err;
  if (err instanceof Error)
    return new BaseError(err.message);
  if (typeof err?.message === "string")
    return new BaseError(err.message);
  if (typeof err === "string")
    return new BaseError(err);
  return new BaseError("unknown error");
}
var BuildError = class _BuildError extends BaseError {
  name = "BuildError";
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, _BuildError.prototype);
  }
};
var NonRetryableError = class _NonRetryableError extends BaseError {
  name = "NonRetryableError";
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, _NonRetryableError.prototype);
  }
};
var IgnorableError = class _IgnorableError extends BaseError {
  name = "IgnorableError";
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, _IgnorableError.prototype);
  }
};
var StoreError = class _StoreError extends NonRetryableError {
  name = "StoreError";
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, _StoreError.prototype);
  }
};
var UniqueConstraintError = class _UniqueConstraintError extends NonRetryableError {
  name = "UniqueConstraintError";
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, _UniqueConstraintError.prototype);
  }
};
var NotNullConstraintError = class _NotNullConstraintError extends NonRetryableError {
  name = "NotNullConstraintError";
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, _NotNullConstraintError.prototype);
  }
};
var RecordNotFoundError = class _RecordNotFoundError extends NonRetryableError {
  name = "RecordNotFoundError";
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, _RecordNotFoundError.prototype);
  }
};
var CheckConstraintError = class _CheckConstraintError extends NonRetryableError {
  name = "CheckConstraintError";
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, _CheckConstraintError.prototype);
  }
};
var BigIntSerializationError = class _BigIntSerializationError extends NonRetryableError {
  name = "BigIntSerializationError";
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, _BigIntSerializationError.prototype);
  }
};
var FlushError = class _FlushError extends NonRetryableError {
  name = "FlushError";
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, _FlushError.prototype);
  }
};

// src/graphql/filter.ts
import {
  GraphQLInputObjectType
} from "graphql";
import { GraphQLList } from "graphql";

// src/graphql/scalar.ts
import {
  GraphQLBoolean,
  GraphQLFloat,
  GraphQLInt,
  GraphQLScalarType,
  GraphQLString
} from "graphql";
var GraphQLBigInt = new GraphQLScalarType({
  name: "BigInt",
  serialize: (value) => String(value),
  parseValue: (value) => BigInt(value),
  parseLiteral: (value) => {
    if (value.kind === "StringValue") {
      return BigInt(value.value);
    } else {
      throw new BuildError(
        `Invalid value kind provided for field of type BigInt: ${value.kind}. Expected: StringValue`
      );
    }
  }
});
var SCALARS = {
  int: GraphQLInt,
  float: GraphQLFloat,
  string: GraphQLString,
  boolean: GraphQLBoolean,
  bigint: GraphQLBigInt,
  hex: GraphQLString
};

// src/graphql/filter.ts
var filterOperators = {
  universal: ["", "_not"],
  singular: ["_in", "_not_in"],
  plural: ["_has", "_not_has"],
  numeric: ["_gt", "_lt", "_gte", "_lte"],
  string: [
    "_contains",
    "_not_contains",
    "_starts_with",
    "_ends_with",
    "_not_starts_with",
    "_not_ends_with"
  ]
};
var buildEntityFilterTypes = ({
  schema,
  enumTypes
}) => {
  const entityFilterTypes = {};
  for (const [tableName, { table }] of Object.entries(getTables(schema))) {
    const filterType = new GraphQLInputObjectType({
      name: `${tableName}Filter`,
      fields: () => {
        const filterFields = {
          // Logical operators
          AND: { type: new GraphQLList(filterType) },
          OR: { type: new GraphQLList(filterType) }
        };
        Object.entries(table).forEach(([columnName, column]) => {
          if (isOneColumn(column))
            return;
          if (isManyColumn(column))
            return;
          if (isJSONColumn(column))
            return;
          const type = isEnumColumn(column) ? enumTypes[column[" enum"]] : SCALARS[column[" scalar"]];
          if (isListColumn(column)) {
            filterOperators.universal.forEach((suffix) => {
              filterFields[`${columnName}${suffix}`] = {
                type: new GraphQLList(type)
              };
            });
            filterOperators.plural.forEach((suffix) => {
              filterFields[`${columnName}${suffix}`] = {
                type
              };
            });
          } else {
            filterOperators.universal.forEach((suffix) => {
              filterFields[`${columnName}${suffix}`] = {
                type
              };
            });
            filterOperators.singular.forEach((suffix) => {
              filterFields[`${columnName}${suffix}`] = {
                type: new GraphQLList(type)
              };
            });
            if ((isScalarColumn(column) || isReferenceColumn(column)) && ["int", "bigint", "float", "hex"].includes(column[" scalar"])) {
              filterOperators.numeric.forEach((suffix) => {
                filterFields[`${columnName}${suffix}`] = {
                  type
                };
              });
            }
            if ((isScalarColumn(column) || isReferenceColumn(column)) && "string" === column[" scalar"]) {
              filterOperators.string.forEach((suffix) => {
                filterFields[`${columnName}${suffix}`] = {
                  type
                };
              });
            }
          }
        });
        return filterFields;
      }
    });
    entityFilterTypes[tableName] = filterType;
  }
  return { entityFilterTypes };
};
var graphqlFilterToStoreCondition = {
  "": "equals",
  not: "not",
  in: "in",
  not_in: "notIn",
  has: "has",
  not_has: "notHas",
  gt: "gt",
  lt: "lt",
  gte: "gte",
  lte: "lte",
  contains: "contains",
  not_contains: "notContains",
  starts_with: "startsWith",
  not_starts_with: "notStartsWith",
  ends_with: "endsWith",
  not_ends_with: "notEndsWith"
};
function buildWhereObject(where) {
  const whereObject = {};
  for (const [whereKey, rawValue] of Object.entries(where)) {
    if (whereKey === "AND" || whereKey === "OR") {
      if (!Array.isArray(rawValue)) {
        throw new BuildError(
          `Invalid query: Expected an array for the ${whereKey} operator. Got: ${rawValue}`
        );
      }
      whereObject[whereKey] = rawValue.map(buildWhereObject);
      continue;
    }
    const [fieldName, condition_] = whereKey.split(/_(.*)/s);
    const condition = condition_ === void 0 ? "" : condition_;
    const storeCondition = graphqlFilterToStoreCondition[condition];
    if (!storeCondition) {
      throw new BuildError(
        `Invalid query: Unknown where condition: ${fieldName}_${condition}`
      );
    }
    whereObject[fieldName] ||= {};
    whereObject[fieldName][storeCondition] = rawValue;
  }
  return whereObject;
}

// src/graphql/graphQLJson.ts
import {
  GraphQLScalarType as GraphQLScalarType2,
  Kind,
  print
} from "graphql";
var GraphQLJSON = new GraphQLScalarType2({
  name: "JSON",
  description: "The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).",
  serialize: (x) => x,
  parseValue: (x) => x,
  parseLiteral: (ast, variables) => {
    if (ast.kind !== Kind.OBJECT) {
      throw new TypeError(
        `JSONObject cannot represent non-object value: ${print(ast)}`
      );
    }
    return parseObject(ast, variables);
  }
});
var parseLiteral = (ast, variables) => {
  switch (ast.kind) {
    case Kind.STRING:
    case Kind.BOOLEAN:
      return ast.value;
    case Kind.INT:
    case Kind.FLOAT:
      return Number.parseFloat(ast.value);
    case Kind.OBJECT:
      return parseObject(ast, variables);
    case Kind.LIST:
      return ast.values.map((n) => parseLiteral(n, variables));
    case Kind.NULL:
      return null;
    case Kind.VARIABLE:
      return variables ? variables[ast.name.value] : void 0;
    default:
      throw new TypeError(`JSON cannot represent value: ${print(ast)}`);
  }
};
var parseObject = (ast, variables) => {
  const value = /* @__PURE__ */ Object.create(null);
  ast.fields.forEach((field) => {
    value[field.name.value] = parseLiteral(field.value, variables);
  });
  return value;
};

// src/graphql/entity.ts
var GraphQLPageInfo = new GraphQLObjectType({
  name: "PageInfo",
  fields: {
    hasNextPage: { type: new GraphQLNonNull(GraphQLBoolean2) },
    hasPreviousPage: { type: new GraphQLNonNull(GraphQLBoolean2) },
    startCursor: { type: GraphQLString2 },
    endCursor: { type: GraphQLString2 }
  }
});
var buildEntityTypes = ({
  schema,
  enumTypes,
  entityFilterTypes
}) => {
  const entityTypes = {};
  const entityPageTypes = {};
  for (const [tableName, { table }] of Object.entries(getTables(schema))) {
    entityTypes[tableName] = new GraphQLObjectType({
      name: tableName,
      fields: () => {
        const fieldConfigMap = {};
        Object.entries(table).forEach(([columnName, column]) => {
          if (isOneColumn(column)) {
            const referenceColumn = table[column[" reference"]];
            const referencedTable = extractReferenceTable(referenceColumn);
            const resolver = async (parent, _args, context) => {
              const relatedRecordId = parent[column[" reference"]];
              if (relatedRecordId === null || relatedRecordId === void 0)
                return null;
              const loader = context.getLoader({
                tableName: referencedTable
              });
              return await loader.load(relatedRecordId);
            };
            fieldConfigMap[columnName] = {
              type: isOptionalColumn(referenceColumn) ? entityTypes[referencedTable] : new GraphQLNonNull(entityTypes[referencedTable]),
              resolve: resolver
            };
          } else if (isManyColumn(column)) {
            const resolver = async (parent, args, context) => {
              const { where, orderBy, orderDirection, limit, after, before } = args;
              const whereObject = where ? buildWhereObject(where) : {};
              (whereObject[column[" referenceColumn"]] ??= {}).equals = parent.id;
              const orderByObject = orderBy ? { [orderBy]: orderDirection ?? "asc" } : void 0;
              const result = await context.readonlyStore.findMany({
                tableName: column[" referenceTable"],
                where: whereObject,
                orderBy: orderByObject,
                limit,
                before,
                after
              });
              const loader = context.getLoader({
                tableName: column[" referenceTable"]
              });
              const ids = result.items.map((item) => item.id);
              const items = await loader.loadMany(ids);
              return { items, pageInfo: result.pageInfo };
            };
            fieldConfigMap[columnName] = {
              type: entityPageTypes[column[" referenceTable"]],
              args: {
                where: { type: entityFilterTypes[column[" referenceTable"]] },
                orderBy: { type: GraphQLString2 },
                orderDirection: { type: GraphQLString2 },
                before: { type: GraphQLString2 },
                after: { type: GraphQLString2 },
                limit: { type: GraphQLInt2 }
              },
              resolve: resolver
            };
          } else if (isJSONColumn(column)) {
            fieldConfigMap[columnName] = {
              type: isOptionalColumn(column) ? GraphQLJSON : new GraphQLNonNull(GraphQLJSON)
            };
          } else {
            const type = isEnumColumn(column) ? enumTypes[column[" enum"]] : SCALARS[column[" scalar"]];
            if (isListColumn(column)) {
              const listType = new GraphQLList2(new GraphQLNonNull(type));
              fieldConfigMap[columnName] = {
                type: isOptionalColumn(column) ? listType : new GraphQLNonNull(listType)
              };
            } else {
              fieldConfigMap[columnName] = {
                type: isOptionalColumn(column) ? type : new GraphQLNonNull(type)
              };
            }
          }
        });
        return fieldConfigMap;
      }
    });
    entityPageTypes[tableName] = new GraphQLObjectType({
      name: `${tableName}Page`,
      fields: () => ({
        items: {
          type: new GraphQLNonNull(
            new GraphQLList2(new GraphQLNonNull(entityTypes[tableName]))
          )
        },
        pageInfo: { type: new GraphQLNonNull(GraphQLPageInfo) }
      })
    });
  }
  return { entityTypes, entityPageTypes };
};

// src/graphql/enum.ts
import { GraphQLEnumType } from "graphql";
function buildEnumTypes({ schema }) {
  const enumTypes = {};
  for (const [enumName, _enum] of Object.entries(getEnums(schema))) {
    enumTypes[enumName] = new GraphQLEnumType({
      name: enumName,
      values: _enum.reduce(
        (acc, cur) => ({ ...acc, [cur]: {} }),
        {}
      )
    });
  }
  return { enumTypes };
}

// src/graphql/metadata.ts
import { GraphQLObjectType as GraphQLObjectType2 } from "graphql";
var metadataEntity = new GraphQLObjectType2({
  name: "_meta",
  fields: { status: { type: GraphQLJSON } }
});

// src/graphql/plural.ts
import {
  GraphQLInt as GraphQLInt3,
  GraphQLNonNull as GraphQLNonNull2,
  GraphQLString as GraphQLString3
} from "graphql";
var buildPluralField = ({
  tableName,
  entityPageType,
  entityFilterType
}) => {
  const resolver = async (_, args, context) => {
    const { where, orderBy, orderDirection, before, limit, after } = args;
    const whereObject = where ? buildWhereObject(where) : {};
    const orderByObject = orderBy ? { [orderBy]: orderDirection || "asc" } : void 0;
    return await context.readonlyStore.findMany({
      tableName,
      where: whereObject,
      orderBy: orderByObject,
      limit,
      before,
      after
    });
  };
  return {
    type: new GraphQLNonNull2(entityPageType),
    args: {
      where: { type: entityFilterType },
      orderBy: { type: GraphQLString3 },
      orderDirection: { type: GraphQLString3 },
      before: { type: GraphQLString3 },
      after: { type: GraphQLString3 },
      limit: { type: GraphQLInt3 }
    },
    resolve: resolver
  };
};

// src/graphql/singular.ts
import {
  GraphQLNonNull as GraphQLNonNull3
} from "graphql";
var buildSingularField = ({
  tableName,
  table,
  entityType
}) => {
  const resolver = async (_, args, context) => {
    const { id } = args;
    if (id === void 0)
      return null;
    const entityInstance = await context.readonlyStore.findUnique({
      tableName,
      id
    });
    return entityInstance;
  };
  return {
    type: entityType,
    args: {
      id: { type: new GraphQLNonNull3(SCALARS[table.id[" scalar"]]) }
    },
    resolve: resolver
  };
};

// src/graphql/buildGraphqlSchema.ts
var buildGraphQLSchema = (schema) => {
  const queryFields = {};
  const { enumTypes } = buildEnumTypes({ schema });
  const { entityFilterTypes } = buildEntityFilterTypes({ schema, enumTypes });
  const { entityTypes, entityPageTypes } = buildEntityTypes({
    schema,
    enumTypes,
    entityFilterTypes
  });
  for (const [tableName, { table }] of Object.entries(getTables(schema))) {
    const entityType = entityTypes[tableName];
    const entityPageType = entityPageTypes[tableName];
    const entityFilterType = entityFilterTypes[tableName];
    const singularFieldName = tableName.charAt(0).toLowerCase() + tableName.slice(1);
    queryFields[singularFieldName] = buildSingularField({
      tableName,
      table,
      entityType
    });
    const pluralFieldName = `${singularFieldName}s`;
    queryFields[pluralFieldName] = buildPluralField({
      tableName,
      entityPageType,
      entityFilterType
    });
  }
  queryFields._meta = {
    type: metadataEntity,
    resolve: async (_source, _args, context) => {
      const status = await context.metadataStore.getStatus();
      return { status };
    }
  };
  return new GraphQLSchema({
    query: new GraphQLObjectType3({
      name: "Query",
      fields: queryFields
    })
  });
};

// src/graphql/buildLoaderCache.ts
import DataLoader from "dataloader";
function buildLoaderCache({ store }) {
  const loaderCache = {};
  return ({ tableName }) => {
    const loader = loaderCache[tableName] ??= new DataLoader(
      async (ids) => {
        const rows = await store.findMany({
          tableName,
          where: { id: { in: ids } },
          limit: ids.length
        });
        return ids.map((id) => rows.items.find((row) => row.id === id));
      },
      { maxBatchSize: 1e3 }
    );
    return loader;
  };
}

// src/graphql/index.ts
var graphql = ({
  maxOperationTokens = 1e3,
  maxOperationDepth = 100,
  maxOperationAliases = 30
} = {
  // Default limits are from Apollo:
  // https://www.apollographql.com/blog/prevent-graph-misuse-with-operation-size-and-complexity-limit
  maxOperationTokens: 1e3,
  maxOperationDepth: 100,
  maxOperationAliases: 30
}) => {
  let yoga = void 0;
  return createMiddleware(async (c) => {
    if (c.req.method === "GET") {
      return c.html(graphiQLHtml(c.req.path));
    }
    if (yoga === void 0) {
      const readonlyStore = c.get("readonlyStore");
      const metadataStore = c.get("metadataStore");
      const schema = c.get("schema");
      const graphqlSchema = buildGraphQLSchema(schema);
      yoga = createYoga({
        schema: graphqlSchema,
        context: () => {
          const getLoader = buildLoaderCache({ store: readonlyStore });
          return { readonlyStore, metadataStore, getLoader };
        },
        graphqlEndpoint: c.req.path,
        maskedErrors: process.env.NODE_ENV === "production",
        logging: false,
        graphiql: false,
        parserAndValidationCache: false,
        plugins: [
          maxTokensPlugin({ n: maxOperationTokens }),
          maxDepthPlugin({
            n: maxOperationDepth,
            ignoreIntrospection: false
          }),
          maxAliasesPlugin({
            n: maxOperationAliases,
            allowList: []
          })
        ]
      });
    }
    const response = await yoga.handle(c.req.raw);
    response.status = 200;
    response.statusText = "OK";
    return response;
  });
};

export {
  isScalarColumn,
  isReferenceColumn,
  isOneColumn,
  isManyColumn,
  isJSONColumn,
  isEnumColumn,
  isOptionalColumn,
  isListColumn,
  isMaterialColumn,
  getTables,
  getEnums,
  extractReferenceTable,
  encodeSchema,
  getBaseError,
  BuildError,
  NonRetryableError,
  IgnorableError,
  StoreError,
  UniqueConstraintError,
  NotNullConstraintError,
  RecordNotFoundError,
  CheckConstraintError,
  BigIntSerializationError,
  FlushError,
  buildGraphQLSchema,
  graphql
};
//# sourceMappingURL=chunk-KGO554RW.js.map